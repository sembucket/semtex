/*
 * Mortar Functions
 *
 * Special utility package for Mortar patching
 *
 * Restrictions
 * ------------
 * To guarantee existence and uniqueness of the solution generated by this
 * formulation, no two adjacent sides can have types M-S, i.e., every mesh
 * must pass the following patch test:
 *
 *      if ( ( (type[iedge] == 'M') && (type[(iedge+1)%4] == 'S') ) ||
 *             (type[iedge] == 'S') && (type[(iedge+1)%4] == 'M') )
 *
 *         { speclib_error ("This mesh fails the adjacent-sides patch test") }
 *
 *
 * References
 *
 * [0] Ron Henderson, "Unstructured Spectral Element Methods: Algorithms
 *     and Simulations", Ph.D. dissertation, Princeton University (1994).
 *
 * [1] George Anagnostou, "Nonconforming Sliding Spectral Element Methods
 *     for the Unsteady Incompressible Navier-Stokes Equations", Ph.D. 
 *     dissertation, M.I.T. (1991).
 *
 * [2] Catherine Andria Mavriplis, "Nonconforming Discretizations and
 *     a Posteriori Error Estimators for Adaptive Spectral Element
 *     Techniques", Ph.D. dissertation, M.I.T. (1989).
 *
 *
 * RCS Information
 * --------------------------
 * $Author$
 * $Date$
 * $RCSfile$
 * $Revision$
 * ------------------------------------------------------------------------ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>

#include "veclib/veclib.h"
#include "speclib/speclib.h"
#include "mortar/mortar.h"

/* Options (1 = on, 0 = off) */

#define NOADJSIDES  0        /* Allow M-S on adjacent sides  */
#define CURVESIDES  1        /* Allow patches to be curved   */
#define GENERALIZE  0        /* Allow general patches        */

/* Error tolerance */

#define EPSILON 1.e-6

/* Private functions */

Branch         *make_branch   (int id, double s0, double L, Mortar *m, 
			       Branch *link),
               *sort_branches (Branch *link);
Segment        *make_segment  (int id, char type, Edge *, Element *, Patch *,
			       Segment*link),
               *find_segment  (char type, int ielmt, int iedge, Patch *P),
               *sort_seglist  (Segment *list);
Mortar         *make_mortar   (int id, Edge *edge, Element *elmt, 
			       Mortar *link),
               *sort_mortars  (Mortar *list);

int             count_mnodes  (Mortar *mlist);
int             count_pnodes  (Patch  *plist);

static Patch   *lookup        (int, Patch*), 
               *install       (int, Patch*);

static void     build_mesh    (Segment *S), 
                build_mortars (Patch   *P), 
                build_branches(Segment *S, Mortar *M),
   
                check_patches (Patch   *P),

                project_s_m   (Segment *M, Segment *S),
                project_m_s   (Segment *M, Segment *S);
               
static void     seg_gathr_z   (Element *U, Segment *S, double *u),
                seg_scatr_z   (Element *U, Segment *S, double *u);

static double   eta    (int q, double z, double *xi, int n);
static double** form_q (int n, int m, double s0, double gamma_p, 
			         double gamma_s, double gamma_k);


/* ............................  S E T U P  ............................... */


/* ------------------------------------------------------------------------ *
 * eta() -- The mortar test function of order N-2, eqn. (2.29)              *
 * ------------------------------------------------------------------------ */

#define SIGN(n)   (1.-2.*((n) % 2))

static double eta (int q, double z, double *zgll, int n)
{
  const double alpha = n * (n + 1.);
  const double dz    = zgll[q] - z;

  if (fabs(dz*dz) < EPSILON)
    return SIGN(n-q-1) * pnd2leg(z,n);
  if (fabs(z*z - 1.) < EPSILON)
    return SIGN(n-q) * pow(z, n-1) * alpha * 0.5 / dz;
  else
    return SIGN(n-q) * pndleg(z,n) / dz;
}

#undef SIGN

/* ------------------------------------------------------------------------ *
 * form_q() -- Form the projection operator                                 *
 *                                                                          *
 * Input:   n   ...   order of the polynomial along the edges (nr|ns - 1)   *
 *          m   ...   order of the polynomial along the mortar              *
 *          s0  ...   mortar offset                                         *
 *                                                                          *
 * The "gamma_x" arguments are the length of the mortar (p), the integra-   *
 * tion strip (s), and the element edge (k).  The mortar offset is the      *
 * signed distance from the edge of the ELEMENT to the edge of the MORTAR   *
 * (see below).                                                             *
 *                                                                          *
 *                        | o    o     o     o    o |  element edge         *
 *                                                                          *
 *   |<------  s0  -------|=========================|  integration strip    *
 *       (i.e, s0 < 0)                                                      *
 *   |..........................................................| mortar    *
 *                                                                          *
 * ------------------------------------------------------------------------ */

static double **form_q 
  (int n, int m, double s0, double gamma_p, double gamma_s, double gamma_k)
{
  const double tol = EPSILON;

  const int np  = n + 1;
  const int mp  = m + 1;

  double **q = dmatrix(0, n, 0, m);
  double *z1 = dvector(0, n);
  double *z2 = dvector(0, n);
  double *zs, *zm, *w, **d, fac;

  int i, j, k;

  /* Get collocation points & weights for the integration */

  getops (mp, &zm, &w, &d, &d);
  getops (np, &zs, &w, &d, &d);
  dzero  (np*mp, *q, 1);

  /* Compute the quadrature points along the integration strip */

  for (i = 0; i < np; i++) {
    z1[i] = (1. + zs[i]) * gamma_s / gamma_k - 1.;
    z2[i] = (1. + zs[i]) * gamma_s / gamma_p - 1.;
  }

  if (s0*s0 > tol*gamma_p) {
    if (s0 >= 0.) {
      fac = 2. * fabs(s0) / gamma_k;
      dsadd(np, fac, z1, 1, z1, 1);
    } else {
      fac = 2. * fabs(s0) / gamma_p;
      dsadd(np, fac, z2, 1, z2, 1);
    }
  }

  /* Compute the P-operator from eqns. (2.32-2.33) */

  fac = gamma_s / 2.;
  for (i = 1; i < n; i++)
    for (j = 0; j <= m; j++)
      for (k = 0; k <= m; k++)
	q[i][j] += fac * w[k] * eta(i, z1[k], zs, n) * hgll(j, z2[k], zm, mp);


  /* Enforce the vertex pinning conditions, eqn. (2.18-2.19) */

  fac = gamma_k / 2.;
  if (s0 < tol) {
    for (i = 1; i < n; i++)
      for (j = 0; j <= m; j++)
	q[i][j] -= fac * w[0] * eta(i, z1[0], zs, n) * hgll(j, z2[0], zm, mp);
    
    for (i = 0, j = 0; j <= m; j++)        /* Vertex condition */
      q[i][j] = hgll(j, z2[i], zm, mp);
  }


  /* Convert s0 to an offset from the other end and check that one */

  s0 = gamma_k - (s0 + gamma_p);
  if (s0 < tol) {
    for (i = 1; i < n; i++)
      for (j = 0; j <= m; j++)
	q[i][j] -= fac * w[n] * eta(i, z1[n], zs, n) * hgll(j, z2[n], zm, mp);

    for (i = n, j = 0; j <= m; j++)        /* Vertex condition */
      q[i][j] = hgll (j, z2[i], zm, mp);
  }

  /* Now divide by the B-operator, eqn. (2.31) */

  for (i = 1; i < n; i++) {
    fac = 1. / (.5 * gamma_k * w[i] * eta(i, zs[i], zs, n));
    dscal (mp, fac, q[i], 1);
  }


  free (z1);
  free (z2);
  return q;
}


/****************************************************************************
 *                                                                          *
 *                            Patching Functions                            *
 *                                                                          *
 * The following functions operate on the Patch structure that groups the   *
 * element segments and the mortar segments together.                       *
 *                                                                          *
 ****************************************************************************/

Patch *build_patches (Element *U, FILE *fp)
{
  Patch   *new_list = (Patch*) NULL;
  Patch   *p;
  Edge    *edge;
  Element *elmt;
  char    type, buf[BUFSIZ], *sp;

  int k, l, id_p, id_s;

  /* Process the lines one at a time until EOF */

  while (fgets(buf, BUFSIZ, fp)) {

    if (*buf == '#') continue;  /* Comment */

    for (sp = buf; isspace(*sp); sp++)
      /* empty for loop */ ;

    type = *sp++;

    if (sscanf (sp, "%d%d%d%d", &k, &l, &id_p, &id_s) != 4) {
      fprintf (stderr, "prePatch(): bad line: %s\n", buf);
      continue;
    }

    elmt = Element_get  (U, --k);
    edge = Element_edge (elmt, --l);

    if (!(p = lookup (id_p, new_list)))
          p = lookup (id_p, new_list = install (id_p, new_list));

    switch (type) {
    case 'M':
      p->masters = make_segment(id_s, type, edge, elmt, p, p->masters);
      break;
    case 'S':
      p->slaves  = make_segment(id_s, type, edge, elmt, p, p->slaves);
      break;
    default:
      fprintf (stderr, "prePatch(): unknown type: %c\n", type);
      break;
    }
  }


  for (p = new_list; p; p = p->next) {
    p->masters = sort_seglist (p->masters);
    p->slaves  = sort_seglist (p->slaves);

    build_mesh     (p->masters);
    build_mesh     (p->slaves);
    build_mortars  (p);

    build_branches (p->masters, p->mortars);
    build_branches (p->slaves , p->mortars);

    p->x0 = *(*p->masters->elmt->xmesh + p->masters->edge->start);
    p->y0 = *(*p->masters->elmt->ymesh + p->masters->edge->start);
  }

  check_patches (new_list);
  return new_list;
}

/* Check to see if this patch system satisfies all restrictions */

static void check_patches (Patch *list)
{
  Patch   *p;
  Segment *s;

  /* Adjacent-sides test */

  for (p = list; p ; p = p ->next)
    for (s = p->slaves; s ; s = s->next) {
      
#if NOADJSIDES
      if (find_segment ('M', iel, next, list) ||
	  find_segment ('M', iel, prev, list))
	fprintf (stderr, 
		 "check_patches: WARNING: fails the adjacent-sides test on "
		 "Patch %d [K = %d, face = %d]\n",
		  p->id, iel+1, iedge+1);
#endif
    }
}


static Patch *lookup (int id, Patch *plist)
{
  Patch *p;

  for (p = plist; p; p = p->next) 
    if (p->id == id) 
      break;

  return p;
}

static Patch *install (int id, Patch *link)
{
  Patch *list = link;
  Patch *new;

  if ((new = (Patch*) calloc(1, sizeof(Patch))) == (Patch*) NULL) {
    fputs("install (patch): out of memory\n", stderr);
    exit (-1);
  }

  new->id = id;
  if (link) {
    while (link->next) link = link->next;
    link->next = new;
    new ->next = NULL;
  } 
    else (list = new)->next = link;

  return list;
}

/****************************************************************************
 *                                                                          *
 *                             Segment Functions                            *
 *                                                                          *
 * The following functions allow operations on element segments - creation, *
 * deletion, lookup, and sorting (by ID number).                            *
 *                                                                          *
 ****************************************************************************/

Segment *make_segment 
  (int id, char type, Edge *edge, Element *elmt, Patch *parent, Segment *link)
{
  const int np = edge->np;
  int n = edge->np - 1;

  double  *w;
  Segment *new;

  if ((new = (Segment*) calloc(1, sizeof(Segment))) == (Segment*) NULL) {
    fputs("make_segment: out of memory\n", stderr);
    exit (-1);
  }

  getops (np, NULL, &w, NULL, NULL);

  new->id      = id;
  new->type    = type;
  new->n       = n;
  new->mesh    = dvector(0, n);
  new->u       = dvector(0, n);
  new->edge    = edge;
  new->parent  = parent;
  new->elmt    = elmt;
  new->next    = link;

#if CURVESIDES
  new->gamma_k = ddot(np, w, 1, edge->area, 1);
#else
#define SQR(a) ((a)*(a))
  { double *xx = (*elmt->xmesh) + edge->start,
           *yy = (*elmt->ymesh) + edge->start;
    
    new->gamma_k = sqrt( SQR(xx[n*edge->skip] - xx[0]) +
			 SQR(yy[n*edge->skip] - yy[0]) );
  }
#undef  SQR
#endif
  
  dzero (np, new->u, 1);

  return new;
}

/* ------------------------------------------------------------------------ *
 * find_segment() -- Segment Match                                          *
 *                                                                          *
 * Search for a segment of the given type connecting to edge "iedge" of     *
 * element "ielmt" among all of the patches.                                *
 *                                                                          *
 * Return: NULL if no segment is found, otherwise a pointer to the matched  *
 *         segment.                                                         *
 * ------------------------------------------------------------------------ */

Segment *find_segment (char type, int iel, int iedge, Patch *P)
{
  Segment *match;

  if (type != 'S' && type != 'M')
    speclib_error ("find_segment(): type should be 'M' or 'S'");

  while (P) {
    match = (type == 'S' ? P->slaves : P->masters);
    while (match)
      if (match->elmt->id == iel && 
	  match->edge->id == iedge) 
	    return match;                      /* ...Found it!    */     
      else match = match->next;                /* ...next segment */
    P = P->next;                               /* ...next patch   */
  }
  
  return match;               /* If we make it here, match = NULL */
}

Segment *sort_seglist (Segment *s)
{
  int   nseg = 0;
  Segment *p = s;
  int i;

  if (!s) return s;

  /* count the # of segments and copy the list */

  for (p = s; p; p = p->next) nseg++;
  p = (Segment*) calloc(nseg, sizeof(Segment));

  for (i = 0; i < nseg; i++) {
    Segment *t = s->next;
    memcpy(p + i, s, sizeof(Segment));
    free(s);
    s = t;
  }
  
  qsort(p, nseg, sizeof(Segment), idcomp);               /* sort    */
  for (i = 0; i < nseg-1; i++) p[i].next = p + i + 1;    /* re-link */
  p[i].next = (Segment*) NULL;
  
  return p;
}

static void build_mesh (Segment *s)
{
  double *z, *w, **d, s0, len;
  int i, np;

  s0 = 0.;
  while (s) {
    np  = s->edge->np;
    len = s->gamma_k;
    
    getops(np, &z, &w, &d, &d);
    for (i = 0; i < np; i++) s->mesh[i] = s0 + len/2. * (z[i] + 1.);

    s0 += len;
    s   = s->next;
  }
}

/* ------------------------------------------------------------------------ *
 * Mortar Functions                                                         *
 *                                                                          *
 * The following functions allow operations on mortars - creation, sorting, *
 * etc.                                                                     *
 * ------------------------------------------------------------------------ */

Mortar *make_mortar (int id, Edge *edge, Element *elmt, Mortar *link)
{
  const int n = edge->np - 1;
  const int np = edge->np;
  double *w;
  Mortar *new;

  if ((new = (Mortar*) calloc(1, sizeof(Mortar))) == (Mortar*) NULL)
    speclib_error ("make_mortar: out of memory");

  getops (np, NULL, &w, NULL, NULL);

  new->id    = id;
  new->n     = n;
  new->mesh  = dvector (0, n);
  new->phi   = dvector (0, n);
  new->solve = ivector (0, n);
  new->edge  = edge;
  new->elmt  = elmt;
  new->next  = link;

#if CURVESIDES
  new->gamma_p = ddot(np, w, 1, edge->area, 1);
#else
#define SQR(a) ((a)*(a))
  { double *xx = (*elmt->xmesh) + edge->start,
           *yy = (*elmt->ymesh) + edge->start;
    
    new->gamma_p = sqrt( SQR(xx[n*edge->skip] - xx[0]) +
			 SQR(yy[n*edge->skip] - yy[0]) );
  }
#undef  SQR
#endif
  
  dzero (np, new->phi,   1);
  izero (np, new->solve, 1);

  return new;
}

/*
 * Build a complete set of mortars from the Master segments of a Patch
 */

static void build_mortars (Patch *p)
{
  Segment *s   = p->masters;
  Mortar  *new = (Mortar*) NULL;

  while (s) {
    new = make_mortar (s->id, s->edge, s->elmt, new);
    dcopy (new->n+1, s->mesh, 1, new->mesh, 1);
    s = s->next;
  }

  p->mortars = sort_mortars(new);
  p->nodes   = count_mnodes(p->mortars);
}

Mortar *sort_mortars (Mortar *s)
{
  int nseg = 0;
  Mortar *p;
  int i;

  if (!s) return s;

  /* count the # of Mortars and copy the list */

  for (p = s; p; p = p->next) nseg++;
  p = (Mortar*) calloc(nseg, sizeof(Mortar));

  for (i = 0; i < nseg; i++) {
    Mortar *t = s->next;
    memcpy(p + i, s, sizeof(Mortar));
    free(s);
    s = t;
  }
  
  qsort(p, nseg, sizeof(Mortar), idcomp);                /* sort    */
  for (i = 0; i < nseg-1; i++) p[i].next = p + i + 1;    /* re-link */
  p[i].next = (Mortar*) NULL;
  
  return p;
}

int count_mnodes (Mortar *mlist)
{
  Mortar *m = mlist;
  int count = 0;

  while (m) {
    count += m->n + 1;
    m      = m->next;
  }

  return count;
}

int count_pnodes (Patch *plist)
{
  Patch  *p = plist;
  int count = 0;

  while (p) {
    count += p->nodes;
    p      = p->next;
  }

  return count;
}

/* ------------------------------------------------------------------------ *
 * Branch Functions                                                         *
 *                                                                          *
 * The following functions allow operations on Branches.  If GENERALIZE is  *
 * on, then a projection matrix is computed for every patch.  Otherwise,    *
 * only two matrices (Z1 and Z2) are needed.                                *
 * ------------------------------------------------------------------------ */

static double **Z1, **Z2;    /* Matrices for restricted meshes */

static void build_branches (Segment *seglist, Mortar *mortarlist)
{
  Segment *s;
  Mortar  *m;
  Branch  *b;
  double  s0, len_p, len_s;
  int     ns, nm, nb;

  for (s = seglist; s; s = s->next) {

    nb = 0;      /* Reset the branch counter            */
    b  = NULL;   /* Initialize the branch to NULL       */
    ns = s->n;   /* Number of points on the slaved edge */

    for (m = mortarlist; m; m = m->next) {      
      nm    = m->n;
      s0    = m->mesh[0] - s->mesh[0]; 
      len_p = m->gamma_p;
      len_s = MIN(s->mesh[ns],m->mesh[nm])-MAX(s->mesh[0],m->mesh[0]);

      /* Check to see if the branch intersects.  If not, go on *
       * to the next mortar.  If it does, create a new branch  *
       * and link it with the others.                          */

      if ( len_s*len_p <= EPSILON ) continue;  
      
      b = make_branch (++nb, s0, len_s, m, b);

      /* Only build the projection matrix for slaved segments */

#if GENERALIZE
      if (s->type == 'S')
	  b->q = form_q (ns, nm, s0, len_p, len_s, s->gamma_k);
#else
      if (s->type == 'S') {
	if (Z1 == NULL || Z2 == NULL) {
	  Z1 = form_q (ns, nm,  0., 2., 1., 1.);   /* Segment 1 */
	  Z2 = form_q (ns, nm, -1., 2., 1., 1.);   /* Segment 2 */
	}

	if ((s0 + EPSILON) > 0.)
	  b->q = Z1;
	else
	  b->q = Z2;
      }
#endif
    }
    
    s->branches = nb;
    s->blist    = sort_branches(b);
  }
}

Branch *make_branch (int id, double s0, double len, Mortar *m, Branch *link)
{
  Branch *new;

  if ((new = (Branch*) calloc(1,sizeof(Branch))) == (Branch*) NULL) {
    fputs("make_branch: out of memory\n", stderr);
    exit (-1);
  }

  new->id      =  id;
  new->s0      =  s0;
  new->gamma_s =  len;
  new->m       =  m;
  new->next    =  link;

  return new;
}

Branch *sort_branches (Branch *b)
{
  int nseg = 0;
  int i;
  Branch *p;

  if (!b) return b;

  /* count the # of Branches and copy the list */

  for (p = b; p; p = p->next) nseg++;
  p = (Branch*) calloc(nseg, sizeof(Branch));

  for (i = 0; i < nseg; i++) {
    Branch *t = b->next;
    memcpy(p + i, b, sizeof(Branch));
    free(b);
    b = t;
  }
  
  qsort(p, nseg, sizeof(Branch), idcomp);                /* sort    */
  for (i = 0; i < nseg-1; i++) p[i].next = p + i + 1;    /* re-link */
  p[i].next = (Branch*) NULL;
  
  return p;
}

/* .........................  P R O C E S S I N G  ........................ */

/* ------------------------------------------------------------------------ *
 * qssum() -- NonConforming Direct-Stiffness Averaging                      *
 *                                                                          *
 * This function averages the solution across all element boundaries, inc-  *
 * nonconforming edges.  The averaging across conforming edges is handled   *
 * through dssum(), and the averaging across nonconforming edges is done    *
 * by first interpolating the solution to the mortars, dividing by the      *
 * mortar multiplicity, and then projecting the solution back via the or-   *
 * thogonal projection matrix Q.                                            *
 * ------------------------------------------------------------------------ */

#undef dssum
#undef dssum3d

void qssum (Element *U, BSystem *M)
{
  const int bpts = M->bpts;
  const int nel  = M->elements;
  const int nb   =(U->nr + U->ns - 2) << 1;

  int **bmap = M->bmap;
  Patch *P = (Patch*) M->other;

  int i, k;

  tempVector (valu, bpts);
  dzero  (bpts, valu, 1);

  /* First pass is to collocate each boundary value with the mass matrix *
   * around the edge of the elements.                                    */

  for (k = 0; k < nel; k++) {
    const int *emap = U[k].emap;
    for (i = 0; i < nb; i++)
      (*U[k].field) [emap[i]] *= (*U[k].mass)[emap[i]];
  }

  Project_s_m (U, P, NULL);          /* Multiply by the transpose */

  for (k = 0; k < nel; k++)          /* Global summation */
    for (i = 0; i < nb; i++)
      valu [bmap[k][i]] += (*U[k].field)[U[k].emap[i]];
  
  dvmul (bpts, M->massinv, 1, valu, 1, valu, 1);     /* Rescale */

  for (k = 0; k < nel; k++)          /* Copy back */
    for (i = 0; i < nb; i++)
      (*U[k].field)[U[k].emap[i]] = valu [bmap[k][i]];

  Project_m_s (U, P, NULL);          /* Project */

  freeVector (valu);                 /* Whew!  All done... */
}

/* A kludgy 3-D version */

void qssum3d (Element *U, BSystem *M)
{
  const int nz  = U->nz;
  int k;

  /* Frame by frame... */

  for (k = 0; k < nz; k++) { 
    Frame_set_one (k, U); 
    qssum (U, M); 
  }
}


/* ------------------------------------------------------------------------ *
 * Project_s_m() -- Projection from elements -> mortars                     *
 *                                                                          *
 * This function essentially multiplies the elemental DOF by the transpose  *
 * of the projection matrix Q.  It is part of the direct-stiffness sum-     *
 * mation.                                                                  *
 * ------------------------------------------------------------------------ */

void Project_s_m (Element *U, Patch *plist, double *u)
{
  Patch  *p;

  for (p = plist; p ; p = p->next) {
    seg_gathr_z (U, p->masters, u);
    seg_gathr_z (U, p->slaves , u);

    project_s_m (p->masters, p->slaves);

    seg_scatr_z (U, p->slaves , u);
    seg_scatr_z (U, p->masters, u);
  }

  return;
}

static void project_s_m (Segment *mlist, Segment *slist)
{
  Segment  *s;       
  Branch   *b;
  double   *u;
  int j, n, mp;

  if (mlist->type != 'M' || slist->type != 'S') 
    speclib_error ("project_s_m called with wrong types form M and S");

  /* master segments are copied directly to initialize the mortars */

  for (s = mlist; s ; s = s->next)
    dcopy (s->n+1, s->u, 1, s->blist->m->phi, 1);

  /* slave segments are projected */

  for (s = slist; s ; s = s->next) {

    u = s->u + 1;
    n = s->n - 1;

    for (b = s->blist; b ; b = b->next)
      dgemv ('N', mp = b->m->n+1, n, 1., *b->q + mp, mp, u, 1, 1., 
	               b->m->phi, 1);
  
    /* --------- virtual vertex contributions ---------- */
    
    b  = s->blist;                 /*  the branch vector */
    n  = s->branches-1;            /*  # of branches - 1 */
    j  = s->n;                     /*  endpoint index    */
    u  = s->u;                     /*  data vector       */
    
    daxpy  (b[0].m->n+1, u[0], b[0].q[0], 1, b[0].m->phi, 1);
    daxpy  (b[n].m->n+1, u[j], b[n].q[j], 1, b[n].m->phi, 1);
  }
  
  /* Now the mortar values are copied back to the masters to be *
   * distributed back to the elements and the slaved segments   *
   * are cleared (masked).                                      */
  
  for (s = mlist; s ; s = s->next)
    dcopy (s->n+1, s->blist->m->phi, 1, s->u, 1);
  for (s = slist; s ; s = s->next)
    dzero (s->n+1, s->u, 1);
  
  return;
}

/* ------------------------------------------------------------------------ *
 * Project_m_s() -- Projection from mortars -> elements                     *
 *                                                                          *
 * This function projects values from the mortar functions back to the ele- *
 * mental edges.  It corresponds to direct multiplication by the projection *
 * matrix Q.                                                                *
 * ------------------------------------------------------------------------ */
 
void Project_m_s (Element *U, Patch *plist, double *u)
{
  Patch *p;

  for (p = plist; p ; p = p->next) {
    seg_gathr_z (U, p->masters, u);
    seg_gathr_z (U, p->slaves , u);

    project_m_s (p->masters, p->slaves);

    seg_scatr_z (U, p->masters, u);
    seg_scatr_z (U, p->slaves , u);
  }

  return;
}

static void project_m_s (Segment *masters, Segment *slaves)
{
  Segment *s;
  Branch  *b;
  double  *u;
  int n, np, nb, mp, i;

  if (masters->type != 'M' || slaves->type != 'S') 
    speclib_error ("project_m_s called with wrong types for M and S");

  /* master segments are copied directly to initialize the mortars */
  
  for (s = masters; s ; s = s->next)
    dcopy (s->n+1, s->u, 1, s->blist->m->phi, 1);
  

  /* slave segments are projected and pinned at the vertices */
  
  for (s = slaves; s ; s = s->next) {
  
    n    = s->n;             /* initialize the segment parameters */
    np   = s->n + 1;
    nb   = s->branches;
    u    = s->u;
    b    = s->blist;

    /* The receiving buffer is cleared on this first projection.  *
     * The endpoints only have to be pinned if there are multiple *
     * branches.                                                  */
    
    dgemv ('T', mp=b->m->n+1, np, 1., *b->q, mp, b->m->phi, 1, 0., u, 1);
    
    if (nb-- > 1) {
      for (i = 1; i <= nb; i++)
	dgemv ('T', mp = b[i].m->n+1, np, 1., *b[i].q, mp, 
	       b[i].m->phi, 1, 1., u, 1);
      
      u[0] = ddot (b[ 0].m->n+1, b[ 0].q[0], 1, b[ 0].m->phi, 1);
      u[n] = ddot (b[nb].m->n+1, b[nb].q[n], 1, b[nb].m->phi, 1);
    } 
  }
}

/* ------------------------------------------------------------------------ *
 * seg_gathr_z() -- Copy from the edges to the segment buffers and zero     *
 * ------------------------------------------------------------------------ */

static void seg_gathr_z (Element *U, Segment *seglist, double *u)
{
  int np, dir, id, start, skip, nrns;
  double  *buf;
  Segment *s;
  
  /* If "u" is undefined, use the Element field */

  if (!u) u = *U->field;

  /* Loop over the segments and copy to local buffers.  The   *
   * edges are zero'd after the copy to make sure that values *
   * are only processed once.                                 */

  nrns   = U->nr * U->ns;
  for (s = seglist; s; s = s->next) {

    np    = s->n + 1;
    start = s->edge->start;
    skip  = s->edge->skip;
    id    = s->elmt->id;

    if (s->type == 'M') {   /* Get the direction for the copy */
      dir = 1;
      buf = s->u;
    } else {
      dir = -1;
      buf = s->u + s->n;
    }

    ecopy (np, u + nrns * id + start, skip, buf, dir);
    dzero (np, u + nrns * id + start, skip);
  }
  return;
}

/* ------------------------------------------------------------------------ *
 * seg_scatr_z() -- Copy from the segment buffers to the edges and clear    *
 * ------------------------------------------------------------------------ */

static void seg_scatr_z (Element *U, Segment *seglist, double *u)
{
  int np, dir, id, start, skip, nrns;
  double  *buf;
  Segment *s;
  
  /* If "u" is undefined, use the Element field */

  if (!u) u = *U->field;

  /* Loop over the segments and copy from local buffers */

  nrns = U->nr * U->ns;
  for (s = seglist; s; s = s->next) {

    np    = s->n + 1;
    start = s->edge->start;
    skip  = s->edge->skip;
    id    = s->elmt->id;

    if (s->type == 'M') {   /* Get the direction for the copy */
      dir = 1;
      buf = s->u;
    } else {
      dir = -1;
      buf = s->u + s->n;
    }

    dvadd (np, buf, dir, u + nrns * id + start, skip,
                         u + nrns * id + start, skip);
  }
}

/* ------------------------------------------------------------------------ *
 * Patch_list                                                               *
 *                                                                          *
 * Set up a logical array to indicate which elements are "slaved".          *
 * ------------------------------------------------------------------------ */

int *Patch_list (Element *U, Patch *P)
{
  int *emask = (int*) calloc (Field_count(U), sizeof(int));
  Segment *s;

  while (P) {
    for (s = P->slaves; s ; s = s->next)
      emask [s->elmt->id] = 1;
    P = P->next;
  }

  return emask;
}

/* 
 * Compute the matrix product: Q^T A_bb Q
 */

void mult_QAQ (Element *U, Qmap q, double **A, double **QAQ)
{
  const int nb = (U->nr + U->ns - 2) << 1;
  const int nq = q.nq;

  double *Q = q.proj [0];

  tempVector (tmp_QA, nq * nb);

  dgemm ('N', 'T', nb, nq, nb, 1., *A, nb, Q     , nq, 0., tmp_QA, nb);
  dgemm ('N', 'N', nq, nq, nb, 1.,  Q, nq, tmp_QA, nb, 0.,   *QAQ, nq);

  freeVector (tmp_QA);
}


/*
 * Compute the matrix product: Q^T A_bi
 */

void mult_QA (Element *U, Qmap q, double **A, double **QA)
{
  const int ni = (U->nr-2) * (U->ns-2);
  const int nb = (U->nr + U->ns - 2) << 1;
  const int nq = q.nq;

  double *Q = q.proj[0];

  dgemm ('N', 'T', ni, nq, nb, 1., *A, ni, Q, nq, 0., *QA, ni);
}


/*
 * Compute the matrix product: A_ib Q
 */

void mult_AQ (Element *U, Qmap q, double **A, double **AQ)
{
  const int ni = (U->nr-2) * (U->ns-2);
  const int nb = (U->nr + U->ns - 2) << 1;
  const int nq = q.nq;

  double *Q = q.proj [0];

  dgemm ('N', 'N', nq, ni, nb, 1., Q, nq, *A, nb, 0., *AQ, nq);
}


/* ------------------------------------------------------------------------ *
 * Qmap_alloc() -- Compute the Qmap for an Element                          *
 *                                                                          *
 * This function computes the Qmap for a given element.  This is a list of  *
 * all nodes coupled to the element, a solve mask for those nodes, and the  *
 * global mortar -> element projection matrix.                              *
 *                                                                          *
 * Treatment of the corner points is a little tricky.  When projections are *
 * done "on the fly" using Project_*_*, edge values are zeroed as soon as   *
 * they've been picked up by some segment so that values only get accumu-   *
 * lated once and the solution is unique.  Since the cooresponding loop is  *
 * over a list of patches sorted by ID number, the ID numbering determines  *
 * which segments will grab values first.                                   *
 *                                                                          *
 * For the direct case (Qmap), a conflict arises at the corner between      *
 * adjacent slaved edges which might try to grab the same values.  Each of  *
 * the following functions MUST make sure the same precedence is followed   *
 * for accumulating values across the patch.                                *
 * ------------------------------------------------------------------------ */

static int*     build_map   (int nq, Element *U, BSystem *M, Segment *slave[]);
static int*     build_solve (int nq, Element *U, BSystem *M, Segment *slave[]);
static double** build_proj  (int nq, Element *U, Segment *slave[]);

Qmap Qmap_alloc (Element *U, BSystem *M, int flags)
{
  Qmap q;
  Segment *slave[4];
  Patch *P = M->other;
  int i, b, nq;

  /* Find the slaved edges and count the number of true boundary points */

  nq = 0;
  for (i = 0; i < 4; i++)
    if ((slave[i] = find_segment('S', U->id, i, P)))
      for (b = 0; b < (*slave[i]).branches; b++)
	nq += (*slave[i]).blist[b].m -> n;
    else 
      nq += (*U).edges[i].np - 1;


  /* Build the map, solve, and projection arrays */

  q.nq    = nq;
  q.map   = (flags & M_MAP)   ? build_map   (nq, U, M, slave) : NULL;
  q.solve = (flags & M_SOLVE) ? build_solve (nq, U, M, slave) : NULL;
  q.proj  = (flags & M_PROJ)  ? build_proj  (nq, U,    slave) : NULL;

  return q;
}

void Qmap_free (Qmap q)
{
  if (q.map)   free (q.map);
  if (q.solve) free (q.solve);
  if (q.proj) { 
    free (*q.proj);
    free ( q.proj); 
  }
}

static int* build_map (int nq, Element *U, BSystem *M, Segment *slave[])
{
  const int id = U->id;
  int  *map, *bmap, np, prec[4];
  int i, p, b;

  /* Precedence Array (lower is better) */

  for (i = 0; i < 4; i++)                         
    prec[i] = slave[i] ? slave[i]->parent->id : UNSET; 

  p   = 0;
  map = ivector (0, nq);

  for (i = 0; i < 4; i++)
    if (slave[i]) {
      int nb = (*slave[i]).branches;
      for (b = --nb; b > -1; b--) {
	np   = (*slave[i]).blist[b].m -> n + 1;
	bmap = M->bmap [(*slave[i]).blist[b].m->elmt->id] +
	                (*slave[i]).blist[b].m->edge->bindex + np - 1;

	/* Precedence Check for branch nb */

	if (b == nb && (prec[i] > prec[(i+3)%4])) 
	  { p++; np--; bmap--; }

	while (np--) map[p++] = *bmap--;
	p--;
      }
    } else {
      np   = (*U).edges[i].np;
      bmap = (*M).bmap [id] + (*U).edges[i].bindex;

      if (i && slave[i-1]) { p++; np--; bmap++; }
      
      while (np--) map[p++] = *bmap++;
      p--;
    }
  
  /* Wrap the last edge around */

  if (prec[0] < prec[3])
    map[nq] = map [0];
  else
    map [0] = map[nq];
  
  if (p != nq) 
    speclib_error ("row-count error in build_map()");

  return map;
}

static int* build_solve (int nq, Element *U, BSystem *M, Segment *slave[])
{
  const int id   = U->id;
  const int bdof = M->bdof;
  int *qsolv, *bmap, np, nb, prec[4];
  int i, p, b;

  /* Precedence Array (lower is better) */

  for (i = 0; i < 4; i++)                         
    prec[i] = slave[i] ? slave[i]->parent->id : UNSET; 
  
  p     = 0;
  qsolv = ivector (0, nq);

  for (i = 0; i < 4; i++)
    if (slave[i]) {
      nb = (*slave[i]).branches;
      for (b = --nb; b > -1; b--) {
	np    = (*slave[i]).blist[b].m -> n + 1;
	bmap  = M->bmap[(*slave[i]).blist[b].m->elmt->id] +
                        (*slave[i]).blist[b].m->edge->bindex + np - 1;

	/* Precedence check for branch nb */

	if (b == nb && (prec[i] > prec[(i+3)%4]))
	  { p++, np--; bmap--; }
	
	while (np--) qsolv[p++] = (*bmap-- < bdof) ? 1 : 0;
	p--;
      }
    } else {
      np    = (*U).edges[i].np;
      bmap  = (*M).bmap [id] + (*U).edges[i].bindex;
      
      if (i && slave[i-1]) { p++; np--; bmap++; }
      
      while (np--) qsolv[p++] = (*bmap++ < bdof) ? 1 : 0;
      p--;
    }
  
  /* Wrap the last edge around */

  if (prec[0] < prec[3])
    qsolv[nq] = qsolv [0];
  else
    qsolv [0] = qsolv[nq];

  if (p != nq) 
    speclib_error ("row-count error in build_solve()");

  return qsolv;
}

static double** build_proj (int nq, Element *U, Segment *slave[])
{
  const int nb = (U->nr + U->ns - 2) << 1;

  int np_s, np_b, ca, cb, ra, rb, np, ns;
  int row, col, m, n, i, b, br;
  int prec[4];
  double **proj, **q;

  /* Precedence Array (lower is better) */

  for (i = 0; i < 4; i++)                         
    prec[i] = slave[i] ? slave[i]->parent->id : UNSET; 

  row  = 0;
  col  = 0;
  proj = dmatrix (0, nb-1, 0, nq-1);
  
  dzero (nb * nq, *proj, 1);   /* Initialize the projection matrix */

  for (i = 0; i < 4; i++)
    if (slave[i]) {
      br   = (*slave[i]).branches;   /* # of branches */
      np_s = (*slave[i]).n;          /* # of slave points on the edge - 1 */

      ra   = row;
      ca   = col;

      /* Check precedence to decide which rows to start/stop in */

      ns   =  (prec[i] < prec[(i+1)%4]) ? 0 : 1;
      np   =  (prec[i] < prec[(i+3)%4]) ? np_s : np_s - 1;
      
      /* The branches have to be copied in reverse order AND the q-matrix *
       * has to be flipped upside down in both directions!  This is be-   *
       * cause the numbering conventions all favor the master edges.      */

      for (b = --br; b > -1; b--, col += np_b) {

	/* #_of_points_on_this_branch-1 and the q-matrix to add in */
	
	np_b  = (*slave[i]).blist[b].m -> n;
	q     = (*slave[i]).blist[b].q;

	for (n = ns; n <= np; n++)
	  for (m = 0; m <= np_b; m++)
	    proj [(row + np_s - n) % nb][(col + np_b - m) % nq] += q[n][m];
      }
      
      rb   = (row + np_s) % nb;
      cb   = (col - np_b) % nq;

      /* Enforce the vertex pinning condition for multiple branches */

      if (prec[i] < prec[(i+3)%4]) {
	n  =  (*slave[i]).blist[br].m -> n;
	q  =  (*slave[i]).blist[br].q;
	dzero (nq, proj[ra], 1);
	for (m = 0; m <= n; m++)
	  proj [ra][(ca + m) % nq] = q[n][n-m];
      }
      
      if (prec[i] < prec[(i+1)%4]) {
	n  =  (*slave[i]).blist [0].m -> n;
	q  =  (*slave[i]).blist [0].q;
	dzero (nq, proj[rb], 1);
	for (m = 0; m <= n; m++)
	  proj [rb][(cb + m) % nq] = q[0][n-m];
      }

      row += np_s;

    } else {
      np_s = (*U).edges[i].np; 
      
      /* If the previous edge was slaved, don't override the *
       * endpoint...it will be taken care of by the pinning  *
       * condition.                                          */

      if (i && slave[i-1]) { row++; col++; np_s--; }

      while (--np_s) proj[row++][col++] = 1.;
    }


  /* Error checking: make sure the row and column numbers are correct, and *
   * also that each row of the matrix adds up to one.  It is a projection  *
   * after all!                                                            */

  if (row != nb || col != nq) speclib_error ("error in build_proj()");

  for (n = 0; n < nb; n++) {
    const double val = dsum (nq, proj[n], 1);
    if (fabs(1.- val) > EPSILON) {
      fprintf (stderr,"Projection error for element %d, boundary pt. %d: %g\n",
	       U->id + 1, n + 1, val); 
    }
  }
  
  return proj;  
}


#ifdef DEBUG

/* Debugging routine...for checking patches */

void show_patches (Patch *plist)
{
  Patch   *p = plist;
  Segment *m, *s;
  Branch  *b;
  Mortar  *q;
  register int i, j;
  const int verbose = option("verbose");
  
  while (p) {

    printf ("Patch ID = %d\n"
	    "M-nodes  = %d\n"
	    "Origin   = (%g,%g)\n", p->id, p->nodes, p->x0, p->y0);
  
    if (m = p->masters) {
      puts  ("Masters...");
      do {
	printf ("\tSegment ID = %d\n"
		"\tOrder      = %d\n"
		"\tLength     = %g\n"
		"\tBranches   = %d\n", m->id, m->n, m->gamma_k, m->branches);
	
	for (b = m->blist; b; b = b->next) {
	  printf ("\t\tBranch ID = %d\n"
		  "\t\tOffset    = %g\n"
		  "\t\tLength    = %g\n", b->id, b->s0, b->gamma_s);
	  puts  ("\t\t----------");
	}
	puts("\tMesh and Solution:");
	for (i = 0; i <= (*m).n; i++)
	  printf("\t\t%#10.6lf %#10.6lf\n", m->mesh[i], m->u[i]);
	putchar('\n');
      } while (m = m->next);
    } else 
      puts  ("Masters...none\n");

    if (s = p->slaves) {
      puts  ("Slaves...");
      do {
	printf ("\tSegment ID = %d\n"
		"\tOrder      = %d\n"
		"\tLength     = %g\n"
		"\tBranches   = %d\n", s->id, s->n, s->gamma_k, s->branches);
	
	for (b = s->blist; b; b = b->next) {
	  printf ("\t\tBranch ID = %d\n"
		  "\t\tOffset    = %g\n"
		  "\t\tLength    = %g\n", b->id, b->s0, b->gamma_s);
	  
	  if (verbose > 2) {
	    puts  ("Q-matrix:");
	    show_matrix (b->q, 0, s->n, 0, b->m->n);
	  }	    
	  puts  ("\t\t----------");
	}
	puts  ("\tMesh and Solution:");
	for (i = 0; i <= s->n; i++)
	  printf("\t\t%#10.6lf %#10.6lf\n", s->mesh[i], s->u[i]);
	putchar('\n');
      } while (s = s->next);
    } else
      puts  ("Slaves...none\n");

    if (q = p->mortars) {
      puts  ("Mortars...");
      do {
	printf ("\tMortar ID  = %d\n"
		"\tOrder      = %d\n"
		"\tLength     = %g\n", q->id, q->n, q->gamma_p);
	puts  ("\tMesh and Solution:");
	for (i = 0; i <= q->n; i++)
	  printf("\t\t%d: %#10.6lf %#10.6lf\n",
		 q->solve[i], q->mesh[i], q->phi[i]);
	putchar('\n');
      } while (q = q->next);
    } else
      puts  ("Mortars...none\n");

    p = p->next;
  }
 
  return;
}

void show_matrix (double **matrix,int nrl,int nrh,int ncl,int nch)
{
  int i, j;
  unsigned int ic = 0;
  unsigned int nc = 5;

  printf("Showing matrix:\n");
  for(i = nrl; i <= nrh;i++) {
    for(j = ncl, ic = 0; j <= nch; j++, ic++)
      printf("%#10.4lf ", matrix[i][j]);
    putchar('\n');
  }
}

#endif
