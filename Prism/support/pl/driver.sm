/*
 * Plotting Library
 *
 * Driver: SuperMongo graphics library.
 *
 * $Id$
 * ------------------------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>

#include "pl.h"
#include "sm.h"

static float xbuf[BUFSIZ];     /* conversion buffer */

/* Macros */

#ifndef MAX
#define MAX(a,b) ((a)>(b)?(a):(b))
#endif

/* ------------------------------------------------------------------------- */

static void vsngl (int n, double *x, int incx, float *y, int incy)
{
  int i = 0;
  while (i < n) {
    *y = (double) *x;
    i += 1;
    x += incx;
    y += incy;
  }
}

static void pl_buferr() {
  fprintf(stderr, "pl: out of buffer space [%d words]\n", BUFSIZ);
}

/* ------------------------------------------------------------------------- */

void pl_driver_init () {
  sm_defvar ("TeX_strings", "1");
}

void pl_driver_exit () {
  sm_device("null");
}

void pl_device (char *dev)
{
  if (dev==(char*)NULL)
    sm_device("nodevice");
  else
    sm_device (dev);
}

void pl_erase() {
  sm_erase ();
  sm_gflush();
}

void pl_box() {
  sm_box   (1,2,0,0);
  sm_gflush();
}

void pl_gflush() {
  sm_gflush();
}

void pl_alpha() {
  sm_alpha();
}

void pl_graphics() {
  sm_graphics();
}

void pl_label (const char *str) {
  sm_label(str);
}

void pl_xlabel (const char *str) {
  sm_xlabel(str);
}

void pl_ylabel (const char *str) {
  sm_ylabel(str);
}

/* ------------------------------------------------------------------------- */

void pl_expand (double val) {
  sm_expand(val);
}

void pl_angle (double val) {
  sm_angle(val);
}

void pl_limits (double xmin, double xmax, double ymin, double ymax) {
  sm_limits (xmin, xmax, ymin, ymax);
}

void pl_connect (int n, double *x, double *y)
{
  if (2*n > BUFSIZ)
    pl_buferr();
  else {
    float *sx = xbuf;
    float *sy = xbuf + n;

    vsngl (n, x, 1, sx, 1);
    vsngl (n, y, 1, sy, 1);
    sm_connect (sx, sy, n);
  }
}

void pl_points (int n, double *x, double *y)
{
  if (2*n > BUFSIZ)
    pl_buferr();
  else {
    float *sx = xbuf;
    float *sy = xbuf + n;

    vsngl (n, x, 1, sx, 1);
    vsngl (n, y, 1, sy, 1);
    sm_points  (sx, sy, n);
  }
}

void pl_dot() {
  sm_dot();
}

void pl_line (double x0, double y0, double x1, double y1) {
  sm_line(x0,y0,x1,y1);
}

void pl_relocate (double x, double y) {
  sm_relocate(x,y);
}

void pl_draw (double x, double y) {
  sm_draw(x,y);
}

void pl_ltype (int type) {
  sm_ltype (type);
}

void pl_ptype (int type) 
{
  float xtype;
  int   ntype = 1;

  switch (type) {
  case PL_DOT:
    xtype = 1.;
    break;
  case PL_PLUS:
    xtype = 41.;
    break;
  case PL_CIRCLE:
    xtype = 80.;
    break;
  case PL_FILLED_CIRCLE:
    xtype = 81;
    break;
  default:
    xtype = 1.;
    ntype = 0;
    break;
  }
  
  sm_ptype (&xtype,ntype);
}

/* Return current position of cursor and key struck */

void pl_curs (double *x, double *y, int *key)
{
  float sx, sy;
  sm_curs(&sx, &sy, key);
  *x = (double) sx;
  *y = (double) sy;
}

/* ------------------------------------------------------------------------- *
 * Interactively prompt for a box and zoom into the new coordinates.         *
 * ------------------------------------------------------------------------- */

void pl_zoom()
{
  int   k;
  float scale;
  float x1, x2, y1, y2;

  puts ("Enter points at opposite corners of the zoom box:");

  k = 0; while (k != 'e') sm_curs (&x1, &y1, &k);
  k = 0; while (k != 'e') sm_curs (&x2, &y2, &k);

  scale = MAX (fabs(x1-x2),fabs(y1-y2));
  x1    = (x1 + x2 - scale) * 0.5;
  x2    =  x1 + scale;
  y1    = (y1 + y2 - scale) * 0.5;
  y2    =  y1 + scale;

  pl_limits (x1, x2, y1, y2);
}
