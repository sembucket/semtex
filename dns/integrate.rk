///////////////////////////////////////////////////////////////////////////////
// integrate.cpp: Unsteady Navier--Stokes solver, using
// "stiffly-stable" time integration [1,2].  Geometries may be 2- or
// 3-dimensional, Cartesian or cylindrical [3].  Fourier expansions
// are used in the homogeneous (z) direction.  This file provides
// integrate as a call-back routine; after initialisation, integrate
// may be called repeatedly without reinitialising internal storage.
//
// For cylindrical coordinates (Fourier in azimuth):
//   u <==> axial     velocity,  x <==> axial     coordinate direction,
//   v <==> radial    velocity,  y <==> radial    coordinate direction,
//   w <==> azimuthal velocity,  z <==> azimuthal coordinate direction.
//
// For Cartesian coordinates (Fourier in z):
//   u <==> x-component  velocity
//   v <==> y-component  velocity
//   w <==> z-component  velocity
//
// In either system, the w velocity component is optional for 2D
// (N_Z=1) (i.e. can have 2D2C or 2D3C).  If 3D (N_Z > 1), w should
// appear in session.
//
// Optionally integrate concentration of advected scalar field c.
//
// Copyright (c) 1994 <--> $Date: 2019/06/21 13:22:31 $, Hugh Blackburn
//
// REFERENCES
// ----------
// [1] Karniadakis, Israeli & Orszag (1991) "High-order splitting methods
//     for the incompressible Navier--Stokes equations", JCP 97:414--443
// [2] Guermond & Shen (2003) "Velocity correction projection methods for
//     incompressible flows", SIAM J Numer Anal 41:112-134
// [3] Blackburn & Sherwin (2004) "Formulation of a Galerkin spectral
//     element--Fourier method for three-dimensional incompressible flows
//     in cylindrical geometries", JCP 179:759-778
// [4] Dong, Karniakadis & Chryssostomides (2014) "A robust and
//     accurate outflow boundary condition for incompressible flow
//     simulations on severely-truncated unbounded domains", JCP 261:83-105.
// [5] Blackburn, Lee, Albrecht & Singh (2019) "Semtex: a spectral
//     element–Fourier solver for the incompressible Navier–Stokes
//     equations in cylindrical or Cartesian coordinates", CPC.
// --
// This file is part of Semtex.
//
// Semtex is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the
// Free Software Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// Semtex is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public License
// along with Semtex (see the file COPYING); if not, write to the Free
// Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
// 02110-1301 USA.
///////////////////////////////////////////////////////////////////////////////

static char RCS[] = "$Id: integrate.cpp,v 9.2 2019/06/21 13:22:31 hmb Exp $";

#include <dns.h>
#include <mpi.h>
#include "rpo_base.h"

typedef ModalMatrixSys Msys;

// -- File-scope constants and routines:

static int_t NDIM, NCOM, NORD, NADV, PIND, CIND;
static bool  C3D;

static void   waveProp  (Domain*, const AuxField***, const AuxField***);
static void   setPForce (const AuxField**, AuxField**);
static void   project   (const Domain*, AuxField**, AuxField**);
static Msys** preSolve  (const Domain*);
static void   Solve     (Domain*, const int_t, AuxField*, Msys*);

bool alloc_rk = true;
bool alloc_pc = true;
AuxField**        du;    // 9 component tensor for the velocity gradients
AuxField**        vort;  // 3 component vector for the vorticity
AuxField**        visc;  // 3 component vector for the explicit viscous terms
AuxField**        rhs;   // 3 component vector for the rhs
AuxField**        phi;   // multi-stage pressure storage
AuxField**        phi_c; // multi-stage pressure storage (with correction)
AuxField**        v_i;   // multi-stage predictor substep storage
AuxField**        u_i;   // multi-stage corrector substep storage
AuxField**        F_i;   // multi-stage forcing term storage
AuxField**        uo;    // initial velocities
vector<AuxField*> __int_ke_vec;
AuxField*         __int_ke_tmp;
AuxField**        __int_err_prev;
AuxField*         __int_err_temp;
AuxField*         __divg_rhs_tmp;
AuxField**        __visc_rhs_tmp;
AuxField**        __diag_vel_tmp;
AuxField*         tmp;   // temporary field for intermediate evaluations
vector<AuxField*> vel0;
ModalMatrixSys*   mms;   // matrix system with homogeneous neumann bcs for the pressure solve
vector<ModalMatrixSys*> u_sys;

void init_fields(Domain* domain) {
  const int_t   nmodes = Geometry::nModeProc();
  const int_t   base   = Geometry::baseMode();
  const real_t  beta   = Femlib::value("BETA");
  const int_t   ntime  = Femlib::ivalue("N_TIME");

  if(!alloc_rk) return;

  if(!Geometry::procID()) cout << "allocating rk integration fields....\n";

  du  = new AuxField*[9];
  F_i = new AuxField*[9];
  u_i = new AuxField*[9];
  v_i = new AuxField*[9];
  for(int ii = 0; ii < 9; ii++) {
    du[ii]  = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    F_i[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    u_i[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    v_i[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  }
  vort  = new AuxField*[3];
  visc  = new AuxField*[3];
  rhs   = new AuxField*[3];
  phi   = new AuxField*[3];
  phi_c = new AuxField*[3];
  uo    = new AuxField*[3];
  __int_err_prev = new AuxField*[3];
  __visc_rhs_tmp = new AuxField*[3];
  __int_ke_vec.resize(3);
  for(int ii = 0; ii < 3; ii++) {
    vort[ii]  = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    visc[ii]  = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    rhs[ii]   = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    phi[ii]   = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    phi_c[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    uo[ii]    = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    __int_ke_vec[ii]   = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    __int_err_prev[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    __visc_rhs_tmp[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  }
  tmp = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  __int_ke_tmp   = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  __int_err_temp = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  __divg_rhs_tmp = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
  // modal matrix system for the pressure solve;
  // hijack the scalar equation solve for this (with homogenous neumann bcs)
  Femlib::ivalue("N_TIME", 1);
  mms = new Msys(0.0, beta, base, nmodes, domain->elmt, domain->b[CIND], DIRECT);
  Femlib::ivalue("N_TIME", ntime);

  alloc_rk = false;
}

void assert_axial_bcs(AuxField** u_arr) {
  int       np     = Geometry::nP();
  int       np2    = np * np;
  real_t*   plane;
  int       plane_j;
  int       node_j;

  AuxField::couple(u_arr[1], u_arr[2], FORWARD);

  for(int plane_i = 0; plane_i < Geometry::nZProc(); plane_i++) {
    plane_j = Geometry::procID() * Geometry::nZProc() + plane_i;

    // axial velocity
    plane = u_arr[0]->plane(plane_i);
    for(int element_i = 0; element_i < Femlib::ivalue("NELS_X"); element_i++) {
      for(int node_i = 0; node_i < np; node_i++) {
        node_j = element_i * np2 + node_i;

        if(plane_j > 1) plane[node_j] = 0.0;
        if(plane_j ==1) plane[node_j] = 0.0;
      }
    }
    // \tilde{v} velocity
    plane = u_arr[1]->plane(plane_i);
    for(int element_i = 0; element_i < Femlib::ivalue("NELS_X"); element_i++) {
      for(int node_i = 0; node_i < np; node_i++) {
        node_j = element_i * np2 + node_i;

        plane[node_j] = 0.0;
        if(plane_j ==1) plane[node_j] = 0.0;
      }
    }
    // tilde{w} velocity
    plane = u_arr[2]->plane(plane_i);
    for(int element_i = 0; element_i < Femlib::ivalue("NELS_X"); element_i++) {
      for(int node_i = 0; node_i < np; node_i++) {
        node_j = element_i * np2 + node_i;

        if(plane_j > 3) plane[node_j] = 0.0;
        if(plane_j < 2) plane[node_j] = 0.0;
        if(plane_j ==1) plane[node_j] = 0.0;
      }
    }
  }
  // zero out all the nyquist data also
  if(!Geometry::procID()) {
    for(int field_i = 0; field_i < 3; field_i++) {
      plane = u_arr[field_i]->plane(1);
      for(int element_i = 0; element_i < Geometry::nElmt(); element_i++) {
        for(int node_i = 0; node_i < np2; node_i++) {
          plane[element_i*np2+node_i] = 0.0;
        }
      }
    }
  }
  AuxField::couple(u_arr[1], u_arr[2], INVERSE);
for(int field_i = 0; field_i < 3; field_i++) u_arr[field_i]->zeroNyquist();
}

// compute grad ui, for vector ui
void calc_tensor(AuxField** ui) {
  for(int ii = 0; ii < 3; ii++) {
    for(int jj = 0; jj < 3; jj++) {
      *du[3*ii+jj] = *ui[ii];
      du[3*ii+jj]->gradient(jj);
      if(jj==2) du[3*ii+jj]->divY();
    }
  }
}

// compute the curl of a vector field, ui as wi
void calc_curl(AuxField** ui, AuxField** wi) {
  calc_tensor(ui);

  *wi[0]  = *ui[2];
  wi[0]->divY();
  *wi[0] += *du[2*3+1];
  *wi[0] -= *du[1*3+2];

  *wi[1]  = *du[0*3+2];
  *wi[1] -= *du[2*3+0];

  *wi[2]  = *du[1*3+0];
  *wi[2] -= *du[0*3+1];
}

// radius x divergence (for rhs of pressure poisson equation)
void divg_rhs(Domain* domain, AuxField** ui, AuxField* div, bool mul_rad, bool do_print) {
  double int_div_sq;
  *div = 0.0;

/*
  for(int ii = 0; ii < 3; ii++) {
    *__divg_rhs_tmp = *ui[ii];
    if( mul_rad && ii <= 1) __divg_rhs_tmp->mulY();
    __divg_rhs_tmp->gradient(ii);
    if(!mul_rad && ii == 2) __divg_rhs_tmp->divY();
    *div += *__divg_rhs_tmp;
  }
  if(!mul_rad) {
    *__divg_rhs_tmp = *ui[1];
    __divg_rhs_tmp->divY();
    *div += *__divg_rhs_tmp;
  }
*/
  if(mul_rad) {
    *__divg_rhs_tmp = *ui[0];
    __divg_rhs_tmp->gradient(0);
    __divg_rhs_tmp->mulY();
    *div += *__divg_rhs_tmp;

    *__divg_rhs_tmp = *ui[1];
    __divg_rhs_tmp->mulY();
    __divg_rhs_tmp->gradient(1);
    *div += *__divg_rhs_tmp;

    *__divg_rhs_tmp = *ui[2];
    __divg_rhs_tmp->gradient(2);
    *div += *__divg_rhs_tmp;
  } else {
    *__divg_rhs_tmp = *ui[0];
    __divg_rhs_tmp->gradient(0);
    *div += *__divg_rhs_tmp;

    *__divg_rhs_tmp = *ui[1];
    __divg_rhs_tmp->mulY();
    __divg_rhs_tmp->gradient(1);
    __divg_rhs_tmp->divY();
    *div += *__divg_rhs_tmp;

    *__divg_rhs_tmp = *ui[2];
    __divg_rhs_tmp->gradient(2);
    __divg_rhs_tmp->divY();
    *div += *__divg_rhs_tmp;
  }

  if(domain) domain->u[0]->smooth(div);

  if(do_print) {
    *__divg_rhs_tmp = *div;
    __divg_rhs_tmp->transform(INVERSE);
    __divg_rhs_tmp->times(*__divg_rhs_tmp, *__divg_rhs_tmp);
    __divg_rhs_tmp->transform(FORWARD);
    int_div_sq = __divg_rhs_tmp->integral();
    if(!Geometry::procID()) cout << "|du.du|^{1/2}: " << sqrt(int_div_sq) << endl;
    //if(!Geometry::procID()) cout << "|du.du|^{1/2}: " << sqrt(int_div_sq) << "\t";
  }
}

// input is [yu, yv, w], output is y.DIV(u)
void y_divg_rhs(Domain* domain, AuxField** ui, AuxField* div, bool do_print) {
  double int_div_sq;
  *div = 0.0;

  for(int ii = 0; ii < 3; ii++) {
    *__divg_rhs_tmp = *ui[ii];
    __divg_rhs_tmp->gradient(ii);
    *div += *__divg_rhs_tmp;
  }
  if(domain) domain->u[0]->smooth(div);

  if(do_print) {
    *__divg_rhs_tmp = *div;
    __divg_rhs_tmp->transform(INVERSE);
    __divg_rhs_tmp->times(*__divg_rhs_tmp, *__divg_rhs_tmp);
    __divg_rhs_tmp->transform(FORWARD);
    int_div_sq = __divg_rhs_tmp->integral();
    if(!Geometry::procID()) cout << "|du.du|^{1/2}: " << sqrt(int_div_sq) << "\t";
  }
}

// explciit viscosity term as curl curl ui, wi = curl ui, vi = curl wi
void visc_rhs(Domain* domain, AuxField** ui, AuxField** wi, AuxField** vi) {
/*
  // rotational component
  calc_curl(ui, wi);
  calc_curl(wi, vi);

  // divergence component
  divg_rhs(NULL, ui, __visc_rhs_tmp[0], false, false);
  *__visc_rhs_tmp[1] = *__visc_rhs_tmp[0];
  *__visc_rhs_tmp[2] = *__visc_rhs_tmp[0];

  for(int ii = 0; ii < 3; ii++) {
    __visc_rhs_tmp[ii]->gradient(ii);
    if(ii == 2) __visc_rhs_tmp[ii]->divY();
    *vi[ii] -= *__visc_rhs_tmp[ii];
    if(domain) domain->u[0]->smooth(vi[ii]);
    *vi[ii] *= ( -1.0 * Femlib::value("KINVIS") );
  }
*/
  for(int ii = 0; ii < 3; ii++) {
    *vi[ii] = 0.0;
    for(int jj = 0; jj < 3; jj++) {
      *__visc_rhs_tmp[ii] = *ui[ii];
      __visc_rhs_tmp[ii]->gradient(jj);
      if(jj == 1) __visc_rhs_tmp[ii]->mulY();
      if(jj == 2) __visc_rhs_tmp[ii]->divY();
      __visc_rhs_tmp[ii]->gradient(jj);
      if(jj == 1) __visc_rhs_tmp[ii]->divY();
      if(jj == 2) __visc_rhs_tmp[ii]->divY();

      *vi[ii] += *__visc_rhs_tmp[ii];
    }
    if(ii == 1 || ii == 2) {
      *__visc_rhs_tmp[ii] = *ui[ii];
      __visc_rhs_tmp[ii]->divY();
      __visc_rhs_tmp[ii]->divY();
      *vi[ii] -= *__visc_rhs_tmp[ii];
    }
    if(ii == 1) {
      *__visc_rhs_tmp[ii] = *ui[2];
      __visc_rhs_tmp[ii]->gradient(2);
      __visc_rhs_tmp[ii]->divY();
      __visc_rhs_tmp[ii]->divY();
      *__visc_rhs_tmp[ii] *= 2.0;
      *vi[ii] -= *__visc_rhs_tmp[ii];
    }
    if(ii == 2) {
      *__visc_rhs_tmp[ii] = *ui[1];
      __visc_rhs_tmp[ii]->gradient(2);
      __visc_rhs_tmp[ii]->divY();
      __visc_rhs_tmp[ii]->divY();
      *__visc_rhs_tmp[ii] *= 2.0;
      *vi[ii] += *__visc_rhs_tmp[ii];
    }
    if(domain) domain->u[0]->smooth(vi[ii]);
    *vi[ii] *= ( Femlib::value("KINVIS") );
  }
}

// Eqns (50)-(52) BS, JCP, 04
void y_visc_rhs(Domain* domain, AuxField** ui, AuxField** vi) {
  const int_t  nmodes = Geometry::nModeProc();
  const int_t  base   = Geometry::baseMode();
  const real_t beta   = Femlib::value ("BETA");
  const int_t  nP     = Geometry::planeSize();
  int          np     = Geometry::nP();
  int          np2    = np * np;
  int_t        Re, Im, k, kk;
  real_t       dz, dz2;

assert_axial_bcs(ui);

  AuxField::couple(ui[1], ui[2], FORWARD);

  for(int ii = 0; ii < 3; ii++) *vi[ii] = 0.0;

  for(int ii = 0; ii < 3; ii++) {
    for(int jj = 0; jj < 2; jj++) {
      *__visc_rhs_tmp[0] = *ui[ii];
      __visc_rhs_tmp[0]->gradient(jj);
      __visc_rhs_tmp[0]->mulY();
      __visc_rhs_tmp[0]->gradient(jj);
// zero out the axial dofs (testing...)
/*
for(int el_i = 0; el_i < Femlib::ivalue("NELS_X"); el_i++) {
for(int node_i = el_i*np2; node_i < el_i*np2+np; node_i++) {
__visc_rhs_tmp[0]->plane(0)[node_i] = 0.0;
__visc_rhs_tmp[0]->plane(1)[node_i] = 0.0;
}
}
*/
      *vi[ii] += *__visc_rhs_tmp[0];
    }

    *__visc_rhs_tmp[0] = *ui[ii];
    for (k = 0; k < nmodes; k++) {
      Re = k  + k;
      Im = Re + 1;
      if(ii == 0)      kk = k + base;
      else if(ii == 1) kk = k + base + 1;
      else             kk = k + base - 1;

      if(ii == 2 && kk < 0) kk = 0;

      dz  = beta * kk;
      dz2 = -1.0 * dz * dz;

      for(int node_i = 0; node_i < nP; node_i++) {
        __visc_rhs_tmp[0]->plane(Re)[node_i] *= dz2;
        __visc_rhs_tmp[0]->plane(Im)[node_i] *= dz2;
      }
    }
    __visc_rhs_tmp[0]->divY();
    // zero out the axial dofs (all of them!)
    for(int el_i = 0; el_i < Femlib::ivalue("NELS_X"); el_i++) {
      for(int node_i = el_i*np2; node_i < el_i*np2+np; node_i++) {
        __visc_rhs_tmp[0]->plane(Re)[node_i] = 0.0;
        __visc_rhs_tmp[0]->plane(Im)[node_i] = 0.0;
      }
    }
    *vi[ii] += *__visc_rhs_tmp[0];
  }

  AuxField::couple(ui[1], ui[2], INVERSE);
  AuxField::couple(vi[1], vi[2], INVERSE);

assert_axial_bcs(vi);

  for(int ii = 0; ii < 3; ii++) {
    // divide by y to recover original viscous term
    vi[ii]->divY();
    vi[ii]->zeroNyquist();
    if(domain) domain->u[0]->smooth(vi[ii]);
    *vi[ii] *= ( Femlib::value("KINVIS") );
  }
}

void conv_rhs(Domain* domain, AuxField** ui, AuxField** ni, FieldForce* FF) {
  for(int ii = 0; ii < 3; ii++) ui[ii]->transform(INVERSE);

  for(int ii = 0; ii < 3; ii++) {
    *ni[ii] = 0.0;
    for(int jj = 0; jj < 3; jj++) {
      *__divg_rhs_tmp = *ui[ii];
      if(jj == 2) __divg_rhs_tmp->transform(FORWARD);
      __divg_rhs_tmp->gradient(jj);
      if(jj == 2) __divg_rhs_tmp->divY();
      if(jj == 2) __divg_rhs_tmp->transform(INVERSE);
      if(jj == 2) __divg_rhs_tmp->zeroNyquist();
      *__visc_rhs_tmp[jj] = *ui[jj];
      ni[ii]->timesMinus(*__visc_rhs_tmp[jj], *__divg_rhs_tmp); // -ve of nonlinear term
    }
  }
  *__visc_rhs_tmp[1] = *ui[1];
  *__visc_rhs_tmp[2] = *ui[2];

  __divg_rhs_tmp->times(*__visc_rhs_tmp[2], *__visc_rhs_tmp[2]);
  __divg_rhs_tmp->divY();
  *ni[1] += *__divg_rhs_tmp;                                    // -ve of nonlinear term

  __divg_rhs_tmp->times(*__visc_rhs_tmp[1], *__visc_rhs_tmp[2]);
  __divg_rhs_tmp->divY();
  *ni[2] -= *__divg_rhs_tmp;                                    // -ve of nonlinear term

  for(int ii = 0; ii < 3; ii++) ui[ii]->transform(FORWARD);
  for(int ii = 0; ii < 3; ii++) ui[ii]->zeroNyquist();

  for(int ii = 0; ii < 3; ii++) ni[ii]->transform(FORWARD);
  for(int ii = 0; ii < 3; ii++) ni[ii]->zeroNyquist();

  for(int ii = 0; ii < 3; ii++) *vel0[ii] = *ui[ii];
  *__visc_rhs_tmp[0] = 0.0;
  FF->addFourier(__visc_rhs_tmp[0], __divg_rhs_tmp, 0, vel0);
  __visc_rhs_tmp[0]->divY();
  *ni[0] += *__visc_rhs_tmp[0];

  for(int ii = 0; ii < 3; ii++) domain->u[0]->smooth(ni[ii]);
}

void y_conv_rhs(Domain* domain, AuxField** ui, AuxField** ni, FieldForce* FF) {
  for(int ii = 0; ii < 3; ii++) ui[ii]->transform(INVERSE);

  for(int ii = 0; ii < 3; ii++) {
    *ni[ii] = 0.0;
    for(int jj = 0; jj < 3; jj++) {
      *__divg_rhs_tmp = *ui[ii];
      if(jj == 2) __divg_rhs_tmp->transform(FORWARD);
      __divg_rhs_tmp->gradient(jj);
      if(jj == 2) __divg_rhs_tmp->transform(INVERSE);
      if(jj == 2) __divg_rhs_tmp->zeroNyquist();
      if(jj <  2) __divg_rhs_tmp->mulY();
      *__visc_rhs_tmp[jj] = *ui[jj];
      ni[ii]->timesMinus(*__visc_rhs_tmp[jj], *__divg_rhs_tmp); // -ve of nonlinear term
    }
  }
  *__visc_rhs_tmp[1] = *ui[1];
  *__visc_rhs_tmp[2] = *ui[2];

  __divg_rhs_tmp->times(*__visc_rhs_tmp[2], *__visc_rhs_tmp[2]);
  *ni[1] += *__divg_rhs_tmp;                                    // -ve of nonlinear term

  __divg_rhs_tmp->times(*__visc_rhs_tmp[1], *__visc_rhs_tmp[2]);
  *ni[2] -= *__divg_rhs_tmp;                                    // -ve of nonlinear term

  for(int ii = 0; ii < 3; ii++) ui[ii]->transform(FORWARD);
  for(int ii = 0; ii < 3; ii++) ui[ii]->zeroNyquist();

  for(int ii = 0; ii < 3; ii++) ni[ii]->transform(FORWARD);
  for(int ii = 0; ii < 3; ii++) ni[ii]->zeroNyquist();

  for(int ii = 0; ii < 3; ii++) *vel0[ii] = *ui[ii];
  FF->addFourier(ni[0], __divg_rhs_tmp, 0, vel0);

  for(int ii = 0; ii < 3; ii++) ni[ii]->divY();

  for(int ii = 0; ii < 3; ii++) domain->u[0]->smooth(ni[ii]);
}

double integrate_ke(AuxField** __u) {
  for(int ii = 0; ii < 3; ii++) {
    *__int_ke_vec[ii] = *__u[ii];
    __int_ke_vec[ii]->transform(INVERSE);
  }
  __int_ke_tmp->innerProduct(__int_ke_vec, __int_ke_vec);
  __int_ke_tmp->transform(FORWARD);
  return __int_ke_tmp->integral();
}

void const_mass_flux_correction(Domain* D, AuxField** ui, real_t c_i) {
  real_t L_x       = Femlib::value("XMAX");
  real_t _refQ     = Femlib::value("Q_BAR");
  real_t getQ, dP;

  if(fabs(_refQ) < 1.0e-6) return;

  if(!Geometry::procID()) {
    getQ  = 2.0 * M_PI * ui[0]->integral(0) / Femlib::ivalue("BETA");
    getQ /= (M_PI * 1.0 * 1.0 * L_x) / Femlib::ivalue("BETA");
    dP    = (_refQ - getQ) / D->Qg;
  }
  MPI_Bcast(&dP, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);

  for(int ii = 0; ii < 3; ii++) ui[ii]->axpy(c_i * dP, *D->grn[ii]);
}

void zero_dirichlet_bcs(AuxField* field) {
  int np  = Geometry::nP();
  int np2 = np * np;
  int node_0, element_0;
  real_t* plane;

  element_0 = Femlib::ivalue("NELS_X") * (Femlib::ivalue("NELS_Y") - 1);

  field->transform(INVERSE);

  for(int plane_i = 0; plane_i < Geometry::nZProc(); plane_i++) {
    plane = field->plane(plane_i);

    for(int element_i = element_0; element_i < Geometry::nElmt(); element_i++) {
      node_0 = element_i*np2 + np*(np-1);

      for(int node_i = 0; node_i < np; node_i++) {
        plane[node_0 + node_i] = 0.0;
      }
    }
  }
  field->transform(FORWARD);
  field->zeroNyquist();
}

void _axpy(AuxField** u1, real_t alpha, AuxField** u2, AuxField** u3) {
  int       np     = Geometry::nP();
  int       np2    = np * np;
  real_t*   plane_1;
  real_t*   plane_2;
  real_t*   plane_3;
  int       plane_j;
  int       node_j;
  int       nex    = Femlib::ivalue("NELS_X");
  int       ney    = Femlib::ivalue("NELS_Y");

  AuxField::couple(u1[1], u1[2], FORWARD);
  AuxField::couple(u2[1], u2[2], FORWARD);
  if(u3 != u1) AuxField::couple(u3[1], u3[2], FORWARD);

  for(int field_i = 0; field_i < 3; field_i++) {
    for(int plane_i = 0; plane_i < Geometry::nZProc(); plane_i++) {
      plane_j = Geometry::procID() * Geometry::nZProc() + plane_i;

      plane_1 = u1[field_i]->plane(plane_i);
      plane_2 = u2[field_i]->plane(plane_i);
      plane_3 = u3[field_i]->plane(plane_i);

      for(int element_i = 0; element_i < Geometry::nElmt(); element_i++) {
        for(int node_i = 0; node_i < np2; node_i++) {
          node_j = element_i * np2 + node_i;

          // nyquist frequency
          if(plane_j == 1) {
            plane_1[node_j] = 0.0;
            continue;
          }
          // wall - homogenous dirichlet bcs
          if(element_i/nex == ney-1 && node_i/np == np-1) {
            plane_1[node_j] = 0.0;
            continue;
          }
          // axis
          if(element_i/nex == 0 && node_i/np == 0) {
            if(plane_j > 3) { // k > 1
              plane_1[node_j] = 0.0;
              continue;
            }
            if(field_i == 0 && plane_j > 1) {
              plane_1[node_j] = 0.0;
              continue;
            }
            if(field_i == 1) {
              plane_1[node_j] = 0.0;
              continue;
            }
            if(field_i == 2 && plane_j < 2) {
              plane_1[node_j] = 0.0;
              continue;
            }
          }
          plane_1[node_j] = alpha * plane_2[node_j] + plane_3[node_j];
        }
      }
    }
  }
  AuxField::couple(u1[1], u1[2], INVERSE);
  AuxField::couple(u2[1], u2[2], INVERSE);
  if(u3 != u1) AuxField::couple(u3[1], u3[2], INVERSE);
}

void zero_mean_radial_pressure_gradient_at_axis(AuxField* dpdy) {
  int       np     = Geometry::nP();
  int       np2    = np * np;
  int       plane_j;
  int       node_j;
  real_t*   plane;
  int       nex    = Femlib::ivalue("NELS_X");
  int       ney    = Femlib::ivalue("NELS_Y");

  for(int plane_i = 0; plane_i < Geometry::nZProc(); plane_i++) {
    plane_j = Geometry::procID() * Geometry::nZProc() + plane_i;
    plane   = dpdy->plane(plane_i);

    // axis
    for(int element_i = 0; element_i < nex; element_i++) {
      for(int node_i = 0; node_i < np; node_i++) {
        node_j = element_i * np2 + node_i;
        if(plane_j < 2) plane[node_j] = 0.0;
      }
    }

    // wall
    for(int element_i = nex*(ney-1); element_i < nex*ney; element_i++) {
      for(int node_i = np*(np-1); node_i < np2; node_i++) {
        node_j = element_i * np2 + node_i;
        plane[node_j] = 0.0;
      }
    }
  }
}

void zero_pressure_rhs_at_axis(AuxField* _rhs) {
  int       np     = Geometry::nP();
  int       np2    = np * np;
  int       plane_j;
  int       node_j;
  real_t*   plane;
  int       nex    = Femlib::ivalue("NELS_X");

  for(int plane_i = 0; plane_i < Geometry::nZProc(); plane_i++) {
    plane_j = Geometry::procID() * Geometry::nZProc() + plane_i;
    plane   = _rhs->plane(plane_i);

    for(int element_i = 0; element_i < nex; element_i++) {
      for(int node_i = 0; node_i < np; node_i++) {
        node_j = element_i * np2 + node_i;
        if(plane_j > 1) plane[node_j] = 0.0;
//plane[node_j] = 0.0; // dp_{k=0}/dy=0; so p_{k=0} should not be enforced at the axis
      }
    }
  }
}

#define ID_DIAGNOSTIC 1

#ifdef ID_DIAGNOSTIC
bool alloc_diagnostics = true;
vector<AuxField*> vcty;
AuxField* enst;
AuxField* pres;

void diagnostics(Domain* domain, bool to_file) {
  double prod, diss, tote, tote_prime, int_dudy, divg;
  Vector du;
  ofstream file;

  // allocate if not already done
  if(alloc_diagnostics) {
    alloc_diagnostics = false;
    vel0.resize(3);
    vcty.resize(3);
    __diag_vel_tmp = new AuxField*[3];
    for(int ii = 0; ii < 3; ii++) {
      vel0[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
      *vel0[ii] = *domain->u[ii];
      vel0[ii]->transform(INVERSE);
      vcty[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
      __diag_vel_tmp[ii] = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    }
    enst = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    pres = new AuxField(new real_t[Geometry::nTotal()], Geometry::nZProc(), domain->elmt);
    return;
  }

  // pressure field was stomped on by the fieldforce, copy back from temporary variable
  pres->transform(INVERSE);
  // transform state into physical space in order to perform pointwise multiplications
  for(int ii = 0; ii < 3; ii++) *__diag_vel_tmp[ii] = *domain->u[ii];
  for(int ii = 0; ii < 3; ii++) __diag_vel_tmp[ii]->transform(INVERSE);

  // energy production, compute as: I = \int_{V} DIV(pu) dV
  *enst = 0.0;
  for(int ii = 0; ii < 3; ii++) {
    *vcty[ii] = *pres;
    if(ii == 2) vcty[ii]->transform(FORWARD);
    vcty[ii]->gradient(ii);
    if(ii == 2) vcty[ii]->transform(INVERSE);
    if(ii == 2) vcty[ii]->divY();

    if(fabs(Femlib::value("Q_BAR")) > 1.0e-6) {
      // constant mass flux forcing
      if(ii == 0) {
        *enst = *domain->u[PIND]; // use the pressure field to compute the velocity gradient at the wall, then replace with original value
        *domain->u[PIND] = *domain->u[0];
        domain->u[PIND]->transform(FORWARD);
        domain->u[PIND]->gradient(1);
        du = Field::normTraction(domain->u[PIND]);
        int_dudy = -2.0 * du.y * Femlib::value("KINVIS") / Femlib::value("XMAX");
        MPI_Bcast(&int_dudy, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);
        *vcty[ii] += int_dudy;
        *domain->u[PIND] = *enst;
        *enst = 0.0;
      }
    } else {
      // constant pressure gradient forcing
      if(ii == 0) *vcty[ii] += 4.0*Femlib::value("KINVIS");
    }

    //if(ii==0) *__diag_vel_tmp[ii] += Femlib::value("WAVE_SPEED");
    *vcty[ii] *= *__diag_vel_tmp[ii];
    //if(ii==0) *__diag_vel_tmp[ii] -= Femlib::value("WAVE_SPEED");
    *enst += *vcty[ii];
  }
  enst->transform(FORWARD);
  prod = enst->integral() / Femlib::value("KINVIS");

  // energy dissipation, compute as: D = \int_{V} [v^2 + w^2 - 2 w dv/\theta + 2 v dwd/theta]/y^2 + |GRAD u|^2 + |GRAD v|^2 + |GRAD w|^2 dV
  // first do the |GRAD U|^2, U = {u,v,w} terms
  *enst = 0.0;
  for(int ii = 0; ii < 3; ii++) {
    for(int jj = 0; jj < 3; jj++) {
      if(jj == ii) continue;

      *vcty[0] = *__diag_vel_tmp[ii];
      if(jj == 2) vcty[0]->transform(FORWARD);
      vcty[0]->gradient(jj);
      if(jj == 2) vcty[0]->transform(INVERSE);
      if(jj == 2) vcty[0]->divY();

      *vcty[0] *= *vcty[0];
      *enst += *vcty[0];
    }

    int jj = (ii+1)%3;
    int kk = (ii+2)%3;

    *vcty[0] = *__diag_vel_tmp[jj];
    *vcty[1] = *__diag_vel_tmp[kk];

    if(kk == 2) vcty[0]->transform(FORWARD);
    vcty[0]->gradient(kk);
    if(kk == 2) vcty[0]->transform(INVERSE);
    if(kk == 2) vcty[0]->divY();

    if(jj == 2) vcty[1]->transform(FORWARD);
    vcty[0]->gradient(jj);
    if(jj == 2) vcty[1]->transform(INVERSE);
    if(jj == 2) vcty[1]->divY();

    *vcty[0] *= *vcty[1];
    *vcty[0] *= 2.0;
    *enst -= *vcty[0];
  }

  *vcty[0] = *__diag_vel_tmp[2];
  vcty[0]->gradient(1);
  vcty[0]->divY();
  *vcty[0] *= *__diag_vel_tmp[2];
  *vcty[0] *= 2.0;
  *enst += *vcty[0];

  *vcty[0] = *__diag_vel_tmp[1];
  vcty[0]->transform(FORWARD);
  vcty[0]->gradient(2);
  vcty[0]->transform(INVERSE);
  vcty[0]->divY();
  *vcty[0] *= *__diag_vel_tmp[2];
  vcty[0]->divY();
  *vcty[0] *= 2.0;
  *enst -= *vcty[0];

  // integeate in fourier space
  enst->transform(FORWARD);
  diss = enst->integral();

  // integrate the total energy
  for(int ii = 0; ii < 3; ii++) *vcty[ii] = *__diag_vel_tmp[ii];
  //*vcty[0] += Femlib::value("WAVE_SPEED");
  *enst = 0.0;
  enst->innerProduct(vcty, vcty) *= 0.5;
  enst->transform(FORWARD);
  tote = enst->integral();

  // perturbation kinetic energy
  for(int ii = 0; ii < 3; ii++) {
    *vcty[ii]  = *__diag_vel_tmp[ii];
    *vcty[ii] -= *vel0[ii];
  }
  enst->innerProduct(vcty, vcty) *= 0.5;
  enst->transform(FORWARD);
  tote_prime = enst->integral();

  // divergence
  *enst = 0.0;
  for(int ii = 0; ii < 3; ii++) {
    *vcty[ii] = *__diag_vel_tmp[ii];
    vcty[ii]->transform(FORWARD);
    if(ii == 1) {
      vcty[ii]->divY();
      *enst += *vcty[ii];
      vcty[ii]->mulY();
    }
    vcty[ii]->gradient(ii);
    if(ii == 2) vcty[ii]->divY();
    *enst += *vcty[ii];
  }
  enst->transform(INVERSE);
  *vcty[0] = *enst;
  *enst *= *vcty[0];
  enst->transform(FORWARD);
  divg = enst->integral();
  divg = sqrt(divg);

  // transform state back into fourier space
  pres->transform(FORWARD);
  pres->zeroNyquist();

  if(!Geometry::procID()) {
    if(to_file) {
      file.open("production_dissipation.txt", ios::app);
      file.precision(12);
      file << domain->step << "\t" << prod << "\t" << diss << "\t" << tote << "\t" << tote_prime << "\t" << divg << "\n";
      file.close();
    } else {
      cout << domain->step << "\t" << prod << "\t" << diss << "\t" << tote << "\t" << tote_prime << "\t" << divg << "\n";
    }
  }
}
#endif

//#define ROTATIONAL_CORRECTION 1
//#define Y_SCALE 1

void rk_step(void (*advection) (Domain*    , 
                                BCmgr*     ,
                                AuxField** , 
                                AuxField** ,
                                FieldForce*),
                Domain*      D ,
                BCmgr*       B ,
                DNSAnalyser* A ,
                FieldForce*  FF, int substep, Msys** MMS, AuxField** Us1, AuxField** Uf1)
{
  int jj;
  const real_t dt      = Femlib::value("D_T") / Femlib::ivalue("RK_SUBSTEP");
  const real_t a_21    = 2.0/3.0;
  const real_t a_31    = 1.0/3.0;
  const real_t a_32    = 1.0/3.0;
  const real_t c_2     = 2.0/3.0;
  const real_t c_3     = 2.0/3.0;
  const real_t c_4     = 1.0;
  const real_t b_1     = 1.0/4.0;
  const real_t b_3     = 3.0/4.0;
  double int_p, int_k;

  for(int ii = 0; ii < 3; ii++) *uo[ii] = *D->u[ii];

  // on first substep put the inital velocity fields in the previous velocity
  // fields storage space for use in the velocity correction scheme once we're done here
  if(!substep) {
    for(int ii = 0; ii < 3; ii++) {
      *Us1[ii] = *D->u[ii];
      if(ii < 2) Us1[ii]->mulY();
    }
  }

  // step 1.
  jj = 0;
  // 1.1 explicit forcing
  for(int ii = 0; ii < 3; ii++) *rhs[ii] = *uo[ii];
  for(int ii = 0; ii < 3; ii++) *F_i[jj*3+ii] = 0.0;
//  advection(D, B, rhs, &F_i[3*jj], FF); // note: axial and radial components are scaled by y here...
  y_conv_rhs(D, &uo[0], &F_i[3*jj], FF);
  if(!substep) for(int ii = 0; ii < 3; ii++) *Uf1[ii] = *F_i[ii];
  //visc_rhs(D, uo, vort, visc);
  y_visc_rhs(D, uo, visc);
  for(int ii = 0; ii < 3; ii++) {
#ifdef Y_SCALE
    if(ii < 2) visc[ii]->mulY();
#else
//    if(ii < 2) F_i[3*jj+ii]->divY();
#endif
    *F_i[3*jj+ii] += *visc[ii];
//*F_i[3*jj+ii] = *visc[ii];

    *v_i[3*jj+ii] = *uo[ii];
#ifdef Y_SCALE
    if(ii < 2) v_i[3*jj+ii]->mulY();
#endif
    v_i[ii]->axpy(dt*a_21, *F_i[3*jj+ii]);
  }
//  _axpy(&v_i[3*jj], dt*a_21, &F_i[3*jj], uo);
  // 1.2 pressure poisson equation
#ifdef Y_SCALE
  y_divg_rhs(NULL, &v_i[3*jj], rhs[0], true);
#else
  divg_rhs(NULL, &v_i[3*jj], rhs[0], true, true);
#endif
  *rhs[0] /= dt;
//zero_pressure_rhs_at_axis(rhs[0]);
  D->u[CIND]->solve(rhs[0], mms);
  *phi[jj] = *D->u[CIND];
  // 1.3 apply the rotational correction to the pressure
#ifdef ROTATIONAL_CORRECTION // TODO: y scaled version of the correction
  *phi_c[jj] = *phi[jj];
  divg_rhs(D, uo, rhs[0], false, false);
  phi_c[jj]->axpy(+a_21*Femlib::value("KINVIS"), *rhs[0]);
  D->u[0]->smooth(phi_c[jj]);
  *D->u[CIND] = *phi_c[jj];
#endif
  // 1.4 project onto divergence free solution
  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *D->u[CIND];
    rhs[ii]->gradient(ii);
    if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
#ifdef Y_SCALE
    if(ii <  2) rhs[ii]->mulY();
    if(ii == 2) v_i[3*jj+ii]->mulY();
#else
    if(ii == 2) rhs[ii]->divY();
#endif
  }
  _axpy(&u_i[3*jj], -dt, rhs, &v_i[3*jj]);
  for(int ii = 0; ii < 3; ii++) {
    D->u[0]->smooth(u_i[3*jj+ii]);
#ifdef Y_SCALE
    u_i[3*jj+ii]->divY();
#endif
  }
assert_axial_bcs(&u_i[3*jj]);
*pres = *D->u[CIND];
for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[3*jj+ii];
diagnostics(D, false);

  // step 2.
  jj = 1;
  // 2.1 explicit forcing
  for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[3*(jj-1)+ii];
  for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *u_i[3*(jj-1)+ii];
  for(int ii = 0; ii < 3; ii++) *F_i[jj*3+ii] = 0.0;
//  advection(D, B, rhs, &F_i[3*jj], FF); // note: axial and radial components are scaled by y here...
  y_conv_rhs(D, &u_i[0], &F_i[3*jj], FF);
  //visc_rhs(D, &u_i[0], vort, visc);
  y_visc_rhs(D, &u_i[0], visc);
  for(int ii = 0; ii < 3; ii++) {
#ifdef Y_SCALE
    if(ii < 2) visc[ii]->mulY();
#else
//    if(ii < 2) F_i[3*jj+ii]->divY();
#endif
    *F_i[3*jj+ii] += *visc[ii];
//*F_i[3*jj+ii] = *visc[ii];

    *v_i[3*jj+ii] = *uo[ii];
#ifdef Y_SCALE
    if(ii < 2) v_i[3*jj+ii]->mulY();
#endif
    v_i[3*jj+ii]->axpy(dt*a_31, *F_i[3*(jj-1)+ii]);
    v_i[3*jj+ii]->axpy(dt*a_32, *F_i[3*(jj+0)+ii]);
  }
//  _axpy(&v_i[3*jj], dt*a_31, &F_i[3*(jj-1)], uo);
//  _axpy(&v_i[3*jj], dt*a_32, &F_i[3*(jj+0)], &v_i[3*jj]);
  // 2.2 pressure poisson equation
#ifdef Y_SCALE
  y_divg_rhs(NULL, &v_i[3*jj], rhs[0], true);
#else
  divg_rhs(NULL, &v_i[3*jj], rhs[0], true, true);
#endif
  *rhs[0] /= dt;
//zero_pressure_rhs_at_axis(rhs[0]);
  D->u[CIND]->solve(rhs[0], mms);
  *phi[jj] = *D->u[CIND];
  // 2.3 apply the rotational correction to the pressure
#ifdef ROTATIONAL_CORRECTION
  *phi_c[jj] = *phi[jj];
  divg_rhs(D, uo, rhs[0], false, false);
  phi_c[jj]->axpy(+a_31*Femlib::value("KINVIS"), *rhs[0]);
  divg_rhs(D, &u_i[0], rhs[0], false, false);
  phi_c[jj]->axpy(+a_32*Femlib::value("KINVIS"), *rhs[0]);
  D->u[0]->smooth(phi_c[jj]);
  *D->u[CIND] = *phi_c[jj];
#endif
  // 2.4 project onto divergence free solution
  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *D->u[CIND];
    rhs[ii]->gradient(ii);
    if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
#ifdef Y_SCALE
    if(ii <  2) rhs[ii]->mulY();
    if(ii == 2) v_i[3*jj+ii]->mulY();
#else
    if(ii == 2) rhs[ii]->divY();
#endif
  }
  _axpy(&u_i[3*jj], -dt, rhs, &v_i[3*jj]);
  for(int ii = 0; ii < 3; ii++) {
    D->u[0]->smooth(u_i[3*jj+ii]);
#ifdef Y_SCALE
    u_i[3*jj+ii]->divY();
#endif
  }
assert_axial_bcs(&u_i[3*jj]);
*pres = *D->u[CIND];
for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[3*jj+ii];
diagnostics(D, false);

  // step 3.
  jj = 2;
  // 3.1 explicit forcing
  for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[3*(jj-1)+ii];
  for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *u_i[3*(jj-1)+ii];
  for(int ii = 0; ii < 3; ii++) *F_i[jj*3+ii] = 0.0;
//  advection(D, B, rhs, &F_i[3*jj], FF); // note: axial and radial components are scaled by y here...
  y_conv_rhs(D, &u_i[3], &F_i[3*jj], FF);
  //visc_rhs(D, &u_i[3], vort, visc);
  y_visc_rhs(D, &u_i[3], visc);
  for(int ii = 0; ii < 3; ii++) {
#ifdef Y_SCALE
    if(ii < 2) visc[ii]->mulY();
#else
//    if(ii < 2) F_i[3*jj+ii]->divY();
#endif
    *F_i[3*jj+ii] += *visc[ii];
//*F_i[3*jj+ii] = *visc[ii];

    *v_i[3*jj+ii] = *uo[ii];
#ifdef Y_SCALE
    if(ii < 2) v_i[3*jj+ii]->mulY();
#endif
    v_i[3*jj+ii]->axpy(dt*b_1, *F_i[3*(jj-2)+ii]);
    v_i[3*jj+ii]->axpy(dt*b_3, *F_i[3*(jj+0)+ii]);
  }
//  _axpy(&v_i[3*jj], dt*b_1, &F_i[3*(jj-2)], uo);
//  _axpy(&v_i[3*jj], dt*b_3, &F_i[3*(jj+0)], &v_i[3*jj]);
  // 3.2 pressure poisson equation
#ifdef Y_SCALE
  y_divg_rhs(NULL, &v_i[3*jj], rhs[0], true);
#else
  divg_rhs(NULL, &v_i[3*jj], rhs[0], true, true);
#endif
  *rhs[0] /= dt;
//zero_pressure_rhs_at_axis(rhs[0]);
*D->u[PIND] = *rhs[0];
  D->u[CIND]->solve(rhs[0], mms);
  *phi[jj] = *D->u[CIND];
  // 3.3 apply the rotational correction to the pressure
#ifdef ROTATIONAL_CORRECTION
  *phi_c[jj] = *phi[jj];
  divg_rhs(D, &uo[0], rhs[0], false, false);
  phi_c[jj]->axpy(+b_1*Femlib::value("KINVIS"), *rhs[0]);
  divg_rhs(D, &u_i[3], rhs[0], false, false);
  phi_c[jj]->axpy(+b_3*Femlib::value("KINVIS"), *rhs[0]);
  D->u[0]->smooth(phi_c[jj]);
  *D->u[CIND] = *phi_c[jj];
#endif
  // 3.4 project onto divergence free solution
  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *D->u[CIND];
    rhs[ii]->gradient(ii);
    if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
#ifdef Y_SCALE
    if(ii <  2) rhs[ii]->mulY();
    if(ii == 2) v_i[3*jj+ii]->mulY();
#else
    if(ii == 2) rhs[ii]->divY();
#endif
  }
  _axpy(&u_i[3*jj], -dt, rhs, &v_i[3*jj]);
  for(int ii = 0; ii < 3; ii++) {
    D->u[0]->smooth(u_i[3*jj+ii]);
#ifdef Y_SCALE
    u_i[3*jj+ii]->divY();
#endif
  }
assert_axial_bcs(&u_i[3*jj]);
  // velocity udpate
  for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[3*jj+ii];
//if(substep==12800)
if(substep==25600)
//if(substep==204600)
//{D->dump();        }
//if(substep==204800)
{D->dump();abort();}

  // second order pressure
  *D->u[PIND] = 0.0;
#ifdef ROTATIONAL_CORRECTION
  D->u[PIND]->axpy(-3.0, *phi_c[jj-1]);
  D->u[PIND]->axpy(+4.0, *phi_c[jj+0]);
#else
  D->u[PIND]->axpy(-3.0, *phi[jj-1]);
  D->u[PIND]->axpy(+4.0, *phi[jj+0]);
#endif

*pres = *D->u[PIND];
diagnostics(D, false);
}

void rk_step_first_order(void (*advection) (Domain*    , 
                                BCmgr*     ,
                                AuxField** , 
                                AuxField** ,
                                FieldForce*),
                Domain*      D ,
                BCmgr*       B ,
                DNSAnalyser* A ,
                FieldForce*  FF, int substep, Msys** MMS, AuxField** Us1, AuxField** Uf1)
{
  const real_t dt      = Femlib::value("D_T") / Femlib::ivalue("RK_SUBSTEP");
  double int_p, int_k;

  for(int ii = 0; ii < 3; ii++) *uo[ii] = *D->u[ii];

  // on first substep put the inital velocity fields in the previous velocity
  // fields storage space for use in the velocity correction scheme once we're done here
  if(!substep) {
    for(int ii = 0; ii < 3; ii++) {
      *Us1[ii] = *D->u[ii];
      if(ii < 2) Us1[ii]->mulY();
    }
  }

  // 1.1 explicit forcing
  for(int ii = 0; ii < 3; ii++) *rhs[ii] = *uo[ii];
  for(int ii = 0; ii < 3; ii++) *F_i[ii] = 0.0;
//  advection(D, B, rhs, F_i, FF); // note: axial and radial components are scaled by y here...
  y_conv_rhs(D, &uo[0], F_i, FF);
  if(!substep) for(int ii = 0; ii < 3; ii++) *Uf1[ii] = *F_i[ii];
  visc_rhs(D, uo, vort, visc);
  //y_visc_rhs(D, uo, visc);
  for(int ii = 0; ii < 3; ii++) {
#ifdef Y_SCALE
    if(ii < 2) visc[ii]->mulY();
#else
//    if(ii < 2) F_i[ii]->divY();
#endif
    *F_i[ii] += *visc[ii];
//*F_i[ii] = *visc[ii];

    *v_i[ii] = *uo[ii];
#ifdef Y_SCALE
    if(ii < 2) v_i[ii]->mulY();
#endif
    v_i[ii]->axpy(dt, *F_i[ii]);
  }
//  _axpy(v_i, dt, F_i, uo);
  // 1.2 pressure poisson equation
#ifdef Y_SCALE
  y_divg_rhs(NULL, v_i, rhs[0], true);
#else
  divg_rhs(NULL, v_i, rhs[0], true, true);
#endif
  *rhs[0] /= dt;
//zero_pressure_rhs_at_axis(rhs[0]);
  D->u[CIND]->solve(rhs[0], mms);
  *phi[0] = *D->u[CIND];
  // 1.3 apply the rotational correction to the pressure
#ifdef ROTATIONAL_CORRECTION // TODO: y scaled version of the correction
  *phi_c[0] = *phi[0];
  divg_rhs(D, uo, rhs[0], false, false);
  phi_c[0]->axpy(Femlib::value("KINVIS"), *rhs[0]);
  D->u[0]->smooth(phi_c[0]);
  *D->u[CIND] = *phi_c[0];
#endif
  // 1.4 project onto divergence free solution
  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *D->u[CIND];
    rhs[ii]->gradient(ii);
    if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
#ifdef Y_SCALE
    if(ii <  2) rhs[ii]->mulY();
    if(ii == 2) v_i[ii]->mulY();
#else
    if(ii == 2) rhs[ii]->divY();
#endif
  }
  _axpy(u_i, -dt, rhs, v_i);
  for(int ii = 0; ii < 3; ii++) {
    D->u[0]->smooth(u_i[ii]);
#ifdef Y_SCALE
    u_i[ii]->divY();
#endif
  }
assert_axial_bcs(u_i);
*pres = *D->u[CIND];
for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[ii];
diagnostics(D, false);

if(substep==12800)
//if(substep==204600)
//{D->dump();        }
//if(substep==204800)
{D->dump();abort();}

#ifdef ROTATIONAL_CORRECTION
  *D->u[PIND] = *phi_c[0];
#else
  *D->u[PIND] = *phi[0];
#endif

*pres = *D->u[PIND];
diagnostics(D, false);
}

#if 0
void pc_loop(void (*advection) (Domain*    , 
                                BCmgr*     ,
                                AuxField** , 
                                AuxField** ,
                                FieldForce*),
                Domain*      D ,
                BCmgr*       B ,
                DNSAnalyser* A ,
                FieldForce*  FF, Msys** MMS, AuxField** Us1, AuxField** Uf1, int step)
{
  int           done    = 0;
  const int_t   nmodes  = Geometry::nModeProc();
  const int_t   base    = Geometry::baseMode();
  const real_t  beta    = Femlib::value("BETA");
  const real_t  dt      = Femlib::value("D_T");
  const int_t   ntime   = Femlib::ivalue("N_TIME");
  const real_t  lambda2 = 1.0 / Femlib::value("D_T") / Femlib::value("KINVIS");
  real_t        int_u2, int_du2, int_p, int_dp;
  int           iter    = 0;

  Femlib::ivalue("N_TIME", 1);

  if(alloc_pc) {
    u_sys.resize(3);
    for(int ii = 0; ii < 3; ii++) {
      u_sys[ii] = new Msys(lambda2, beta, base, nmodes, D->elmt, D->b[ii], DIRECT);
    }
  }

  // on first substep put the inital velocity fields in the previous velocity
  // fields storage space for use in the velocity correction scheme once we're done here
  for(int ii = 0; ii < 3; ii++) {
    *Us1[ii] = *D->u[ii];
    if(ii < 2) Us1[ii]->mulY();
  }

  for(int ii = 0; ii < 3; ii++) *uo[ii]  = *D->u[ii];
  for(int ii = 0; ii < 3; ii++) *u_i[ii] = *D->u[ii];
  for(int ii = 0; ii < 9; ii++) *F_i[ii] = 0.0;
  for(int ii = 0; ii < 9; ii++) F_i[ii]->zeroNyquist();

  if(!Geometry::procID()) cout << "\ndoing pressure correction iterative solve, tracer index: " << CIND << ", pressure index: " << PIND << "\n" << endl;

  // compute the initial ke
  int_u2 = integrate_ke(uo);
  if(!Geometry::procID()) cout << "initial ke: " << int_u2 << endl;
  int_p = D->u[CIND]->integral();
  if(!Geometry::procID()) cout << "global pressure integral: " << int_p << endl;

  // first step, do a poisson solve for the initial pressure
  if(alloc_pc) {
    divg_rhs(NULL, uo, rhs[0], true, false); // scale rhs by y
    *rhs[0] /= dt;
    D->u[CIND]->solve(rhs[0], mms);
    divg_rhs(D, uo, rhs[0], false, false);
    D->u[CIND]->axpy(-1.0*Femlib::value("KINVIS"), *rhs[0]);
    *phi[0] = *D->u[CIND];
  }
*D->u[CIND] = 0.0;
*phi[0] = 0.0;
D->u[CIND]->zeroNyquist();

  while(!done) {
    if(!Geometry::procID()) cout << "iteration: " << iter << "\t";
    // 1. viscous step
    //    -- nonlinear term (previous time level)
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *uo[ii];
    for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *uo[ii];
    advection(D, B, &rhs[0], &F_i[0], FF); // note: axial and radial components are scaled by y here...
    // on first substep put the inital nonlinear forcing (scaled by y) in the previous nonlinear
    // terms storage space for use in the velocity correction scheme once we're done here
    if(!iter) for(int ii = 0; ii < 3; ii++) *Uf1[ii] = *F_i[ii];
    //    -- nonlinear term (current time level)
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[ii];
    for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *u_i[ii];
    advection(D, B, &rhs[0], &F_i[3], FF); // note: axial and radial components are scaled by y here...
    for(int ii = 0; ii < 3; ii++) {
      //  -- pressure gradient forcing
      *rhs[ii] = *D->u[CIND];
      rhs[ii]->gradient(ii);
      if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
      if(ii == 2) rhs[ii]->divY();
      *rhs[ii] *= (-1.0*dt); // TODO: pressure gradient forcing causes blow up...
      //  -- time centered nonlinear term
      if(ii <  2) F_i[0+ii]->divY();
//      rhs[ii]->axpy(0.5*dt, *F_i[0+ii]);
      if(ii <  2) F_i[3+ii]->divY();
//      rhs[ii]->axpy(0.5*dt, *F_i[3+ii]);
      //  -- previous time step
//      rhs[ii]->axpy(1.0, *uo[ii]);
//      rhs[ii]->mulY();
//      *rhs[ii] *= (-1.0*lambda2);
    }
    _axpy(rhs, 1.0,    uo,      rhs);
//    _axpy(rhs, 0.5*dt, &F_i[0], rhs);
//    _axpy(rhs, 0.5*dt, &F_i[3], rhs);
    for(int ii = 0; ii < 3; ii++) {
      rhs[ii]->mulY();
      *rhs[ii] *= (-1.0*lambda2);
    }
    // couple the rhs terms so that we are in tilde variables
    for(int ii = 0; ii < 3; ii++) D->u[ii]->evaluateBoundaries(NULL, step, true);
    Field::coupleBCs(D->u[1], D->u[2], FORWARD);
    AuxField::couple(D->u[1], D->u[2], FORWARD);
    AuxField::couple(rhs[1] , rhs[2],  FORWARD);
    for(int ii = 0; ii < 3; ii++) D->u[ii]->solve(rhs[ii], MMS[ii]);
    // uncouple back into hat variables
    AuxField::couple(D->u[1], D->u[2], INVERSE);
    for(int ii = 0; ii < 3; ii++) D->u[ii]->zeroNyquist();
/*
assert_axial_bcs(rhs);
for(int ii = 0; ii < 3; ii++) *D->u[ii] = *rhs[ii];
*/

    // 2. pressure step
    *phi[0] = *D->u[CIND];
    for(int ii = 0; ii < 3; ii++) *v_i[ii] = *D->u[ii];
    divg_rhs(NULL, v_i, rhs[0], true, false); // scale rhs by y
    *rhs[0] /= dt;
    *D->u[CIND] = 0.0;
    D->u[CIND]->zeroNyquist();
    D->u[CIND]->evaluateBoundaries(D->u[CIND], 0);
    D->u[CIND]->solve(rhs[0], mms);
    //D->u[CIND]->solve(rhs[0], MMS[CIND]);
    D->u[CIND]->zeroNyquist();

    // 3. velocity update
/*
    for(int ii = 0; ii < 3; ii++) {
      *rhs[ii] = *D->u[CIND];
      rhs[ii]->gradient(ii);
      if(ii == 2) rhs[ii]->divY();
      D->u[ii]->axpy(-dt, *rhs[ii]);
      D->u[0]->smooth(D->u[ii]);
    }
*/
phi_c[0]->zeroNyquist();
*phi_c[0] = *D->u[CIND];
    *D->u[CIND] += *phi[0];
    //   -- rotational correction
#ifdef ROTATIONAL_CORRECTION
    divg_rhs(D, v_i, rhs[0], false, false);
    D->u[CIND]->axpy(-1.0*Femlib::value("KINVIS"), *rhs[0]);
#endif

    for(int ii = 0; ii < 3; ii++) *v_i[ii] = *D->u[ii];
    const_mass_flux_correction(D, v_i, 1.0);
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *v_i[ii];

    // 3. convergence test
    int_u2 = integrate_ke(v_i);
    for(int ii = 0; ii < 3; ii++) *v_i[ii] -= *u_i[ii];
    int_du2 = integrate_ke(v_i);
    for(int ii = 0; ii < 3; ii++) *v_i[ii] += *u_i[ii];
    if(!Geometry::procID()) cout << "\t|u|^2: " << int_u2 << "\t|du|^2: " << int_du2 << "\t|du^2/u^2|^{1/2}: " << sqrt(int_du2/int_u2) << "\t";
    int_p = D->u[CIND]->integral();
    if(!Geometry::procID()) cout << "global pressure integral: " << int_p << "\t";

    for(int ii = 0; ii < 3; ii++) D->u[ii]->smooth(D->u[ii]);

#ifdef ID_DIAGNOSTIC
    *pres = *D->u[CIND];
    diagnostics(D, true);
#endif
    
    for(int ii = 0; ii < 3; ii++) *u_i[ii] = *D->u[ii];
    for(int ii = 0; ii < 3; ii++) u_i[ii]->zeroNyquist();

    divg_rhs(D, u_i, rhs[0], false, true); // compute the divergence at the end of the iteration (for testing)

    iter++;
    if(sqrt(int_du2/int_u2) < 1.0e-14) done = 1;
    MPI_Bcast(&done, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Barrier(MPI_COMM_WORLD);
  }

  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *phi_c[0];
    rhs[ii]->gradient(ii);
    if(ii == 2) rhs[ii]->divY();
//    D->u[ii]->axpy(-dt, *rhs[ii]);
//zero_dirichlet_bcs(D->u[ii]);
//    D->u[0]->smooth(D->u[ii]);
  }
  _axpy(u_i, -dt, rhs, u_i);
  for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[ii];
  for(int ii = 0; ii < 3; ii++) D->u[0]->smooth(D->u[ii]);
//if(step==3){D->dump();abort();}

{
int_u2 = integrate_ke(v_i);
if(!Geometry::procID()) cout << "end of step, final ke: " << int_u2 << endl;
int_p = D->u[CIND]->integral();
if(!Geometry::procID()) cout << "global pressure integral: " << int_p << endl;
}

  Femlib::ivalue("N_TIME", ntime);
  *D->u[PIND] = *D->u[CIND];

  alloc_pc = false;
}
#endif
void pc_loop(void (*advection) (Domain*    , 
                                BCmgr*     ,
                                AuxField** , 
                                AuxField** ,
                                FieldForce*),
                Domain*      D ,
                BCmgr*       B ,
                DNSAnalyser* A ,
                FieldForce*  FF, Msys** MMS, AuxField** Us1, AuxField** Uf1, int step)
{
  int           done    = 0;
  const int_t   nmodes  = Geometry::nModeProc();
  const int_t   base    = Geometry::baseMode();
  const real_t  beta    = Femlib::value("BETA");
  const real_t  dt      = Femlib::value("D_T");
  const int_t   ntime   = Femlib::ivalue("N_TIME");
  const real_t  lambda2 = 1.0 / Femlib::value("D_T") / Femlib::value("KINVIS");
  real_t        int_u2, int_du2, int_p, int_dp;
  int           iter    = 0;

  Femlib::ivalue("N_TIME", 1);

  if(alloc_pc) {
    u_sys.resize(3);
    for(int ii = 0; ii < 3; ii++) {
      u_sys[ii] = new Msys(lambda2, beta, base, nmodes, D->elmt, D->b[ii], DIRECT);
    }
  }

  // on first substep put the inital velocity fields in the previous velocity
  // fields storage space for use in the velocity correction scheme once we're done here
  for(int ii = 0; ii < 3; ii++) {
    *Us1[ii] = *D->u[ii];
    if(ii < 2) Us1[ii]->mulY();
  }

  for(int ii = 0; ii < 3; ii++) *uo[ii]  = *D->u[ii];
  for(int ii = 0; ii < 3; ii++) *u_i[ii] = *D->u[ii];
  for(int ii = 0; ii < 9; ii++) *F_i[ii] = 0.0;
  for(int ii = 0; ii < 9; ii++) F_i[ii]->zeroNyquist();

  if(!Geometry::procID()) cout << "\ndoing pressure correction iterative solve, tracer index: " << CIND << ", pressure index: " << PIND << "\n" << endl;

  // compute the initial ke
  int_u2 = integrate_ke(uo);
  if(!Geometry::procID()) cout << "initial ke: " << int_u2 << endl;
  int_p = D->u[CIND]->integral();
  if(!Geometry::procID()) cout << "global pressure integral: " << int_p << endl;

  // first step, do a poisson solve for the initial pressure
  if(alloc_pc) {
    divg_rhs(NULL, uo, rhs[0], true, false); // scale rhs by y
    *rhs[0] /= dt;
    D->u[CIND]->solve(rhs[0], mms);
    divg_rhs(D, uo, rhs[0], false, false);
    D->u[CIND]->axpy(-1.0*Femlib::value("KINVIS"), *rhs[0]);
    *phi[0] = *D->u[CIND];
  }
*D->u[CIND] = 0.0;
*phi[0] = 0.0;
D->u[CIND]->zeroNyquist();

  while(!done) {
    if(!Geometry::procID()) cout << "iteration: " << iter << "\t";
    // 1. viscous step
    //    -- nonlinear term (previous time level)
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *uo[ii];
    for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *uo[ii];
    advection(D, B, &rhs[0], &F_i[0], FF); // note: axial and radial components are scaled by y here...
    // on first substep put the inital nonlinear forcing (scaled by y) in the previous nonlinear
    // terms storage space for use in the velocity correction scheme once we're done here
    if(!iter) for(int ii = 0; ii < 3; ii++) *Uf1[ii] = *F_i[ii];
    //    -- nonlinear term (current time level)
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[ii];
    for(int ii = 0; ii < 3; ii++) *rhs[ii]  = *u_i[ii];
    advection(D, B, &rhs[0], &F_i[3], FF); // note: axial and radial components are scaled by y here...
    for(int ii = 0; ii < 3; ii++) {
      //  -- pressure gradient forcing
      *rhs[ii] = *D->u[CIND];
      rhs[ii]->gradient(ii);
      if(ii == 1) zero_mean_radial_pressure_gradient_at_axis(rhs[ii]);
      if(ii <  2) rhs[ii]->mulY();
      *rhs[ii] *= (-1.0*dt);
      //  -- previous time step
      *tmp = *uo[ii];
      tmp->mulY();
      rhs[ii]->axpy(1.0, *tmp);
      //  -- time centered nonlinear term
/*
      if(!iter && ii == 2) F_i[0+ii]->mulY();
      if(         ii == 2) F_i[3+ii]->mulY();
      rhs[ii]->axpy(0.5*dt, *F_i[0+ii]);
      rhs[ii]->axpy(0.5*dt, *F_i[3+ii]);
      *rhs[ii] *= (-1.0*lambda2);
*/
    }
    // couple the rhs terms so that we are in tilde variables - TODO: viscous term causes blow up...
/*
    for(int ii = 0; ii < 3; ii++) D->u[ii]->evaluateBoundaries(NULL, step, true);
    Field::coupleBCs(D->u[1], D->u[2], FORWARD);
    AuxField::couple(D->u[1], D->u[2], FORWARD);
    AuxField::couple(rhs[1] , rhs[2],  FORWARD);
    for(int ii = 0; ii < 3; ii++) D->u[ii]->solve(rhs[ii], MMS[ii]);
    // uncouple back into hat variables
    AuxField::couple(D->u[1], D->u[2], INVERSE);
    for(int ii = 0; ii < 3; ii++) D->u[ii]->zeroNyquist();
*/
assert_axial_bcs(rhs);
for(int ii = 0; ii < 3; ii++) *D->u[ii] = *rhs[ii];

    // 2. pressure step
    *phi[0] = *D->u[CIND];
    for(int ii = 0; ii < 3; ii++) *v_i[ii] = *D->u[ii];
    divg_rhs(NULL, v_i, rhs[0], true, false); // scale rhs by y
    *rhs[0] /= dt;
    *D->u[CIND] = 0.0;
    D->u[CIND]->zeroNyquist();
    D->u[CIND]->evaluateBoundaries(D->u[CIND], 0);
    D->u[CIND]->solve(rhs[0], mms);
    //D->u[CIND]->solve(rhs[0], MMS[CIND]);
    D->u[CIND]->zeroNyquist();

    // 3. velocity update
/*
    for(int ii = 0; ii < 3; ii++) {
      *rhs[ii] = *D->u[CIND];
      rhs[ii]->gradient(ii);
      if(ii == 2) rhs[ii]->divY();
      D->u[ii]->axpy(-dt, *rhs[ii]);
      D->u[0]->smooth(D->u[ii]);
    }
*/
phi_c[0]->zeroNyquist();
*phi_c[0] = *D->u[CIND];
    *D->u[CIND] += *phi[0];
    //   -- rotational correction
#ifdef ROTATIONAL_CORRECTION
    divg_rhs(D, v_i, rhs[0], false, false);
    D->u[CIND]->axpy(-1.0*Femlib::value("KINVIS"), *rhs[0]);
#endif

    for(int ii = 0; ii < 3; ii++) *v_i[ii] = *D->u[ii];
    const_mass_flux_correction(D, v_i, 1.0);
    for(int ii = 0; ii < 3; ii++) *D->u[ii] = *v_i[ii];

    // 3. convergence test
    int_u2 = integrate_ke(v_i);
    for(int ii = 0; ii < 3; ii++) *v_i[ii] -= *u_i[ii];
    int_du2 = integrate_ke(v_i);
    for(int ii = 0; ii < 3; ii++) *v_i[ii] += *u_i[ii];
    if(!Geometry::procID()) cout << "\t|u|^2: " << int_u2 << "\t|du|^2: " << int_du2 << "\t|du^2/u^2|^{1/2}: " << sqrt(int_du2/int_u2) << "\t";
    int_p = D->u[CIND]->integral();
    if(!Geometry::procID()) cout << "global pressure integral: " << int_p << "\t";

    for(int ii = 0; ii < 3; ii++) D->u[ii]->smooth(D->u[ii]);

#ifdef ID_DIAGNOSTIC
    *pres = *D->u[CIND];
    diagnostics(D, true);
#endif
    
    for(int ii = 0; ii < 3; ii++) *u_i[ii] = *D->u[ii];
    for(int ii = 0; ii < 3; ii++) u_i[ii]->zeroNyquist();

    divg_rhs(D, u_i, rhs[0], false, true); // compute the divergence at the end of the iteration (for testing)

    iter++;
    if(sqrt(int_du2/int_u2) < 1.0e-14) done = 1;
    MPI_Bcast(&done, 1, MPI_INT, 0, MPI_COMM_WORLD);
    MPI_Barrier(MPI_COMM_WORLD);
  }

  for(int ii = 0; ii < 3; ii++) {
    *rhs[ii] = *phi_c[0];
    rhs[ii]->gradient(ii);
    if(ii == 2) rhs[ii]->divY();
//    D->u[ii]->axpy(-dt, *rhs[ii]);
//zero_dirichlet_bcs(D->u[ii]);
//    D->u[0]->smooth(D->u[ii]);
  }
  _axpy(u_i, -dt, rhs, u_i);
  for(int ii = 0; ii < 3; ii++) *D->u[ii] = *u_i[ii];
  for(int ii = 0; ii < 3; ii++) D->u[0]->smooth(D->u[ii]);
if(step==1000){D->dump();abort();}

{
int_u2 = integrate_ke(v_i);
if(!Geometry::procID()) cout << "end of step, final ke: " << int_u2 << endl;
int_p = D->u[CIND]->integral();
if(!Geometry::procID()) cout << "global pressure integral: " << int_p << endl;
}

  Femlib::ivalue("N_TIME", ntime);
  *D->u[PIND] = *D->u[CIND];

  alloc_pc = false;
}

void integrate (void (*advection) (Domain*    , 
                                   BCmgr*     ,
                                   AuxField** , 
                                   AuxField** ,
                                   FieldForce*),
                Domain*      D ,
                BCmgr*       B ,
                DNSAnalyser* A ,
                FieldForce*  FF)
// ---------------------------------------------------------------------------
// On entry, D contains storage (in the following order!) for:
// -- velocity Fields 'u', 'v' (and 'w' if 2D3C or 3D),
// -- optional scalar Field 'c',
// -- constraint Field 'p'.
//
// Us is multi-level auxillary Field storage for velocities and
// Uf is multi-level auxillary Field storage for nonlinear forcing terms.
// ---------------------------------------------------------------------------
{
  NCOM = D -> nVelCmpt();              // -- Number of velocity components.
  //NADV = D -> nAdvect();               // -- Number of advected fields.
  NADV = NCOM;
  NDIM = Geometry::nDim();	       // -- Number of space dimensions.
  NORD = Femlib::ivalue ("N_TIME");    // -- Time integration order.
  C3D  = Geometry::cylindrical() && NDIM == 3;
  PIND = (D->hasScalar()) ? NCOM+1 : NCOM;

  //if(Femlib::ivalue("PC_STEP"))         { CIND = PIND; }
  //else if(Femlib::ivalue("RK_SUBSTEP")) { CIND = D->nVelCmpt(); PIND = CIND; }
CIND = D->nVelCmpt();
  if(!Geometry::procID()) cout << "pressure index: " << PIND << endl;
  if(!Geometry::procID()) cout << "  scalar index: " << CIND << endl;

  int_t              i, j, k;
  const real_t       dt    = Femlib:: value ("D_T");
  const int_t        nStep = Femlib::ivalue ("N_STEP");
  const int_t        nZ    = Geometry::nZProc();
  static Msys**      MMS;
  static AuxField*** Us;
  static AuxField*** Uf;
  Field*             Pressure = D -> u[PIND];
  double mff_correction;
  bool substep = true;

  if (!MMS) {			// -- Initialise static storage.

    // -- Create multi-level storage for velocities and forcing.

    const int_t ntot  = Geometry::nTotProc();
    real_t*     alloc = new real_t [static_cast<size_t>(2 * NADV*NORD * ntot)];
    Us                = new AuxField** [static_cast<size_t>(2 * NORD)];
    Uf                = Us + NORD;

    for (k = 0, i = 0; i < NORD; i++) {
      Us[i] = new AuxField* [static_cast<size_t>(2 * NADV)];
      Uf[i] = Us[i] + NADV;
      for (j = 0; j < NADV; j++) {
        Us[i][j] = new AuxField (alloc + k++ * ntot, nZ, D -> elmt);
        Uf[i][j] = new AuxField (alloc + k++ * ntot, nZ, D -> elmt);
      }
    }

    // -- Create global matrix systems.

    MMS = preSolve (D);

    // -- Create multi-level storage for pressure BCS.

    B -> buildComputedBCs (Pressure);

    // -- Apply coupling to radial & azimuthal velocity BCs.

if(!Femlib::ivalue("RK_SUBSTEP"))
    if (C3D) Field::coupleBCs (D -> u[1], D -> u[2], FORWARD);
  }

  // -- Because we may restart from scratch on each call, zero these:

  *Pressure = 0.0;

  for (i = 0; i < NORD; i++)
    for (j = 0; j < NADV; j++) {
      *Us[i][j] = 0.0;
      *Uf[i][j] = 0.0;
    }

  // -- Solve the Stokes flow problem with unit forcing
  if(!D->grn[0] && fabs(Femlib::value("Q_BAR")) > 1.0e-6) {
    real_t            L_x   = Femlib::value("XMAX");
    vector<AuxField*> tmp;
    tmp.resize(4);

    for (i = 0; i < 4; i++) {
      D->grn[i] = new AuxField(new real_t[(size_t)Geometry::nTotProc()], Geometry::nZProc(), D->elmt, 'g'+i);
      tmp[i] = new AuxField(new real_t[(size_t)Geometry::nTotProc()], Geometry::nZProc(), D->elmt, 'k'+i);
      *tmp[i] = *D->u[i];
      *D->u[i] = 0.0;
    }

    // -- Set the constant forcing
    for (i = 0; i < NCOM; i++) *Uf[0][i] = 0.0;
    ROOTONLY {
      Uf[0][0] -> addToPlane (0, 1.0);
      if (Geometry::cylindrical()) Uf[0][0] -> mulY ();
    }

    D->step += 1;

    // -- Update high-order pressure BC storage.
    B -> maintainFourier (D -> step, Pressure, const_cast<const AuxField**>(Us[0]), const_cast<const AuxField**>(Uf[0]));
    Pressure -> evaluateBoundaries (Pressure, D -> step);

    // -- Complete unconstrained advective substep and compute pressure.
    if (Geometry::cylindrical()) { Us[0][0] -> mulY(); Us[0][1] -> mulY(); }

    waveProp (D, const_cast<const AuxField***>(Us), const_cast<const AuxField***>(Uf));
    for (i = 0; i < NADV; i++) AuxField::swapData (D -> u[i], Us[0][i]);

    rollm     (Uf, NORD, NADV);
    setPForce (const_cast<const AuxField**>(Us[0]), Uf[0]);
    Solve     (D, PIND,  Uf[0][0], MMS[PIND]);

    // -- Correct velocities for pressure.
    project   (D, Us[0], Uf[0]);

    // -- Update multilevel velocity storage.
    for (i = 0; i < NADV; i++) *Us[0][i] = *D -> u[i];
    rollm (Us, NORD, NADV);

    // -- Re-evaluate velocity (possibly time-dependent) BCs.
    for (i = 0; i < NADV; i++)  {
      D -> u[i] -> evaluateBoundaries (NULL,     D -> step, false);
      D -> u[i] -> bTransform         (FORWARD);
      D -> u[i] -> evaluateBoundaries (Pressure, D -> step, true);
    }
if(!Femlib::ivalue("RK_SUBSTEP"))
    if (C3D) Field::coupleBCs (D -> u[1], D -> u[2], FORWARD);

    // -- Viscous correction substep.
    if (C3D) {
      AuxField::couple (Uf [0][1], Uf [0][2], FORWARD);
      AuxField::couple (D -> u[1], D -> u[2], FORWARD);
    }
    for (i = 0; i < NADV; i++) Solve (D, i, Uf[0][i], MMS[i]);
    if (C3D) AuxField::couple (D -> u[1], D -> u[2], INVERSE);

    D->step -= 1;

    // this will be broadcast to the other procs when applied
    D->Qg  = 2.0 * M_PI * D->u[0]->integral(0) / Femlib::ivalue("BETA");
    D->Qg /= (M_PI * 1.0 * 1.0 * L_x / Femlib::ivalue("BETA"));
    if(!Geometry::procID()) cout << "Stokes + unit forcing volumetric flux: " << D->Qg << endl;
    if(!Geometry::procID()) cout << "                          ux integral: " << 2.0 * M_PI * D->u[0]->integral(0) / Femlib::ivalue("BETA") << endl;
    if(!Geometry::procID()) cout << "                          pipe length: " << L_x << endl;

    // -- Resetting fields
    for (i = 0; i < 4; i++) {
      *D->grn[i] = *D->u[i];
      *D->u[i]   = *tmp[i];
    }

    *Pressure = 0.0;
    for (i = 0; i < NORD; i++)
      for (j = 0; j < NADV; j++) {
        *Us[i][j] = 0.0;
        *Uf[i][j] = 0.0;
      }
    // do we really need to do this again??
    //B -> buildComputedBCs (Pressure);
  }

  // -- The following timestepping loop implements equations (15--18) in [5].

#ifdef ID_DIAGNOSTIC
  // setup only
  diagnostics(D, true);
#endif

  while (D -> step < nStep) {

#ifdef ID_DIAGNOSTIC
    diagnostics(D, true);
#endif

    // explicit (second order pressure) time stepping for first time step
    if(substep && Femlib::ivalue("RK_SUBSTEP")) {
      int n_sub_steps = Femlib::ivalue("RK_SUBSTEP");
      real_t _dt = dt / n_sub_steps;
      //Femlib::value("D_T", _dt);

      init_fields(D);
      //for(int ii = 0; ii < n_sub_steps; ii++) {
      for(int ii = 0; ii < Femlib::ivalue("RK_STEPS") * n_sub_steps; ii++) {
        if(!Geometry::procID()) cout << "\nRK substep: " << ii << "\n" << endl;
        rk_step(advection, D, B, A, FF, ii, MMS, Us[1], Uf[1]);
        //rk_step_first_order(advection, D, B, A, FF, ii, MMS, Us[1], Uf[1]);
#ifdef ID_DIAGNOSTIC
        *pres = *D->u[CIND];
        diagnostics(D, true);
#endif
//for(int jj = 0; jj < 3; jj++) *Us[0][jj] = *D->u[jj];
//for(int jj = 0; jj < 3; jj++) *Uf[0][jj] = *Uf[0][jj];
//A->analyse(Us[0], Uf[0]);
      }

      //Femlib::value("D_T",  dt);
      D->step += 1;
      D->time += dt;
      Femlib::value("t", D->time);

      substep = false;

      continue;
    }

    // iterate on the pressure correction scheme for the first step
    if(substep && Femlib::ivalue("PC_STEP")) {
      init_fields(D);

      for(int ii = 0; ii < Femlib::ivalue("PC_STEP"); ii++) {
        if(!Geometry::procID()) cout << "doing pressure correction, step: " << ii << endl;
        pc_loop(advection, D, B, A, FF, MMS, Us[1], Uf[1], ii);
#ifdef ID_DIAGNOSTIC
        *pres = *D->u[CIND];
        diagnostics(D, true);
#endif
        D->time += dt;
      }
      D->step = Femlib::ivalue("PC_STEP");

      substep = false;

      continue;
    }

    // -- Compute nonlinear terms from previous velocity field.
    //    Add physical space forcing, again at old time level.
    //
    advection (D, B, Us[0], Uf[0], FF);
    
    // -- Now update the time (remainder including BCs at new time level).

    D -> step += 1;
    D -> time += dt;
    Femlib::value ("t", D -> time);

    // -- Update high-order pressure BC storage.

    B -> maintainFourier (D -> step, Pressure,
			  const_cast<const AuxField**>(Us[0]),
			  const_cast<const AuxField**>(Uf[0]));
    Pressure -> evaluateBoundaries (Pressure, D -> step);

    // -- Complete unconstrained advective substep and compute pressure.

    if (Geometry::cylindrical()) { Us[0][0] -> mulY(); Us[0][1] -> mulY(); }

    waveProp (D, const_cast<const AuxField***>(Us),
	         const_cast<const AuxField***>(Uf));
    for (i = 0; i < NADV; i++) AuxField::swapData (D -> u[i], Us[0][i]);

    rollm     (Uf, NORD, NADV);
    setPForce (const_cast<const AuxField**>(Us[0]), Uf[0]);
    Solve     (D, PIND,  Uf[0][0], MMS[PIND]);

#ifdef ID_DIAGNOSTIC
    // copy over before this gets stomped on by the fieldforce
    *pres = *D->u[PIND];
#endif

    // -- Correct velocities for pressure.

    project   (D, Us[0], Uf[0]);

    // -- Update multilevel velocity storage.

    for (i = 0; i < NADV; i++) *Us[0][i] = *D -> u[i];
    rollm (Us, NORD, NADV);

    // -- Re-evaluate velocity (possibly time-dependent) BCs.

    for (i = 0; i < NADV; i++)  {
      D -> u[i] -> evaluateBoundaries (NULL,     D -> step, false);
      D -> u[i] -> bTransform         (FORWARD);
      D -> u[i] -> evaluateBoundaries (Pressure, D -> step, true);
    }
    if (C3D) Field::coupleBCs (D -> u[1], D -> u[2], FORWARD);

    // -- Viscous correction substep.

    if (C3D) {
      AuxField::couple (Uf [0][1], Uf [0][2], FORWARD);
      AuxField::couple (D -> u[1], D -> u[2], FORWARD);
    }

    if(D->step == 1) Femlib::ivalue("N_TIME", 1);
    if(D->step == 2) Femlib::ivalue("N_TIME", 2);
    for (i = 0; i < NADV; i++) Solve (D, i, Uf[0][i], MMS[i]);
    if(D->step == 1) Femlib::ivalue("N_TIME", NORD);
    if(D->step == 2) Femlib::ivalue("N_TIME", NORD);
    if (C3D)
      AuxField::couple (D -> u[1], D -> u[2], INVERSE);

    // constant flow rate
    if(fabs(Femlib::value("Q_BAR")) > 1.0e-6) {
      real_t L_x       = Femlib::value("XMAX");
      real_t _refQ     = Femlib::value("Q_BAR");
      real_t getQ, dP;
      if(!Geometry::procID()) {
        getQ  = 2.0 * M_PI * D->u[0]->integral(0) / Femlib::ivalue("BETA");
        getQ /= (M_PI * 1.0 * 1.0 * L_x) / Femlib::ivalue("BETA");
        dP    = (_refQ - getQ) / D->Qg;
      }
      MPI_Bcast(&dP, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);

      for(i = 0; i < NADV; i++) D->u[i]->axpy(dP, *D->grn[i]);
    }

    // -- Process results of this step.

    A -> analyse (Us[0], Uf[0]);
  }
}

static void waveProp (Domain*           D ,
		      const AuxField*** Us,
		      const AuxField*** Uf)
// ---------------------------------------------------------------------------
// Compute the first substep of stiffly-stable timestepping scheme.
//
// On entry, the most recent velocity fields are in Us, and the most
// recent nonlinear terms in Uf.  The intermediate velocity field u^ is
// computed and left in D's velocity areas.
//
// This is the only routine that makes explicit use of the multi time
// level structure of Us & Uf.
// ---------------------------------------------------------------------------
{
  int_t             i, q;
  vector<AuxField*> H (NADV);	// -- Mnemonic for u^{Hat}.

  for (i = 0; i < NADV; i++) {
     H[i] = D -> u[i];
    *H[i] = 0.0;
  }

  const int_t    Je = min (D -> step, NORD);
  vector<real_t> alpha (Integration::OrderMax + 1);
  vector<real_t> beta  (Integration::OrderMax);

  Integration::StifflyStable (Je, &alpha[0]);
  Integration::Extrapolation (Je, &beta [0]);
if(!Geometry::procID()) cout << "alpha: " << alpha[0] << "\t" << alpha[1] << "\t" << alpha[2] << endl;
if(!Geometry::procID()) cout << "beta:  " <<  beta[0] << "\t" <<  beta[1] << endl;
  Blas::scal (Je, Femlib::value ("D_T"), &beta[0],  1);

  for (i = 0; i < NADV; i++)
    for (q = 0; q < Je; q++) {
      H[i] -> axpy (-alpha[q + 1], *Us[q][i]);
      H[i] -> axpy ( beta [q]    , *Uf[q][i]);
    }
}


static void setPForce (const AuxField** Us,
		       AuxField**       Uf)
// ---------------------------------------------------------------------------
// On input, intermediate velocity storage u^ is in Us.  Create div u^ / D_T
// in the first dimension of Uf as a forcing field for discrete PPE.
// ---------------------------------------------------------------------------
{
  int_t        i;
  const real_t dt = Femlib::value ("D_T");

  for (i = 0; i < NDIM; i++) (*Uf[i] = *Us[i]) . gradient (i);

  for (i = 1; i < NDIM; i++) *Uf[0] += *Uf[i];

  *Uf[0] /= dt;
}


static void project (const Domain* D ,
		     AuxField**    Us,
		     AuxField**    Uf)
// ---------------------------------------------------------------------------
// On input, new pressure field is stored in D and intermediate velocity
// level u^ is stored in Us.  Constrain velocity field:
//
//                    u^^ = u^ - D_T * grad P,
//
// then scale by -1.0 / (D_T * KINVIS) to create forcing for viscous step
// (this is -1.0 / (D_T  * diffusivity) in the case of a scalar field).
//
// u^^ is left in Uf.
// ---------------------------------------------------------------------------
{
  int_t        i;
  const real_t alpha = -1.0 / Femlib::value ("D_T * KINVIS");
  const real_t beta  =  1.0 / Femlib::value ("KINVIS");
  const real_t Pr    =        Femlib::value ("PRANDTL");
  real_t mass_flux;

  for (i = 0; i < NADV; i++) {
    Field::swapData (Us[i], Uf[i]);
    if (Geometry::cylindrical() && i >= 2) Uf[i] -> mulY();
    *Uf[i] *= alpha;
  }

  // -- For scalar, use diffusivity instead of viscosity.
  if (NADV > NCOM) *Uf[NCOM] *= Pr;

  for (i = 0; i < NDIM; i++) {
    (*Us[0] = *D -> u[PIND]) . gradient (i);

    if (Geometry::cylindrical() && i <  2) Us[0] -> mulY();
    Uf[i] -> axpy (beta, *Us[0]);
  }
}


static Msys** preSolve (const Domain* D)
// ---------------------------------------------------------------------------
// Set up ModalMatrixSystems for each Field of D.  If iterative solution
// is selected for any Field, the corresponding ModalMatrixSystem pointer
// is set to zero.
//
// ITERATIVE >= 1 selects iterative solver for velocity components,
// ITERATIVE >= 2 selects iterative solver for non-zero pressure Fourier modes.
// ---------------------------------------------------------------------------
{
  const int_t             nmodes = Geometry::nModeProc();
  const int_t             base   = Geometry::baseMode(); 
  const int_t             itLev  = Femlib::ivalue ("ITERATIVE");
  const real_t            beta   = Femlib:: value ("BETA");
  const vector<Element*>& E = D -> elmt;
  Msys**                  M = new Msys* [static_cast<size_t>(NADV + 1)];
  int_t                   i;

  vector<real_t> alpha (Integration::OrderMax + 1);
  Integration::StifflyStable (NORD, &alpha[0]);
  real_t   lambda2 = alpha[0] / Femlib::value ("D_T * KINVIS");

  // -- Velocity systems.

  for (i = 0; i < NCOM; i++) {
    M[i] = new Msys
      (lambda2, beta, base, nmodes, E, D -> b[i], (itLev) ? JACPCG : DIRECT);
  }

  // -- Scalar system.
/*
  if (NADV != NCOM) {
    lambda2 = alpha[0] / Femlib::value ("D_T * KINVIS / PRANDTL");
    M[NCOM] = new Msys
      (lambda2, beta, base, nmodes, E, D -> b[NCOM],(itLev < 1)?DIRECT:JACPCG);
  }
*/
  // -- Pressure system.

  if (itLev > 1)
    M[PIND] = new Msys
      (0.0, beta, base, nmodes, E, D -> b[PIND], MIXED);
  else
    M[PIND] = new Msys
      (0.0, beta, base, nmodes, E, D -> b[PIND], DIRECT);

  return M;
}


static void Solve (Domain*     D,
		   const int_t i,
		   AuxField*   F,
		   Msys*       M)
// ---------------------------------------------------------------------------
// Solve Helmholtz problem for D->u[i], using F as a forcing Field.
// Iterative or direct solver selected on basis of field type, step,
// time order and command-line arguments.
// ---------------------------------------------------------------------------
{
  const int_t step = D -> step;

  if (i < NADV && step < NORD) { // -- We need a temporary matrix system.
    const int_t Je     = min (step, NORD);
    const int_t base   = Geometry::baseMode();
    const int_t nmodes = Geometry::nModeProc();

    vector<real_t> alpha (Je + 1);
    Integration::StifflyStable (Je, &alpha[0]);
    const real_t   lambda2 = (i == NCOM) ? // -- True for scalar diffusion.
      alpha[0] / Femlib::value ("D_T * KINVIS / PRANDTL") :
      alpha[0] / Femlib::value ("D_T * KINVIS");
    const real_t   beta    = Femlib::value ("BETA");

    Msys* tmp = new Msys
      (lambda2, beta, base, nmodes, D -> elmt, D -> b[i], JACPCG);
    D -> u[i] -> solve (F, tmp);
    delete tmp;

  } else D -> u[i] -> solve (F, M);
}
