///////////////////////////////////////////////////////////////////////////////
// statistics.C: routines for statistical analysis of AuxFields.
//
// Copyright (c) 1994 <--> $Date$, Hugh Blackburn
//
// At present, this is limited to running averages of primitive
// variables, regardless of value of AVERAGE.
//
// NB: Modified for use with dual: no computation of Reynolds stresses.
///////////////////////////////////////////////////////////////////////////////

static char RCS[] = "$Id$";

#include <ctime>
#include <sem.h>


Statistics::Statistics (Domain* D) :
// ---------------------------------------------------------------------------
// Store averages for all Domain Fields (no extra fields - Reynolds stress).
//
// Try to initialize from file session.avg, failing that set all
// buffers to zero.  Number of fields in file should be same as
// Statistics::avg buffer.
//
// NR = Number of Reynolds stress averaging buffers, set if AVERAGE > 1.
// ---------------------------------------------------------------------------
  name (D -> name),
  base (D)
{
  int_t       i, j;
  const int_t ND    = Geometry::nDim();
  const int_t NF    = base -> u.size();
  const int_t NE    = 0;
  const int_t NR    = 0;
  const int_t NT    = NF + NE + NR;
  const int_t nz    = Geometry::nZProc();
  const int_t ntot  = Geometry::nTotProc();
  real_t*     alloc = new real_t [static_cast<size_t> (NT * ntot)];

  ROOTONLY cout << "-- Initializing averaging  : ";  

  // -- Set pointers, allocate storage.

  src.resize (NF + NE);	// -- Straight running average of these.
  avg.resize (NT);		// -- Additional are computed from src.
  
  for (i = 0; i < NF; i++) src[     i] = (AuxField*) base -> u[i];
  for (i = 0; i < NE; i++) src[NF + i] = extra[i];

  for (j = 0, i = 0; i < NF + NE; i++, j++)
    avg[i] = new AuxField (alloc+j*ntot, nz, base -> elmt, src[i] -> name());
  for (i = 0; i < NT - NF - NE; i++, j++)
    avg[i + NF + NE] = new AuxField (alloc+j*ntot, nz, base -> elmt, 'A' + i);

  // -- Initialise averages, either from file or zero.
  //    This is much the same as Domain input routine.

  char     s[StrMax];
  ifstream file (strcat (strcpy (s, name), ".avg"));

  if (file) {
    ROOTONLY {
      cout << "read from file " << s;
      cout.flush();
    }
    file >> *this;
    file.close();
  } else {			// -- No file, set to zero.
    ROOTONLY cout << "set to zero";
    for (i = 0; i < NT; i++) *avg[i] = 0.0;
    navg = 0;
  }

  ROOTONLY cout << endl;
}


void Statistics::update (AuxField** work)
// ---------------------------------------------------------------------------
// Update running averages, using zeroth time level of work as
// workspace.  Reynolds stress terms are calculated without
// dealiasing, and are held in physical space.
// ---------------------------------------------------------------------------
{
  int_t       i;
  const int_t NT = avg.size();
  const int_t ND = Geometry::nDim();
  const int_t NR = 0;
  const int_t NA = NT - NR;

  // -- Running averages only.

  for (i = 0; i < NA; i++) {
    *avg[i] *= static_cast<real_t> (navg);
    *avg[i] += *src[i];
    *avg[i] /= static_cast<real_t> (navg + 1);
  }

  navg++;
}


void Statistics::dump ()
// ---------------------------------------------------------------------------
// Similar to Domain::dump.
// ---------------------------------------------------------------------------
{
  const int_t step     = base -> step;
  const bool  periodic = !(step %  Femlib::ivalue ("IO_FLD"));
  const bool  initial  =   step == Femlib::ivalue ("IO_FLD");
  const bool  final    =   step == Femlib::ivalue ("N_STEP");

  if (!(periodic || final)) return;

  ofstream    output;
  const int_t NT = avg.size();
  const int_t ND = Geometry::nDim();

  ROOTONLY {
    const char routine[] = "Statistics::dump";
    const bool verbose   = Femlib::ivalue ("VERBOSE");
    const bool chkpoint  = Femlib::ivalue ("CHKPOINT");
    char       dumpfl[StrMax], backup[StrMax], command[StrMax];

    if (chkpoint) {
      if (final) {
	strcat (strcpy (dumpfl, name), ".avg");
	output.open (dumpfl, ios::out);
      } else {
	strcat (strcpy (dumpfl, name), ".ave");
	if (!initial) {
	  strcat  (strcpy (backup, name), ".ave.bak");
	  sprintf (command, "mv ./%s ./%s", dumpfl, backup);
	  system  (command);
	}
	output.open (dumpfl, ios::out);
      }
    } else {
      strcat (strcpy (dumpfl, name), ".avg");
      if   (initial) output.open (dumpfl, ios::out);
      else           output.open (dumpfl, ios::app);
    }

    if (!output) message (routine, "can't open dump file", ERROR);
    if (verbose) message (routine, ": writing field dump", REMARK);
  }

  output << *this;

  ROOTONLY output.close();
}


ofstream& operator << (ofstream&   strm,
		       Statistics& src )
// ---------------------------------------------------------------------------
// Output Statistics class to file.  Like similar Domain routine.
// ---------------------------------------------------------------------------
{
  int_t           i;
  const int_t     N = src.avg.size();
  vector<AuxField*> field (N);

  for (i = 0; i < N; i++) field[i] = src.avg[i];

  writeField (strm, src.name, src.navg, src.base -> time, field);

  return strm;
}


ifstream& operator >> (ifstream&   strm,
		       Statistics& tgt )
// ---------------------------------------------------------------------------
// Input Statistics class from file.  Like similar Domain routine.
// ---------------------------------------------------------------------------
{
  const char routine[] = "strm>>Statistics";
  int_t      i, j, np, nz, nel, ntot, nfields;
  int_t      npchk,  nzchk, nelchk, swap = 0;
  char       s[StrMax], f[StrMax], err[StrMax], fields[StrMax];

  if (strm.getline(s, StrMax).eof()) return strm;
  
  strm.getline (s, StrMax) . getline (s, StrMax);

  tgt.avg[0] -> describe (f);
  istrstream (s, strlen (s)) >> np    >> np    >> nz    >> nel;
  istrstream (f, strlen (f)) >> npchk >> npchk >> nzchk >> nelchk;
  
  if (np  != npchk ) message (routine, "element size mismatch",       ERROR);
  if (nz  != nzchk ) message (routine, "number of z planes mismatch", ERROR);
  if (nel != nelchk) message (routine, "number of elements mismatch", ERROR);
  
  ntot = np * np * nz * nel;
  if (ntot != Geometry::nTot())
    message (routine, "declared sizes mismatch", ERROR);

  strm.getline (s,StrMax);
  istrstream (s, strlen (s)) >> tgt.navg;
    
  strm.getline (s, StrMax) . getline (s, StrMax);
  strm.getline (s, StrMax) . getline (s, StrMax) . getline (s, StrMax);
    
  nfields = 0;
  while (isalpha (s[nfields])) {
    fields[nfields] = s[nfields];
    nfields++;
  }
  fields[nfields] = '\0';
  if (nfields != tgt.avg.size()) {
    sprintf (err, "strm: %1d fields, avg: %1d", nfields, tgt.avg.size());
    message (routine, err, ERROR);
  }
  for (i = 0; i < nfields; i++) 
    if (!strchr (fields, tgt.avg[i] -> name())) {
      sprintf (err, "field %c not present in avg", fields[i]);
      message (routine, err, ERROR);
    }

  strm.getline (s, StrMax);
  Veclib::describeFormat (f);

  if (!strstr (s, "binary"))
    message (routine, "input field strm not in binary format", ERROR);
  
  if (!strstr (s, "endian"))
    message (routine, "input field strm in unknown binary format", WARNING);
  else {
    swap = ((strstr (s, "big") && strstr (f, "little")) ||
	    (strstr (f, "big") && strstr (s, "little")) );
    ROOTONLY {
      if (swap) cout << " (byte-swapping)";
      cout.flush();
    }
  }
    
  for (j = 0; j < nfields; j++) {
    for (i = 0; i < nfields; i++)
      if (tgt.avg[i] -> name() == fields[j]) break;
    strm >> *tgt.avg[i];
    if (swap) tgt.avg[i] -> reverse();
  }
  
  ROOTONLY if (strm.bad())
    message (routine, "failed reading average file", ERROR);

  return strm;
}



