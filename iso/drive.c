/*****************************************************************************
 * Iso:
 * ----
 * DNS of isotropic turbulence by a Fourier-Galerkin pseudo-spectral method.
 *
 * Usage:
 * ------
 * iso -s <start_file> || -r <restart_file>
 *
 * Method:
 * -------
 * Time evolution of Fourier coefficients of flow in box with sides of length
 * 2PI and periodic boundary conditions.  Number of modes in each direction
 * must be the same integer power of two.
 *
 * Computation of the non-linear terms is fully de-aliased by the method
 * of isotropically-truncated convolution sums in conjunction with phase
 * shifts, as described by Orszag [1].
 *
 * Time advancement is explicit, Adams-Bashforth 2 on the nonlinear
 * terms, with an analytic integrating-factor treatment of viscous terms,
 * developed by Rogallo [2].  Initial timestep is Euler.
 *
 * A general description of the Fourier treatment and elimination of
 * pressure by projection in Fourier-space can be found in ch. 4 of
 * Lesieur's book [3].
 *
 * Storage requirements:
 * ---------------------
 * In terms of the main storage, the programme carries 13*N*N*N words, with
 * additional incidental requirements for storage of one-dimensional vectors
 * and scalar variables.
 *
 * Main storage consists of the Fourier coefficients of the velocities
 * (3*N*N*N), the nonlinear terms at the current timestep (G) and the last
 * timestep (G_old) (6*N*N*N), and workspace (4*N*N*N).  The most obvious
 * ways to save storage would be to carry only two velocity components, and
 * to keep G_old on disk: this would produce a saving of 4*N*N*N.  With much
 * hard work, an additional N*N*N of workspace could probably be saved.
 * For large simulations, out-of-core storage will be needed.
 *
 * Files:
 * ------
 * At start-up, two files are needed; an ASCII start-file, which gives run
 * parameters, and a binary file which gives the initial condition
 * velocity Fourier coefficients.  The IC file is named in the start-file.
 *
 * Example start-file:  Comments: {not in file}, (ignored if present).
 *   Test run                {title, which is recorded but not used}
 *   Top_Hat                 (name of a binary IC file)
 *   64                      (number of Fourier modes in each direction)
 *   0.0001                  (time step)
 *   1000                    (number of time steps between restart files)
 *   1000000                 (maximum number of time-steps)
 *   0.0707                  (value of kinematic viscosity)
 *
 * All this information is stored, updated and written at the beginning
 * of restart files generated by the programme.  Binary restart files are
 * created whenever the number of timesteps taken is an integer multiple of
 * the number of timesteps between restart files specified in the start-file.
 * The restart files begin with header information, preceeded by a "magic"
 * number which identifies the files as created by iso.  Next come the three
 * velocity-component Fourier coefficients, followed by the nonlinear terms
 * from the next-to-last timestap (G_old) which must be carried for the two-
 * level explicit scheme.  Restart files can be used to re-initiate
 * execution (as implied by the name!): iso -r filename.
 *
 * Names of restart files are generated by appending a numeric tag to
 * the name of the IC file.
 *
 * References:
 * -----------
 * [1]  S.A. Orszag, 1971, 'Numerical simulation of incompressible flows
 *        within simple boundaries. 1. Galerkin (spectral) representations',
 *        Stud. Appl. Math., VLN4, Dec., pp. 293--327.
 * [2]  R.S. Rogallo, 1981, 'Numerical experiments in homogeneous
 *        turbulence', NASA TM 81315, Sept.
 * [3]  M. Lesieur, 1990,  Turbulence in Fluids, 2nd ed, Kluwer Academic.
 * [4]  C. Canuto, M.Y. Hussaini, A. Quarteroni & T.A. Zang, 1988,  Spectral
 *        Methods in Fluid Dynamics, Springer.
 *
 *
 * Program development by:
 * -----------------------
 * Hugh Blackburn
 * Department of Mechanical Engineering
 * Monash University
 * Clayton VIC 3168
 * hmb@artemis.eng.monash.edu.au
 *
 * $Id$
 *****************************************************************************/

#include "globals.h"


#define  SWAP(a, b)   G_temp = (a); (a) = (b); (b) = G_temp;

static void getargs (int, char**, int*, string);
static char prog[] = "iso";


int main (int argc, char *argv[])
{
  CVF       U, G, G_old, G_temp, work;
  CF        F;
  int*      Dim;
  complex*  Wtab;
  complex*  Stab;
  int       TabLen;
  header*   Run_info = calloc (1, sizeof (header));
  header*   IC_info  = calloc (1, sizeof (header));
  int       Start;
  string    Input_file, Restart_file;
  FILE*     fp;
  int       Npts;
  real      q2;


  Start = TRUE;
  getargs (argc, argv, &Start, Input_file);
  
  if (Start) {			/* -- Start-up, with Euler step.  */
    fp = efopen     (Input_file, "r");
    read_start_file (fp,     Run_info);
    Run_info -> N_Step = 0;
    print_header    (stdout, Run_info);
    fclose          (fp);

    Dim    =  ivector (1, 3);
    Dim[1] = (Dim[2] = Run_info -> N_Grid);
    Dim[3] =  Dim[1] / 2;
    Npts   =  Dim[1] * Dim[2] * Dim[3];

    allocate_storage (&U, &G, &G_old, &work, &F, &Wtab, &Stab, Dim);

    fp = efopen (Run_info -> IC_File, "r");
    read_header (fp, IC_info);

    if (IC_info -> N_Grid != Run_info -> N_Grid)
      message (prog, "Size of IC file doesn't match declaration", ERROR);

    read_field (fp, U, Npts);
    fclose     (fp);

    preFFT   (Dim[3], Wtab);
    preShift (Dim[1], Stab);
    
    q2 = energy (Dim, U);
    fprintf (stdout, "\nStep 0, energy: %.3e\n", q2);

    nonlin    (U, G, F, work, Wtab, Stab, Dim);
    integrate (U, G, G_old, Run_info, Dim, Start);
    Run_info-> N_Step++;

    q2 = energy (Dim, U);    
    fprintf (stdout, "Step %d, energy: %.3e\n", Run_info -> N_Step, q2);

    SWAP (G, G_old);

    Start = FALSE;

  } else {			/* -- Restart from file. */
    fp = efopen  (Input_file, "r");
    read_header  (fp,     Run_info);    
    print_header (stdout, Run_info);    
    
    Dim    =  ivector (1, 3);
    Dim[1] = (Dim[2] = Run_info -> N_Grid);
    Dim[3] =  Dim[1] / 2;
    Npts   =  Dim[1] * Dim[2] * Dim[3];

    allocate_storage (&U, &G, &G_old, &work, &F, &Wtab, &Stab, Dim);
    
    read_field (fp, U,     Npts);
    read_field (fp, G_old, Npts);
    
    fclose (fp);

    preFFT   (Dim[3], Wtab);
    preShift (Dim[1], Stab);
  }

  /* -- Main time-stepping loop. */

  while (Run_info -> N_Step < Run_info -> Max_Step) {

    nonlin    (U, G, F, work, Wtab, Stab, Dim);
    integrate (U, G, G_old, Run_info, Dim, Start);
    Run_info -> N_Step++;

    q2 = energy (Dim, U);    
    fprintf     (stdout, "Step %d, energy: %.3e\n", Run_info -> N_Step, q2);
    fflush      (stdout);

    SWAP (G, G_old);
    
    if (Run_info -> N_Step % Run_info -> N_Save == 0) {
      make_file_name (Run_info, Restart_file);
      fp = efopen    (Restart_file, "w");
      write_restart  (fp, Run_info, U, G_old, Npts);
      fclose         (fp);
    }
  }

  return EXIT_SUCCESS;
}


static void getargs (int argc, char *argv[], int *Start, string Input_file)
/* ------------------------------------------------------------------------- *
 * Process command-line arguments.
 * Usage: iso -s <start_file> || -r <restart_file>
 * ------------------------------------------------------------------------- */
{
  if (argc == 3) {
    if (argv[1][0] == '-' && argv[1][1] == 'r') {
      *Start = FALSE;
      strcpy (Input_file, argv[2]);
    } else if (argv[1][0] == '-' && argv[1][1] == 's') {
      strcpy (Input_file, argv[2]);
    } else {
      fprintf (stderr, "iso: bad flag %s\n", argv[1]);
      fprintf (stderr, "Usage: iso -s <start_file> || -r <restart_file>\n");
      exit    (EXIT_FAILURE);
    }
  } else {
    fprintf (stderr, "iso: arg count\n");
    fprintf (stderr, "Usage: iso -s <start_file> || -r <restart_file>\n");
    exit    (EXIT_FAILURE);
  }
}
