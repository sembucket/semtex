///////////////////////////////////////////////////////////////////////////////
// element.C: 2D spectral element class routines.
//
// Copyright (C) 1994, 1999 Hugh Blackburn
//
// $Id$
///////////////////////////////////////////////////////////////////////////////

#include <Sem.h>


Element::Element (const integer i,
		  const Mesh*   M,
		  const real*   z,
		  const integer n) :
// ---------------------------------------------------------------------------
// Create a new quad element, n x n.  Node spacing along any side
// generated by mapping z (defined on domain [-1, 1], np points) onto
// side.
//
// Compute information for internal storage, and economise.
// ---------------------------------------------------------------------------
  _id   (i),
  _np   (n),
  _npnp (_np * _np),
  _next (4 * (_np - 1)),
  _nint (_npnp - _next)
{
  const char routine[] = "Element::Element";

  if (_np < 2) message (routine, "need > 2 knots for element edges", ERROR);

  Femlib::buildMaps (_np, 2, &_emap, &_pmap);
  
  _xmesh = new real [(size_t) _npnp];
  _ymesh = new real [(size_t) _npnp];
  
  M -> meshElmt (_id, _np, z, _xmesh, _ymesh);
  
  Femlib::adopt (_npnp, &_xmesh);
  Femlib::adopt (_npnp, &_ymesh);
 
  this -> map();
}


Element::~Element ()
// ---------------------------------------------------------------------------
// Clean up internal storage using Femlib family routines.
// ---------------------------------------------------------------------------
{
  Femlib::abandon (&_xmesh);
  Femlib::abandon (&_ymesh);

  Femlib::abandon (&_drdx );
  Femlib::abandon (&_dsdx );
  Femlib::abandon (&_drdy );
  Femlib::abandon (&_dsdy );

  Femlib::abandon (&_G1   );
  Femlib::abandon (&_G2   );
  Femlib::abandon (&_G3   );
  Femlib::abandon (&_G4   );
  Femlib::abandon (&_delta);
}


void Element::map ()
// ---------------------------------------------------------------------------
// Generate geometric factors associated with mapping from 2D Cartesian to
// isoparametrically-mapped space:
//
//   dxdr, dydr, = dx/dr,  dy/dr,  "Forward Partials"
//   dxds, dyds, = dx/ds,  dy/ds.
//   drdx, drdy, = dr/dx,  dr/dy,  "Inverse Partials"
//   dsdx, dsdy, = ds/dx,  ds/dy.
//   jac         = dx/dr * dy/ds - dx/ds * dy/dr.
//
// The following relationships are used, where
//
//   IN[j][k] = h_k (x_j) is a Lagrangian interpolant matrix operator, and
//   DV[j][k] = h'_k(x_j) is a Lagrangian derivative  matrix operator,
//
// [ IT = transpose(IN), DT = transpose(DV) ]:
//
//   [dxdr] = [IN][X][DT];    [dydr] = [IN][Y][DT],
//   [dxds] = [DV][X][IT];    [dyds] = [DV][Y][IT].
//
// For a Gauss--Legendre quadrature rule, the inverse partials and
// mass matrix are returned for spatial locations at the mesh nodes,
// while the forward partials and other geometric factors are for
// spatial locations at the quadrature points.  In general, the amount
// of storage allocated for forward and inverse partials differ.
//
// For Lobatto--Legendre rule, everything is at the nodes, hence the
// interpolant matrices are identities.
// 
// The inverse partials are retained in Element storage, to be used in
// element gradient operations (e.g. dP/dx = dP/dr * dr/dx + dP/ds *
// ds/dx) while the forward partials are retained in scrambled form
// (in combination with quadrature weights) as "geometric factors"
// G1--G4, to be used in element quadrature operations.  For
// cylindrical geometries, G1--G4 are multiplied by y (i.e. r) as a
// consequence of the fact that Helmholtz equations are symmetrized by
// premultiplication by this factor for cylindrical coords.
//
// The local length-scale, delta, is a measure of the size of the
// local mesh length.  There are two options (selected in compilation
// stage) below.
//
// Null-mapping optimizations mentioned below occur when the element
// geometry ensures that the entries of a vector are zero to within
// roundoff, due either to the edges of elements being aligned with
// coordinate axes (as can happen for the inverse partials) or if the
// element is an undistorted (but possibly rotated) rectangle (this
// applies to G3).  In these cases the associated memory is deleted
// and the pointers are set to zero, so they can serve as flags in
// subsequent computations.
// ---------------------------------------------------------------------------
{
  const char   routine[] = "Element::map";
  const real   EPS  = 4 * ((sizeof(real) == sizeof(double)) ? EPSDP : EPSSP);
  const real   dz   = Femlib::value ("TWOPI / (BETA * N_Z)");
  const real   invD = 1.0 / Geometry::nDim();
  const real   *x   = _xmesh, *y = _ymesh;
  const real   **DV, **DT, *w;
  char         err[StrMax];
  real         *jac, *dxdr, *dxds, *dydr, *dyds, *tV, *WW;

  vector<real> work;

  // -- Permanent/family allocations.
  
  _drdx  = new real [(size_t) _npnp];
  _dsdx  = new real [(size_t) _npnp];
  _drdy  = new real [(size_t) _npnp];
  _dsdy  = new real [(size_t) _npnp];
  _G1    = new real [(size_t) _npnp];
  _G2    = new real [(size_t) _npnp];
  _G3    = new real [(size_t) _npnp];
  _G4    = new real [(size_t) _npnp];
  _delta = new real [(size_t) _npnp];
    
  // -- Temporaries.

  work.setSize (7 * _npnp);

  dxdr = work();
  dxds = dxdr + _npnp;
  dydr = dxds + _npnp;
  dyds = dydr + _npnp;

  jac  = dyds + _npnp;
  WW   = jac  + _npnp;
  tV   = WW   + _npnp;
    
  Femlib::quad (LL, _np, _np, 0, 0, &w, 0, 0, &DV, &DT);
  Veclib::zero (_npnp, WW, 1);
  Blas::ger    (_np, _np, 1.0, w, 1, w, 1, WW, _np);
    
  Blas::mxm (  x, _np, *DT, _np, dxdr, _np);
  Blas::mxm (*DV, _np,   x, _np, dxds, _np);
  Blas::mxm (  y, _np, *DT, _np, dydr, _np);
  Blas::mxm (*DV, _np,   y, _np, dyds, _np);
    
  Veclib::vmul  (_npnp,        dxdr, 1, dyds, 1, tV,  1);
  Veclib::vvvtm (_npnp, tV, 1, dxds, 1, dydr, 1, jac, 1);
    
  if (jac[Veclib::imin (_npnp, jac, 1)] < EPS) {
    sprintf (err, "jacobian of element %1d nonpositive", _id + 1);
    message (routine, err, ERROR);
  }
    
  Veclib::vmul  (_npnp, dyds, 1, dyds, 1, tV,  1);
  Veclib::vvtvp (_npnp, dxds, 1, dxds, 1, tV,  1, _G1, 1);
  Veclib::vdiv  (_npnp, _G1,  1, jac,  1, tV,  1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _G1, 1);
    
  Veclib::vmul  (_npnp, dydr, 1, dydr, 1, tV,  1);
  Veclib::vvtvp (_npnp, dxdr, 1, dxdr, 1, tV,  1, _G2, 1);
  Veclib::vdiv  (_npnp, _G2,  1, jac,  1, tV,  1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _G2, 1);
    
  Veclib::vmul  (_npnp, dydr, 1, dyds, 1, tV,    1);
  Veclib::neg   (_npnp, tV,   1);
  Veclib::vvvtm (_npnp, tV,   1, dxdr, 1, dxds,  1, _G3, 1);
  Veclib::vdiv  (_npnp, _G3,  1, jac,  1, tV,    1);
  Veclib::vmul  (_npnp, tV,   1, WW,   1, _G3,   1);
  
  Veclib::vmul  (_npnp, jac,  1, WW,   1, _G4, 1);

  Veclib::copy  (_npnp, dyds, 1, _drdx, 1);
  Veclib::vneg  (_npnp, dxds, 1, _drdy, 1);
  Veclib::vneg  (_npnp, dydr, 1, _dsdx, 1);
  Veclib::copy  (_npnp, dxdr, 1, _dsdy, 1);
    
  Veclib::vdiv  (_npnp, _drdx, 1, jac, 1, _drdx, 1);
  Veclib::vdiv  (_npnp, _drdy, 1, jac, 1, _drdy, 1);
  Veclib::vdiv  (_npnp, _dsdx, 1, jac, 1, _dsdx, 1);
  Veclib::vdiv  (_npnp, _dsdy, 1, jac, 1, _dsdy, 1);

#if 0
  // This is what Eggels uses:
  // The local length-scale, delta, is a measure of the size of the
  // local mesh length: delta = sqrt{(dx^2 + dy^2 + dz^2)/3}
  //                          ~ sqrt{([dr^2 + ds^2]*jac + dz^2)/3)}

  const real dxy = 2.0 * sqr (2.0 / (_np - 1));

  Veclib::smul (_npnp, dxy,  jac, 1, _delta, 1);

  if (Geometry::nDim() == 3) {
    if (Geometry::system() == Geometry::Cylindrical)
      Veclib::smul (_npnp, dz, _ymesh, 1, tV, 1);
    else
      Veclib::fill (_npnp, dz, tV, 1);
    Veclib::vmul (_npnp, tV, 1, tV, 1, tV, 1);
    Veclib::vadd (_npnp, tV, 1, _delta, 1, _delta, 1);
  }
  Blas::scal    (_npnp, invD,      _delta, 1);
  Veclib::vsqrt (_npnp, _delta, 1, _delta, 1);
#else
  // The local length-scale, delta, is a measure of the size of the
  // local mesh: delta = (dx * dy * dz)^1/DIM
  //                   ~ [[2/(np - 1)]^2*jac * dz]^(1/DIM).

  const real dxyz = sqr (2.0 / (_np - 1)) * ((Geometry::nZ()>1) ? dz : 1.0);

  Veclib::smul (_npnp, dxyz, jac, 1, _delta, 1);

  if (Geometry::system() == Geometry::Cylindrical)
    for (register integer i = 0; i < _npnp; i++)
      _delta[i] *= (fabs(_ymesh[i]) < EPS) ? EPS : fabs(_ymesh[i]);

  Veclib::spow (_npnp, invD, _delta, 1, _delta, 1);
#endif

  if (Geometry::system() == Geometry::Cylindrical) {
    Veclib::vmul (_npnp, _G1, 1, y, 1, _G1, 1);
    Veclib::vmul (_npnp, _G2, 1, y, 1, _G2, 1);
    Veclib::vmul (_npnp, _G3, 1, y, 1, _G3, 1);
    Veclib::vmul (_npnp, _G4, 1, y, 1, _G4, 1);
  } 

  // -- Calculations are done.  Do null-mapping optimizations.
  
  if (Blas::nrm2 (_npnp, _drdx, 1) < EPS) { delete [] _drdx; _drdx = 0; }
  if (Blas::nrm2 (_npnp, _drdy, 1) < EPS) { delete [] _drdy; _drdy = 0; }
  if (Blas::nrm2 (_npnp, _dsdx, 1) < EPS) { delete [] _dsdx; _dsdx = 0; }
  if (Blas::nrm2 (_npnp, _dsdy, 1) < EPS) { delete [] _dsdy; _dsdy = 0; }
  if (Blas::nrm2 (_npnp, _G3,   1) < EPS) { delete [] _G3;   _G3   = 0; }

#if defined (DAMPING)
  // -- Van Driest damping.
  //    An ad-hoc modification to mesh length scale to account for wall
  //    effects in LES.  This example is for a pipe flow, radius 0.5.
  Femlib::prepVec
  ("delta x y","delta*sqrt(1-exp(-(75.27*abs(0.5-sqrt(x*x+y*y)))^3))");
  Femlib__parseVec (nTot(), delta, xmesh, ymesh, delta);
#endif

  // -- Check for family redundancies.

  Femlib::adopt (_npnp, &_drdx );
  Femlib::adopt (_npnp, &_drdy );
  Femlib::adopt (_npnp, &_dsdx );
  Femlib::adopt (_npnp, &_dsdy );
  Femlib::adopt (_npnp, &_G1   );
  Femlib::adopt (_npnp, &_G2   );
  Femlib::adopt (_npnp, &_G3   );
  Femlib::adopt (_npnp, &_G4   );
  Femlib::adopt (_npnp, &_delta);
}


void Element::bndryDsSum (const integer* btog,
			  const real*    src ,
			  real*          tgt ) const
// ---------------------------------------------------------------------------
// Direct-stiffness-sum from element boundary to globally-numbered
// storage, i.e. tgt[btog[i]] += mass[emap[i]] * src[emap[i]].  This
// is using in smoothing Fields along element boundaries.
// ---------------------------------------------------------------------------
{
  const integer    loopcnt = _next; // -- Workaround for NEC vectorisation.
  register integer i, e;
  register real    w;
  const real       EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  const int        CYL = Geometry::system() == Geometry::Cylindrical;

  if (CYL)
#if defined(__uxp__)
#pragma loop novrec
#elif defined(_SX)
#pragma vdir nodep
#endif
    for (i = 0; i < loopcnt; i++) {
      e = _emap[i];
      w = _G4  [e];
      tgt[btog[i]] += (w > EPS) ? w * src[e] : src[e];
    }
  else
#if defined(__uxp__)
#pragma loop novrec
#elif defined(_SX)
#pragma vdir nodep
#endif
    for (i = 0; i < loopcnt; i++) {
      e = _emap[i];
      tgt[btog[i]] += _G4[e] * src[e];
    }
}


void Element::bndryMask (const integer* bmsk,
			 real*          tgt ,
			 const real*    src ,
			 const integer* btog) const
// ---------------------------------------------------------------------------
// Mask the values in (row-major) tgt according to the mask vector
// bmsk and optionally globally-numbered vector src.
//
// If src is non-zero, it is used with boundary-to-global mapping
// vector btog to impose values within tgt on locations where bmsk is
// non-zero; other locations are unaffected.
//
// If src is zero, then the values within tgt where bmsk is zero are
// set to zero (i.e. tgt itself is taken as the source).  Btog is then
// not used and may be zero also.
// ---------------------------------------------------------------------------
{
  register integer i, e;
  const integer    loopcnt = _next;

  if (src) {
    for (i = 0; i < _next; i++) {
      e = _emap[i];
      tgt[e] = (bmsk[i]) ? src[btog[i]] : tgt[e];
    }

  } else {
    vector<real>   work (_npnp);
    register real* tmp = work();

    Veclib::gathr (_npnp, tgt, _emap, tmp);
    for (i = 0; i < loopcnt; i++)
      tmp[i] = (bmsk[i]) ? tmp[i] : 0.0;
    Veclib::zero  (_nint, tmp + _next, 1);
    Veclib::gathr (_npnp, tmp, _pmap, tgt);
  }
}


void Element::bndryInsert (const integer* b2g,
			   const real*    src,
			   real*          tgt) const
// ---------------------------------------------------------------------------
// Load values from globally-numbered src around periphery of element
// tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, src, b2g, _emap, tgt);
}

       
void Element::e2g (const real*    src     ,
		   const integer* btog    ,
		   real*          external,
		   real*          internal) const
// ---------------------------------------------------------------------------
// Load values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, src, _emap, btog, external);
  if (internal) Veclib::gathr (_nint, src, _emap + _next, internal);
}


void Element::e2gSum (const real*    src     ,
		      const integer* btog    ,
		      real*          external,
		      real*          internal) const
// ---------------------------------------------------------------------------
// Sum values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr_sum (_next, src, _emap,  btog, external);
  if (internal) Veclib::gathr_sum (_nint, src, _emap + _next, internal);
}


void Element::g2e (real*          tgt,
		   const integer* btog,
		   const real*    external,
		   const real*    internal) const
// ---------------------------------------------------------------------------
// From (globally-numbered) external & internal partitons of vector,
// load into elemnt storage tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (_next, external, btog,  _emap, tgt);
  if (internal) Veclib::scatr (_nint, internal, _emap + _next, tgt);
}


void Element::e2gSumSC (real*          F   ,
			const integer* btog,
			real*          tgt ,
			const real*    hbi ) const
// ---------------------------------------------------------------------------
// Create statically-condensed boundary Helmholtz forcing for this
// element from row-major F and insert it into globally-numbered tgt
// by direct stiffness summation.
//
// NB: forcing, F, is modified.
//
// On entry, F contains the elemental weak boundary-constrained forcing
//   - M f - H g.
//
// Elemental storage is then sorted in F so that it is ordered with boundary
// nodes foremost, i.e. it contains the partition { F | F }.
//                                                   b   i
//
// Statically-condensed boundary forcing is created in the first partition:
//                       -1                         -1
//   F   <--   F  -  h  h   F           (matrix h  h   supplied as hbi)
//    b         b     bi ii  i                   bi ii
//
// and summed into the tgt vector.  In the summation, there is no need
// to check if the global node is to be solved for or is fixed, since
// the fixed (essential-BC) partition of tgt is overwritten later.
//
// NB: scatr_sum is broken for self-periodic elements on vector machines!
// ---------------------------------------------------------------------------
{
  vector<real> work (_npnp);

  Veclib::gathr (_npnp, F, _emap, work());
  Veclib::copy  (_npnp, work(), 1, F, 1);

  if (_nint) Blas::gemv ("T",_nint,_next, -1. ,hbi,_nint,F+_next,1, 1., F,1);

  Veclib::scatr_sum (_next, F, btog, tgt);
}


void Element::g2eSC (const real*    RHS ,
		     const integer* btog,
		     real*          F   , 
		     real*          tgt ,
		     const real*    hbi ,
		     const real*    hii ,
		     real*          work) const
// ---------------------------------------------------------------------------
// Complete static condensation solution for internal values of Element.
//
// On entry, global-node solution values are in RHS and F contains the
// weak form of internal forcing in its top end (as installed by
// e2gSumSC).
//
// If u is current Element, compute internal solution according to:
//            -1      -1
//   u  <--  h  F  - h  h   u
//    i       ii i    ii ib  b
//
// Input vector work has length nTot().  F is overwritten during
// processing.
// ----------------------------------------------------------------------------
{
  // -- Load globally-numbered RHS into element-boundary storage.

  Veclib::gathr (_next, RHS,  btog, work);
  Veclib::scatr (_next, work, _emap, tgt );

  // -- Complete static-condensation solution for element-internal storage.

  if (_nint) {
    real* Fi   = F    + _next;
    real* wint = work + _next;

    Veclib::copy  (_nint, Fi, 1, wint, 1);
    Blas::gemv    ("T", _nint, _nint,  1.0, hii, _nint, wint, 1, 0.0, Fi, 1);
    Blas::gemv    ("N", _nint, _next, -1.0, hbi, _nint, work, 1, 1.0, Fi, 1);
    Veclib::scatr (_nint, Fi, _emap + _next, tgt);
  }
}


void Element::HelmholtzSC (const real lambda2,
			   const real betak2 ,
			   real*      hbb    ,
			   real*      hbi    ,
			   real*      hii    ,
			   real*      rmat   ,
			   real*      rwrk   ,
			   integer*   iwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix and return the
// statically condensed form in hbb, the interior-exterior coupling
// matrix in hbi, and the interior resolution matrix factor in hii.
//
// lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Uncondensed System   -->   Statically condensed form returned in hbb.
//
//                                                           -1
//  +---------+------+       +---------+    +------+  +------+  +---------+
//  |         |      |       |         |    |      |  |      |  |         |
//  |         |      |       |         |    |      |  | hii  |  |   hib   |
//  |   hbb   | hbi  |  -->  |   hbb   | -  | hbi  |  |      |  |         |
//  |         |      |       |         |    |      |  +------+  +---------+
//  |         |      |       |         |    |      |
//  +---------+------+       +---------+    +------+
//  |         |      |
//  |   hib   | hii  |
//  |         |      |
//  +---------+------+
//
// Element matrices are built row-by-row, sorted to place entries for
// internal nodes first, posted into local partitions.  Then the
// internal resolution matrix hii is factorized and the static
// condensation completed.  In addition, the interior-exterior
// partition hbi is postmultiplied by hii(inverse) for convenience in
// the resolution stage.
//
// hbb:    nExt  by nExt    matrix;  (row-major 1D storage).
// hbi:    nExt  by nInt    matrix;  (row-major 1D storage).
// hii:    nInt  by nInt    matrix;  (row-major 1D storage).
// rmat:   nKnot by nKnot   matrix;  (row-major 1D storage).
// rwrk:   nExt*(nExt+nInt) vector.
// iwrk:   nInt             vector.
// ---------------------------------------------------------------------------
{
  const char       routine[] = "Element::HelmholtzSC";
  register integer i, j, eq, info, ij = 0;
  const real       **DV, **DT;

  // -- Construct hbb, hbi, hii partitions of elemental Helmholtz matrix.

  Femlib::quad (LL, _np, _np, 0, 0, 0, 0, 0, &DV, &DT);

  for (i = 0; i < _np; i++)
    for (j = 0; j < _np; j++, ij++) {

      this -> helmRow (DV, DT, lambda2, betak2, i, j, rmat, rwrk);

      Veclib::gathr (_npnp, rmat, _emap, rwrk);

      if ( (eq = _pmap[ij]) < _next ) {
	Veclib::copy (_next, rwrk,         1, hbb + eq * _next, 1);
	Veclib::copy (_nint, rwrk + _next, 1, hbi + eq * _nint, 1);
      } else
	Veclib::copy (_nint, rwrk + _next, 1, hii + (eq - _next) * _nint, 1);
    }

  // -- Static condensation.

  if (_nint) {

    Lapack::getrf (_nint, _nint, hii, _nint, iwrk, info);
    if (info) message (routine, "matrix hii has singular factor", ERROR);

#if defined (DEBUG)
  if ((int) Femlib::value("VERBOSE") > 3) this -> printMatSC (hbb, hbi, hii);
#endif

    Lapack::getri (_nint, hii, _nint, iwrk, rwrk, _nint*_next, info);
    if (info) message (routine, "matrix hii is singular", ERROR);

    Blas::mxm    (hbi, _next, hii, _nint, rwrk, _nint);
    Blas::mxmts  (rwrk, _next, hbi, _nint, hbb, _next);
    Veclib::copy (_nint*_next, rwrk, 1, hbi, 1);
  }
}


void Element::printMatSC (const real* hbb,
			  const real* hbi,
			  const real* hii) const
// ---------------------------------------------------------------------------
// (Debugging) utility to print up element matrices.
// ---------------------------------------------------------------------------
{
  integer i, j;

  cout << "-- Helmholtz matrices, element " << _id << endl;

  cout << "-- hbb:" << endl;

  cout.precision(3);

  for (i = 0; i < _next; i++) {
    for (j = 0; j < _next; j++)
      cout << setw (10) << hbb[Veclib::row_major (i, j, _next)];
    cout << endl;
  }

  cout << "-- hii:" << endl;

  for (i = 0; i < _nint; i++) {
    for (j = 0; j < _nint; j++)
      cout << setw (10) << hii[Veclib::row_major (i, j, _nint)];
    cout << endl;
  }

  cout << "-- hbi:" << endl;

  for (i = 0; i < _next; i++) {
    for (j = 0; j < _nint; j++)
      cout << setw (10) << hbi[Veclib::row_major (i, j, _nint)];
    cout << endl;
  }

  cout.precision(6);
}


void Element::Helmholtz (const real lambda2,
			 const real betak2 ,
			 real*      h      ,
			 real*      rmat   ,
			 real*      rwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix, return in h.
//
// This routine can be used when static condensation is not employed,
// and is included mainly to ease checking of entire element matrices.
// Node ordering produced is row-major.
//
// h:    vector, length np*np*np*np;
// rmat: vector, length np*np;
// ---------------------------------------------------------------------------
{
  const real       **DV, **DT;
  register integer i, j, ij = 0;

  Femlib::quad (LL, _np, _np, 0, 0, 0, 0, 0, &DV, &DT);

  for (i = 0; i < _np; i++)
    for (j = 0; j < _np; j++, ij++) {
      this -> helmRow (DV, DT, lambda2, betak2, i, j, rmat, rwrk);
      Veclib::copy (_npnp, rmat, 1, h + ij * _np, 1);
    }
}


void Element::HelmholtzDg (const real lambda2,
			   const real betak2 ,
			   real*      diag   ,
			   real*      work   ) const
// ---------------------------------------------------------------------------
// Create the diagonal of the elemental Helmholtz matrix in diag.  The
// diagonal is sorted in _emap order: i.e., boundary nodes are first.
//
// Input vector diag must be nTot() long, work must be Ntot() +
// nKnot() long.  Construction is very similar to that in helmRow
// except that m, n = i, j.
// ---------------------------------------------------------------------------
{
  const real       EPS  = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  const int        CYL = Geometry::system() == Geometry::Cylindrical;
  const real**     DT;
  register integer i, j, ij;
  register real    *dg = work, *tmp = work + _npnp;
  real             r2, HCon;

  Femlib::quad (LL, _np, _np, 0, 0, 0, 0, 0, 0, &DT);

  if (CYL) {
    for (ij = 0, i = 0; i < _np; i++)
      for (j = 0; j < _np; j++, ij++) {
	r2   = sqr (_ymesh[Veclib::row_major (i, j, _np)]);
	HCon = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	Veclib::vmul (_np, DT[j], 1, DT[j], 1, tmp, 1);
	dg[ij] = Blas::dot   (_np, _G1 + i*_np, 1, tmp, 1);
	Veclib::vmul (_np, DT[i], 1, DT[i], 1, tmp, 1);
	dg[ij] += Blas::dot   (_np, _G2 + j,   _np, tmp, 1);
	if (_G3)
	  dg[ij] += 2. * _G3[Veclib::row_major (i, j, _np)]*DT[j][j]*DT[i][i];
	dg[ij] += HCon * _G4[Veclib::row_major (i, j, _np)];
      }
  } else {
    HCon = lambda2 + betak2;
    for (ij = 0, i = 0; i < _np; i++)
      for (j = 0; j < _np; j++, ij++) {
	Veclib::vmul (_np, DT[j], 1, DT[j], 1, tmp, 1);
	dg[ij]  = Blas::dot   (_np, _G1 + i*_np, 1, tmp, 1);
	Veclib::vmul (_np, DT[i], 1, DT[i], 1, tmp, 1);
	dg[ij] += Blas::dot   (_np, _G2 + j,   _np, tmp, 1);
	if (_G3)
	  dg[ij] += 2. * _G3[Veclib::row_major (i, j, _np)]*DT[j][j]*DT[i][i];
	dg[ij] += HCon * _G4[Veclib::row_major (i, j, _np)];
      }
  }

  Veclib::gathr (_npnp, work, _emap, diag);
}


void Element::helmRow (const real**  DV     ,
		       const real**  DT     ,
		       const real    lambda2,
		       const real    betak2 ,
		       const integer i      ,
		       const integer j      ,
		       real*         hij    ,
		       real*         work   ) const
// ---------------------------------------------------------------------------
// Build row [i,j] of the elemental Helmholtz matrix in array hij (np x np).
//
// Lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Input array work should be at least np long.
//
// For a 2D tensor product form, the elemental Helmholtz matrix is produced
// as (sums on p & q indices assumed):
//
// h      = G1  IN  DT  IN  DT     \
//  ij mn     pq  pi  jq  pm  nq   |
//        + G2  DV  IT  DV  IT     |
//            pq  pi  jq  pm  nq   |
//        + G3  DV  IT  IN  DT      >                              "STIFFNESS"
//            pq  pi  jq  pm  nq   |
//        + G3  IN  DT  DV  IT     |
//            pq  pi  jq  pm  nq   /
//                
//        + G4  IN  IT  IN  IT        (k2 / sqr (r  ) + lambda2)        "MASS"
//            pq  pi  jq  pm  nq                  pq
//
// where the terms G1, G2, G3, G4 contain geometric mapping factors
// and quadrature weights, and the matrices IN, IT are the Lagrangian
// interpolation matrix (from the nodes to the quadrature points) and
// its transpose, while DV, DT are the Lagrangian derivative matrix &
// transpose.
//
// (The 1/r^2 factor in the mass matrix is only for cylindrical coordinates.)
//
// For Gauss--Lobatto--Legendre integration, the interpolant matrices
// are identities, and are not required.
// ---------------------------------------------------------------------------
{
  const real       r2   = sqr (_ymesh[Veclib::row_major (i, j, _np)]);
  const real       EPS  = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  const real       hCon = (Geometry::system() == Geometry::Cylindrical &&
			r2 > EPS) ? (betak2 / r2 + lambda2) : betak2 + lambda2;
  register integer m, n;

  Veclib::zero (_npnp, hij, 1);

  for (n = 0; n < _np; n++) {
    Veclib::vmul (_np, DT[j], 1, DT[n], 1, work, 1);
    hij[Veclib::row_major (i, n, _np)]  = Blas::dot (_np,_G1+i*_np,1,work,1);
  }

  for (m = 0; m < _np; m++) {
    Veclib::vmul (_np, DT[i], 1, DT[m], 1, work, 1);
    hij[Veclib::row_major (m, j, _np)] += Blas::dot (_np,_G2+j,_np,work,1);
  }

  if (_G3)
    for (m = 0; m < _np; m++)
      for (n = 0; n < _np; n++) {
	hij [Veclib::row_major (m, n, _np)] +=
	  _G3[Veclib::row_major (i, n, _np)] * DV[n][j] * DV[i][m];
	hij [Veclib::row_major (m, n, _np)] +=
	  _G3[Veclib::row_major (m, j, _np)] * DV[j][n] * DV[m][i];
      }

  hij[Veclib::row_major (i, j, _np)] += _G4[Veclib::row_major (i,j,_np)]*hCon;
}


void Element::HelmholtzKern (const real lambda2,
			     const real betak2 ,
			     real*      R      ,
			     real*      S      ,
			     real*      src    ,
			     real*      tgt    ) const 
// ---------------------------------------------------------------------------
// Apply kernel of elemental discrete Helmholtz operator on src to make tgt
// (if required, these can be the same storage locations).
//
// Lambda2 is the Helmholtz constant, betak2 is the mode Fourier constant.
// ---------------------------------------------------------------------------
{
  const integer    loopcnt = _npnp; // -- Workaround for NEC vectorisation.
  register integer ij;
  register real    tmp, r2, hCon;
  register real    *g1 = _G1, *g2 = _G2, *g3 = _G3, *g4 = _G4, *r = _ymesh;
  const real       EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  const int        CYL = Geometry::system() == Geometry::Cylindrical;

  if (CYL) {
    if (g3) {
      for (ij = 0; ij < loopcnt; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < loopcnt; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }

  } else {			// -- Cartesian.
    hCon = betak2 + lambda2;
    if (g3) {
      for (ij = 0; ij < loopcnt; ij++) {
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < loopcnt; ij++) {
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }
  }
}


void Element::grad (real*        tgtA,
		    real*        tgtB,
		    const real** DV  ,
		    const real** DT  ,
		    real*        work) const
// ---------------------------------------------------------------------------
// Operate partial derivative d(tgt)/dxi = d_dr*drdxi + d_ds*dsdxi,
// where the appropriate component of gradient is selected by input
// pointers.  Values are computed at node points.
//
// Work area must be 2*nTot() long.
// ---------------------------------------------------------------------------
{
  real* tmpA = work;
  real* tmpB = tmpA + _npnp;
  real* tgt;

  if ((tgt = tgtA)) {
    if (_drdx && _dsdx) {
      Blas::mxm     (tgt, _np, *DT, _np, tmpA, _np);
      Blas::mxm     (*DV, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdx, 1, tmpA, 1);
      Veclib::vvtvp (_npnp, tmpB, 1, _dsdx, 1, tmpA, 1, tgt, 1);
    } else if (_drdx) {
      Blas::mxm     (tgt, _np, *DT, _np, tmpA, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdx, 1, tgt, 1);
    } else {
      Blas::mxm     (*DV, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpB, 1, _dsdx, 1, tgt, 1);
    }
  }

  if ((tgt = tgtB)) {
    if (_drdy && _dsdy) {
      Blas::mxm     (tgt, _np, *DT, _np, tmpA, _np);
      Blas::mxm     (*DV, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdy, 1, tmpA, 1);
      Veclib::vvtvp (_npnp, tmpB, 1, _dsdy, 1, tmpA, 1, tgt, 1);
    } else if (_drdy) {
      Blas::mxm     (tgt, _np, *DT, _np, tmpA, _np);
      Veclib::vmul  (_npnp, tmpA, 1, _drdy, 1, tgt, 1);
    } else {
      Blas::mxm     (*DV, _np, tgt, _np, tmpB, _np);
      Veclib::vmul  (_npnp, tmpB, 1, _dsdy, 1, tgt, 1);
    }
  }
}


void Element::gradX (const real* xr,
		     const real* xs,
		     real*       dx) const
// ---------------------------------------------------------------------------
// Partial implementation of x-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (_drdx && _dsdx) Veclib::vvtvvtp (_npnp, xr,1,_drdx,1,xs,1,_dsdx,1,dx,1);
  else if (_drdx)     Veclib::vmul    (_npnp, xr,1,_drdx,1,dx,1);
  else                Veclib::vmul    (_npnp, xs,1,_dsdx,1,dx,1);
}


void Element::gradY (const real* yr,
		     const real* ys,
		     real*       dy) const
// ---------------------------------------------------------------------------
// Partial implementation of y-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (_drdy && _dsdy) Veclib::vvtvvtp (_npnp, yr,1,_drdy,1,ys,1,_dsdy,1,dy,1);
  else if (_drdy)     Veclib::vmul    (_npnp, yr,1,_drdy,1,dy,1);
  else                Veclib::vmul    (_npnp, ys,1,_dsdy,1,dy,1);
}


void Element::sideGeom (const integer side,
			real*         x   ,
			real*         y   ,
			real*         nx  ,
			real*         ny  ,
			real*         area) const
// ---------------------------------------------------------------------------
// Generate unit outward normal components and change-of-variable
// Jacobian, area, for use in computation of edge integrals.
//
// We will always use Lobatto-Legendre quadrature for these integrals; 
// however, we need to do some recomputation of local forward partial
// derivatives along edges.
//
// Computed vectors have CCW edge-traverse ordering, i.e. are made to operate
// on vectors obtained from base storage using BLAS-conformant copy.
//
// For cylindrical coordinates the area variable is weighted by y (i.e. r).
// ---------------------------------------------------------------------------
{
  if (side < 0 || side >= 4)
    message ("Element::sideGeom", "illegal side", ERROR);

  register integer low, skip;
  const real       **D, *w;
  real             *xr, *xs, *yr, *ys, *len;
  vector<real>     work (_np + _np);

  Femlib::quad (LL, _np, _np, 0, 0, &w, 0, 0, &D, 0);

  switch (side) {
  case 0: 
    low  = 0;
    skip = 1;
    xr   = work();
    yr   = xr + _np;
        
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (_np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (_np, yr, 1, yr, 1, area, 1, area, 1);

    if   (_dsdx) Veclib::smul (_np, -1.0, _dsdx, skip, nx, 1);
    else         Veclib::zero (_np,                    nx, 1);
    if   (_dsdy) Veclib::smul (_np, -1.0, _dsdy, skip, ny, 1);
    else         Veclib::zero (_np,                    ny, 1);
    
    break;

  case 1: 
    low  = _np - 1;
    skip = _np;
    xs   = work();
    ys   = xs + _np;

    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _xmesh+low, _np, 0.0, xs, 1);
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _ymesh+low, _np, 0.0, ys, 1);
    Veclib::vmul  (_np, xs, 1, xs, 1, area, 1);

    Veclib::vvtvp (_np, ys, 1, ys, 1, area, 1, area, 1);

    if   (_drdx) Veclib::copy (_np, _drdx+low, skip, nx, 1);
    else         Veclib::zero (_np,                  nx, 1);
    if   (_drdy) Veclib::copy (_np, _drdy+low, skip, ny, 1);
    else         Veclib::zero (_np,                  ny, 1);
    
    break;

  case 2:
    low  = _np * (_np - 1);
    skip = -1;
    xr   = work();
    yr   = xr + _np;
    
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
	
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (_np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (_np, yr, 1, yr, 1, area, 1, area, 1);

    if   (_dsdx) Veclib::copy (_np, _dsdx+low, skip, nx, 1);
    else         Veclib::zero (_np,                  nx, 1);
    if   (_dsdy) Veclib::copy (_np, _dsdy+low, skip, ny, 1);
    else         Veclib::zero (_np,                  ny, 1);

    break;

  case 3:
    low  = 0;
    skip = -_np;
    xs   = work();
    ys   = xs + _np;
    
    Veclib::copy  (_np, _xmesh + low, skip, x, 1);
    Veclib::copy  (_np, _ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _xmesh+low, _np, 0.0, xs, 1);
    Blas::gemv    ("T", _np, _np, 1.0, *D, _np, _ymesh+low, _np, 0.0, ys, 1);
    Veclib::vmul  (_np, xs, 1, xs, 1, area, 1);
    Veclib::vvtvp (_np, ys, 1, ys, 1, area, 1, area, 1);

    if   (_drdx) Veclib::smul (_np, -1.0, _drdx, skip, nx, 1);
    else         Veclib::zero (_np,                    nx, 1);
    if   (_drdy) Veclib::smul (_np, -1.0, _drdy, skip, ny, 1);
    else         Veclib::zero (_np,                    ny, 1);

    break;
  }
  
  Veclib::vsqrt  (_np, area, 1, area, 1);
  Veclib::vmul   (_np, area, 1, w,    1, area, 1);
  if (Geometry::system() == Geometry::Cylindrical)
    Veclib::vmul (_np, area, 1, _ymesh+low, skip, area, 1);

  len = work();

  Veclib::vhypot (_np, nx, 1, ny,  1, len, 1);
  Veclib::vdiv   (_np, nx, 1, len, 1, nx,  1);
  Veclib::vdiv   (_np, ny, 1, len, 1, ny,  1);
}


void Element::sideEval (const integer side,
			real*         tgt ,
			const char*   func) const
// ---------------------------------------------------------------------------
// Evaluate function func along side of element, returning in tgt.
//
// The function can use variables "x", "y" & "t" (and any
// floating-point parameters previously set).
// ---------------------------------------------------------------------------
{
  vector<real> work(_np + _np);
  real         *x, *y;

  register  integer estart, skip;
  terminal (side, estart, skip);

  x = work();
  y = x + _np;

  Veclib::copy (_np, _xmesh + estart, skip, x, 1);
  Veclib::copy (_np, _ymesh + estart, skip, y, 1);

  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (_np, x, y, tgt);
}


void Element::sideGrad (const integer side,
			const real*   src ,
			real*         c1  ,
			real*         c2  ) const
// ---------------------------------------------------------------------------
// Using geometric factors for this Element, return the first and
// second component, c1 and/or c2, of grad src (length nTot()) along
// side.
//
// We have to take some special care on sides 2 & 3, where the usual
// skips are negative: we instead use positive skips for formation of
// dc/dr, dc/ds, then a -1 skip when multiplying by dr/dx, ds/dx, etc.
// ---------------------------------------------------------------------------
{
  register integer    d, estart, skip;
  static vector<real> work (_np + _np);
  const real          **DV, **DT;
  real                *ddr, *dds;

  this -> terminal (side, estart, skip);

  ddr = work();
  dds = ddr + _np;

  Femlib::quad (LL, _np, _np, 0, 0, 0, 0, 0, &DV, &DT);

  // -- Make dc/dr, dc/ds along element edge.

  switch (side) {
  case 0:
    d = 1;
    Blas::gemv ("T",_np,_np, 1.0, *DV, _np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N",_np,_np, 1.0, src, _np, *DV + estart, d*skip, 0.0, dds, 1);
    break;
  case 1:
    d = 1;
    Blas::gemv ("T",_np,_np, 1.0, src, _np, *DT + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T",_np,_np, 1.0, *DV, _np, src + estart, d*skip, 0.0, dds, 1);
    break;
  case 2:
    d = -1;
    Blas::gemv ("T",_np,_np, 1.0, *DV, _np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N",_np,_np, 1.0, src, _np, *DV + estart, d*skip, 0.0, dds, 1);
    break;
  case 3:
    d = -1;
    Blas::gemv ("T",_np,_np, 1.0, src, _np, *DT + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T",_np,_np, 1.0, *DV, _np, src + estart, d*skip, 0.0, dds, 1);
    break;
  }

  // -- dc/dx = dc/dr * dr/dx + dc/ds * ds/dx.

  if (c1) {
    if   (_drdx) Veclib::vmul  (_np, ddr, d, _drdx+estart, skip, c1, 1);
    else         Veclib::zero  (_np, c1, 1);
    if   (_dsdx) Veclib::vvtvp (_np, dds, d, _dsdx+estart, skip, c1, 1, c1, 1);
  }
  
  // -- dc/dy = dc/dr * dr/dy + dc/ds * ds/dy.

  if (c2) {
    if   (_drdy) Veclib::vmul  (_np, ddr, d, _drdy+estart, skip, c2, 1);
    else         Veclib::zero  (_np, c2, 1);
    if   (_dsdy) Veclib::vvtvp (_np, dds, d, _dsdy+estart, skip, c2, 1, c2, 1);
  }
}


void Element::sideGet (const integer  side,
		       const real*    src ,
		       real*          tgt ) const
// ---------------------------------------------------------------------------
// Load edge vector tgt with values from internal storage src.
// ---------------------------------------------------------------------------
{
  register integer start, skip;

  this -> terminal (side, start, skip);

  Veclib::copy (_np, src + start, skip, tgt, 1);
}


void Element::evaluate (const char* func,
			real*       tgt ) const
// ---------------------------------------------------------------------------
// Evaluate function over mesh points, store in tgt.  Function can
// explicitly use "x" and "y", for which mesh values are used.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (_npnp, _xmesh, _ymesh, tgt);
}


real Element::integral (const char* func) const
// ---------------------------------------------------------------------------
// Return integral of func over element, using element quadrature
// rule.
// ---------------------------------------------------------------------------
{
  real         intgrl;
  vector<real> tmp (_npnp);

  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (_npnp, _xmesh, _ymesh, tmp());

  Veclib::vmul (_npnp, tmp(), 1, _G4, 1, tmp(), 1);

  intgrl = Veclib::sum (_npnp, tmp(), 1);
  
  return intgrl;
}


real Element::integral (const real* src,
			real*       tmp) const
// ---------------------------------------------------------------------------
// Discrete approximation to the integral of element src vector.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, src, 1, _G4,  1, tmp, 1);
  return Veclib::sum (_npnp, tmp, 1);
}


real Element::area () const
// ---------------------------------------------------------------------------
// Discrete approximation to area of element, using GLL quadrature.
// ---------------------------------------------------------------------------
{ 
  return Veclib::sum (_npnp, _G4, 1);
}


void Element::weight (real* tgt) const
// ---------------------------------------------------------------------------
// Multiply tgt by elemental mass matrix.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, tgt, 1, _G4, 1, tgt, 1);
}


void Element::lengthScale (real* tgt) const
// ---------------------------------------------------------------------------
// Load tgt with information about local elemental length scale.
// ---------------------------------------------------------------------------
{
  Veclib::copy (_npnp, _delta, 1, tgt, 1);
}


real Element::norm_inf (const real* src) const
// ---------------------------------------------------------------------------
// Return infinity-norm of element value.
// ---------------------------------------------------------------------------
{
  return fabs (src[Blas::iamax (_npnp, src, 1)]);
}


real Element::norm_L2 (const real* src) const
// ---------------------------------------------------------------------------
// Return L2-norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register integer i;
  register real    L2 = 0.0;
  register real*   dA = _G4;

  for (i = 0; i < _npnp; i++) L2 += src[i] * src[i] * dA[i];

  return sqrt (L2);
}


real Element::norm_H1 (const real* src) const
// ---------------------------------------------------------------------------
// Return Sobolev-1 norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register real    H1 = 0;
  register integer i;
  vector<real>     work (3 * _npnp);
  register real    *dA = _G4, *u = work(), *gw = u + _npnp;
  const real       **DV, **DT;

  Femlib::quad (LL, _np, _np, 0, 0, 0, 0, 0, &DV, &DT);

  // -- Add in L2 norm of u.

  for (i = 0; i < _npnp; i++) H1 += src[i] * src[i] * dA[i];

  // -- Add in L2 norm of grad u.

  Veclib::copy (_npnp, src, 1, u, 1);
  this -> grad (u, 0, DV, DT, gw);
  for (i = 0; i < _npnp; i++) H1 += u[i] * u[i] * dA[i];

  Veclib::copy (_npnp, src, 1, u, 1);
  this -> grad (0, u, DV, DT, gw);
  for (i = 0; i < _npnp; i++) H1 += u[i] * u[i] * dA[i];

  return sqrt (H1);
}


void Element::divR (real* src) const
// ---------------------------------------------------------------------------
// Divide src by y (i.e. r in cylindrical coordinates), take special
// action where r = 0.  This is used in taking theta component of
// gradient.
// ---------------------------------------------------------------------------
{
  const integer    loopcnt = _npnp; // -- Workaround for NEC vectorisation.
  register integer i;
  register real    rad, rinv;
  register real*   y   = _ymesh;
  const real       EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  for (i = 0; i < loopcnt; i++) {
    rad     = y[i];
    rinv    = (rad > EPS) ? 1.0 / rad : 0.0;
    src[i] *= rinv;
  }
}


void Element::mulR (real* src) const
// ---------------------------------------------------------------------------
// Multiply src by y (i.e. r in cylindrical coordinates).
// ---------------------------------------------------------------------------
{
  Veclib::vmul (_npnp, src, 1, _ymesh, 1, src, 1);
}


void Element::sideGetR (const integer side,
			real*         tgt ) const
// ---------------------------------------------------------------------------
// Load r (i.e. y) values for side into tgt.
// ---------------------------------------------------------------------------
{
  register integer estart, skip;

  this -> terminal (side, estart, skip);

  Veclib::copy (_np, _ymesh + estart, skip, tgt, 1);
}


void Element::sideDivR (const integer side,
			const real*   src ,
			real*         tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y (i.e. r), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  integer       i, base,  skip;
  real          r, rinv,  *y;
  const real    *s;
  const integer loopcnt = _np;
  const real    EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = _ymesh;
    s    = src;
    break;
  case 1:
    base = _np - 1;
    skip = _np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 2:
    base = _np * _np - 1;
    skip = -1;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 3:
    base = _np * (_np - 1);
    skip = -_np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  }

  for (i = 0; i < loopcnt; i++) {
    r      = y[i*skip];
    rinv   = (r > EPS) ? 1.0 / r : 0.0;
    tgt[i] = rinv * s[i*skip];
  }
}


void Element::sideDivR2 (const integer side,
			 const real*   src ,
			 real*         tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y^2 (i.e. r^2), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  register integer    i, base, skip;
  register real       r, rinv2, *y;
  register const real *s;
  const integer       loopcnt = _np;
  const real          EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = _ymesh;
    s    = src;
    break;
  case 1:
    base = _np - 1;
    skip = _np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 2:
    base = _np * _np - 1;
    skip = -1;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  case 3:
    base = _np * (_np - 1);
    skip = -_np;
    y    = _ymesh + base;
    s    = src    + base;
    break;
  }

  for (i = 0; i < loopcnt; i++) {
    r      = y[i*skip];
    rinv2  = (r > EPS) ? 1.0 / sqr(r) : 0.0;
    tgt[i] = rinv2 * s[i*skip];
  }
}


integer Element::locate (const real    x    ,
			 const real    y    ,
			 real&         r    ,
			 real&         s     ,
			 const integer guess) const
// ---------------------------------------------------------------------------
// If x & y fall in this element, compute the corresponding r & s
// values, and return 1.  Otherwise return 0.
//
// If guess = 0 (the default argument), the input value of (r, s) is used
// as an initial guess for N--R iteration.  Otherwise the  (r, s) value that
// corresponds to the closest point in the Element mesh to (x, y) is used.
// Point tolerances can be changed by setting token TOL_POS.
// ---------------------------------------------------------------------------
{
  static real         EPS    = 0.0;
  const integer       MaxItn = 8;
  const real          DIVERG = 20.0;
  real                *J, *F, *ir, *is, *dr, *ds, *tp;
  static vector<real> work (5 * _np + 6);
  integer             ipiv[2], info, i, j;
  
  tp = work();
  ir = tp + _np;
  is = ir + _np;
  dr = is + _np;
  ds = dr + _np;
  J  = ds + _np;
  F  = J  + 4;

  if (EPS == 0.0) EPS = Femlib::value ("TOL_POS");

  if (guess) {
    vector<real> tmp (2 * _npnp);
    const real*  knot;
    real         *tx = tmp(), *ty = tmp() + _npnp;

    const real diag =
      max (hypot(_xmesh[_np*_np-1]  -_xmesh[0],
		 _ymesh[_np*_np-1]  -_ymesh[0])   ,
	   hypot(_xmesh[_np*(_np-1)]-_xmesh[_np-1],
		 _ymesh[_np*(_np-1)]-_ymesh[_np-1]));

    Femlib::quad     (LL, _np, _np, &knot, 0, 0, 0, 0, 0, 0);
    Veclib::ssub     (_npnp, x, _xmesh, 1, tx, 1);
    Veclib::ssub     (_npnp, y, _ymesh, 1, ty, 1);
    Veclib::vvtvvtp  (_npnp, tx, 1, tx, 1, ty, 1, ty, 1, tx, 1);
    
    i = Veclib::imin (_npnp, tx, 1);

    if (tx[i] - diag * diag > 0.0) return 0;

    j = i % _np;
    i = (i - j) / _np;

    r = knot[i];
    s = knot[j];
    
    if      (r >  0.99) r =  0.99;
    else if (r < -0.99) r = -0.99;
    if      (s >  0.99) s =  0.99;
    else if (s < -0.99) s = -0.99;
  }

  i = 0;
  do {
    Femlib::interp (LL, _np, r, s, ir, is, dr, ds);

               Blas::mxv (_xmesh, _np, ir, _np, tp);
    F[0] = x - Blas::dot (_np, is, 1, tp, 1);
    J[2] =     Blas::dot (_np, ds, 1, tp, 1);
               Blas::mxv (_ymesh, _np, ir, _np, tp);
    F[1] = y - Blas::dot (_np, is, 1, tp, 1);
    J[3] =     Blas::dot (_np, ds, 1, tp, 1);
               Blas::mxv (_xmesh, _np, dr, _np, tp);
    J[0] =     Blas::dot (_np, is, 1, tp, 1);
               Blas::mxv (_ymesh, _np, dr, _np, tp);
    J[1] =     Blas::dot (_np, is, 1, tp, 1);
    
    Lapack::gesv (2, 1, J, 2, ipiv, F, 2, info);
    
    r += F[0];
    s += F[1];

    if (fabs (r) > DIVERG || fabs (s) > DIVERG) {
#if defined (DEBUG)
      if ((int) Femlib::value("VERBOSE") > 3) cerr << "D" << endl;
#endif
      return 0;
    }

  } while (++i < MaxItn && (fabs (F[0]) > EPS || fabs (F[1]) > EPS));

#if defined (DEBUG)
  if ((int) Femlib::value("VERBOSE") > 3) {
    if (i == MaxItn) cerr << "M" << endl;
    else if (fabs (r) > 1.0 + EPS && fabs(s) > 1.0 + EPS) cerr << "O" << endl;
  }
#endif

  return (i < MaxItn && fabs (r) < 1.0 + EPS && fabs(s) < 1.0 + EPS) ? 1 : 0;
}


real Element::probe (const real  r  ,
		     const real  s  ,
		     const real* src) const
// ---------------------------------------------------------------------------
// Return the value of field storage located at r, s, in this element.
// ---------------------------------------------------------------------------
{
  real               *ir, *is, *tp;
  static vector<real> work (3 * _np);

  ir = work();
  is = ir + _np;
  tp = is + _np;

  Femlib::interp   (LL, _np, r, s, ir, is, 0, 0);
  Blas::mxv        (src, _np, ir, _np, tp);
  return Blas::dot (_np, is, 1, tp, 1);
}


real Element::CFL (const real  d,
		   const real* u,
		   const real* v) const
// ---------------------------------------------------------------------------
// Return estimate of local inverse timescale for CFL stability
// condition, for either the x or y velocity component, selected by
// input pointer.
//
//   CFL_x = max (|u| / dx),
//   CFL_y = max (|v| / dy),
//
// where dx or dy are estimated from local element geometric
// information:
//
//   dx = (dx/dr + dx/ds) * d,
//   dy = (dy/dr + dy/ds) * d,
//
// and d is a mesh spacing in canonical coordinates, estimated as the
// minimum to be conservative (and supplied as input).
//
// The local CFL number is then D_T * CFL
// ---------------------------------------------------------------------------
{
  const integer    loopcnt = _npnp;
  register integer i;
  vector<real>     work (_npnp);
  register real*   tmp = work();

  Veclib::zero (loopcnt, tmp, 1);

  if        (u) {
    if (_drdx) for (i = 0; i < loopcnt; i++) tmp[i] += d * fabs (_drdx[i]);
    if (_dsdx) for (i = 0; i < loopcnt; i++) tmp[i] += d * fabs (_dsdx[i]);
    Veclib::vdiv (loopcnt, u, 1, tmp, 1, tmp, 1);
  } else if (v) {
    if (_drdy) for (i = 0; i < loopcnt; i++) tmp[i] += d * fabs (_drdy[i]);
    if (_dsdy) for (i = 0; i < loopcnt; i++) tmp[i] += d * fabs (_dsdy[i]);
    Veclib::vdiv (loopcnt, v, 1, tmp, 1, tmp, 1);
  }

  i = Blas::iamax (loopcnt, tmp, 1);
  return fabs (tmp[i]);
}


