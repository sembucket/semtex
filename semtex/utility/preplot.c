/* This is source code freely distributed by AMTEC Inc, suppliers of Tecplot.
 *
 * NB: it is *NOT* part of Semtex and is covered by different
 * distribution restrictions. Please see the AMTEC website.
 *
 * This seems to work on many UNIX compilations:
 *
 * cc preplot.c -DIRIS -o preplot
 */

/*


USAGE:
-----------------------------------------------------------------------
This source code, in part or whole may be used without permission
from AMTEC ENGINEERING.  Modification is encouraged however we
do ask that you report any changes to Byron 206-827-3304 so that
the master copy can be updated.
-----------------------------------------------------------------------


SYNTAX:
-----------------------------------------------------------------------
The command line syntax can be generated by typing:

  preplot <Cr>
-----------------------------------------------------------------------


BINARY FILE FORMAT:
-----------------------------------------------------------------------
The binary file format is fully described at the bottom of this 
source code.
-----------------------------------------------------------------------


COMPILING:
-----------------------------------------------------------------------
 Preplot was originally developed in PASCAL and then later converted
 to C.  To compile preplot use one of the following commands:

For UNIX, et.al.:
 cc preplot.c -DAPOLLO -o preplot
 cc preplot.c -DCONVEX -lm -o preplot      (added by kwe/NASA Langley)
 cc preplot.c -DCRAY   /usr/local/lib/libbinconv.a -o preplot
 cc preplot.c -DCRAYB  -l /usr/local/lib/libieee.a -o preplot
 cc preplot.c -DCRAYB  -o preplot
 cc preplot.c -DENCORE -o preplot
 cc preplot.c -DIRIS -o preplot
 cc preplot.c -DIRIS3000 -o preplot
 cc preplot.c -DSUN -o preplot
 cc preplot.c -DSTARDENT -43 -o preplot
 cc preplot.c -DDEC -o preplot
 cc preplot.c -DDECALPHA -o preplot
 cc preplot.c -DHP -o preplot
 cc preplot.c -DMASSCOMP -o preplot
 cc preplot.c -DIBM6K -o preplot
 cc preplot.c -DINTER -o preplot

NOTES: For Iris Workstations you may have to include the -cckr flag.
       For Crays:  If Unicos is later than 6.0 then you probably 
       can use -DCRAYB and you do not have to specify -l
       /usr/local/lib/libieee.a
    

For DOS:
 cl /AL /DDOS /DMicrosoftC preplot.c (Microsoft C)
 qcl /AL /DDOS /DMicrosoftC preplot.c (Quick C)

For VMS 
 cc /G_FLOAT /DEFINE=("CC$mixed_float",VMS) preplot.c
 link preplot.opt/opt

Also add the -DPLOT3D flag if you want the capability to read
plot3d files.
If you have some other "generic" unix system then most likely
the ENCORE or IRIS versions of the compile command should 
work.  If you still have problems then you may have to
do some customizing yourself (In which case please let me know
what you came up with..... 206-827-3304 (ask for byron).

MACHINE SPECIFIC NOTES:

CRAY:
The CRAY version only compiles on machines that have the libbinconv.a
library.  navier on NAS currently is one that does.

CONVEX:
Some implimentations do not have the library function dcvtid for 
converting floating point numbers to ieee format but instead provide
the -fi flag on the cc compiler which makes all floating point 
operations use ieee format.  If dcvtid is not avialable then comment
out appropriate lines int the WriteR subroutine to remove CONVEX
specific coding.
-----------------------------------------------------------------------

HISTORY:
-----------------------------------------------------------------------
Version:  1.0 ; original format,        NO LONGER SUPPORTED;
Version:  3.0 ; new format, BLOCK MODE, NO LONGER SUPPORTED;
Version:  3.1 ; new format, POINT MODE, NO LONGER SUPPORTED;
Version:  4.0 ; user specified BLOCK,POINT
Version:  4.1 ; added Font type to text
Version:  4.2 ; added geometry type to geoms
                and removed old solid points
                stuff.
Version:  4.2b  Added capability for PLOT3D 
                input format input files.
--------------------------------------------------------------
Version:  4.3   Removed character width                1/11/89
--------------------------------------------------------------
Version:  4.3b  Fixed line length problem.
                Fixed Typo for bad text header         1/19/89
                error message.
                Added code to generate error           1/20/89
                message for lines that are too
                long.
--------------------------------------------------------------
Version:  4.3c  Changed group stuff to be Scope        1/23/89
                where scope = (GLOBAL,LOCAL)
--------------------------------------------------------------
Version:  4.3d  Increased line length to 1023          3/05/89
--------------------------------------------------------------
Version:  4.3e  Increased max num zones and vars       4/24/89
--------------------------------------------------------------
Version:  4.3f  Fixed problem with text and geom scope
                Also fixed problem with text font type 4/26/89
--------------------------------------------------------------
Version:  4.3g  Increased maxnumzones and maxnumvars to
                500,100                                6/6/89
--------------------------------------------------------------
Version:  4.3h  Added tab character as separator       6/20/89
--------------------------------------------------------------
Version:  4.3i  Added real PLOT3D code                 6/29/89
--------------------------------------------------------------
Version:  4.3j  Added CRAY coding                      7/10/89
--------------------------------------------------------------
Version:  4.3k  fixed filter for FORTRAN block markers
                on CRAY version                        7/11/89
--------------------------------------------------------------
Version:  4.3l  More fixes on CRAY version and also on
                PLOT3D coding for all versions.        7/14/89
--------------------------------------------------------------
Version:  4.3m  Added skipping capability for 
                i,j,klists (Plot3d)                    7/19/89
--------------------------------------------------------------
Version   4.3n  Code added by kwe/NASA Langley for use
                on CONVEX                            
               -General house cleaning.  Added more 
                error checking to command line parsing.
               -Also added ability to use repeat factors
                in input file.  These typically appear
                in free-formated or namelist output from 
                CRAY FORTRAN.  
               -Added in corrections from kwe for CONVEX
                version.                               7/19/89
--------------------------------------------------------------
Version:  4.3o -Fixed error message for EOF condition  8/2/89
--------------------------------------------------------------
Version:  4.3p -Added error checking for max number of
                geometry segments.                     8/3/89
--------------------------------------------------------------
               -Added capability to insert comment 
                lines by placing a # in column 1       8/17/89
               -Changed routine that parses Integer
                values to allow range of 4-byte integer
                on workstations.                       9/19/89
               -Added capability to have dashdot and
                dotted geometries (mostly to make 
                consistant with users manual).         9/20/89
--------------------------------------------------------------
Version: 4.3q
--------------------------------------------------------------
               -Added capability to automatically insert
                an X variable that is a counter when only
                one variable is supplied.              10/2/89
--------------------------------------------------------------
Version: 4.3r
--------------------------------------------------------------
               -Fixed problem with geometry line type. 10/6/89
               -Fixed debug output for color.          10/6/89
--------------------------------------------------------------
Version: 4.4a
--------------------------------------------------------------
               -Changed restriction on geometry boxes
                to require 5 points.                   10/20/89
               -Added 3d geometries and FEBLOCK and 
                FEPOINT ZONE format types.             1/17/90
--------------------------------------------------------------
Version: 4.5                                           1/29/90
--------------------------------------------------------------
               -Added index limits.                    3/21/90
               -capability to read in just the grid
                file for Plot3D                        3/21/90
--------------------------------------------------------------
Version: 4.5b                                          3/22/90
--------------------------------------------------------------
               -Small fix for IRIS version where using
                iset and jset flags would sometimes
                not parse the command line correctly.  4/13/90
--------------------------------------------------------------
Version: 4.5c                                          4/13/90
--------------------------------------------------------------
               -Fixed finite element input.  (Adding
                index limits introduced a bug for FE
                data).                                 5/03/90
--------------------------------------------------------------
Version: 4.5d                                          5/03/90
--------------------------------------------------------------
               -Added -fe flag to allow reading of
                old finite element data format.        5/21/90
--------------------------------------------------------------
Version: 4.5e                                          5/03/90
--------------------------------------------------------------
               -Changed the way ip, jp, and kp sets
                are input.                             6/14/90
--------------------------------------------------------------
Version: 4.5f                                          6/14/90
--------------------------------------------------------------
               -Fixed bug in code that reads in PLOT3D
                files in ASCII format.  Also added
                capability to allow PLOT3D ascii files
                to contain repeat factors.             6/19/90
--------------------------------------------------------------
Version: 4.5g                                          6/19/90
--------------------------------------------------------------
               -Removed restriction that only one of
                -ip, -jp, or -kp flags be used at a
                time for PLOT3D input.                 6/20/90
--------------------------------------------------------------
Version: 4.5h                                          6/20/90
--------------------------------------------------------------
               -Increased limit on IMax to be 2000000000.
                (used to be 99999).                    9/26/90
--------------------------------------------------------------
Version: 4.5i                                          9/26/90
--------------------------------------------------------------
               -Added extra error checking to check for
                valid ascii representation of floating
                point numbers.                        10/17/90
--------------------------------------------------------------
Version: 4.5j                                         10/17/90
--------------------------------------------------------------
               -Added code to be able to compile on new
                UNICOS for CRAY's
--------------------------------------------------------------
Version: 4.5k                                         10/31/90
--------------------------------------------------------------
               - Added flag to zone header to be able
                 to duplicate variables.              11/6/90
--------------------------------------------------------------
Version: 4.6a                                         11/6/90 
--------------------------------------------------------------
               - Fixed limits on plot3d input files to
                 be able to handel i,j, or k indicies 
                 greater than 256.                    11/7/90
--------------------------------------------------------------
Version: 4.6b                                         11/7/90 
--------------------------------------------------------------
               - Added Zone parameter to text and
                 geometries.                          12/28/90
--------------------------------------------------------------
Version: 4.7a                                         12/28/90
--------------------------------------------------------------
               - Added capability to preplot to specify
                 - as input file.  In this case standard
                 in is used.  - for the output file will
                 write to standard out (or if the output
                 filename is missing and - is used for
                 the input filename).                 01/04/91
               - Added code to make filename for 
                 temporary scratch file be random so
                 multiple preplots can be launched at
                 one time.                            01/10/91
--------------------------------------------------------------
Version: 4.7b                                         12/28/90
--------------------------------------------------------------
               - Changed shorts and ints to LgIndex   01/29/91
--------------------------------------------------------------
Version: 4.7c                                         12/28/91
--------------------------------------------------------------
               - Fixed bug with filename length in 
                 DOS                                  03/28/91
--------------------------------------------------------------
Version: 4.7d                                         12/28/91
--------------------------------------------------------------
               - Added error checking for FE data
                 index values.                        04/05/91
               - Fixed restriction with number of 
                 segments allowed in 3d geometries.   04/17/91
--------------------------------------------------------------
Version: 5.0a                                         08/07/91
--------------------------------------------------------------
               - Fixed up circle and ellipse format
                 Still will parse BOX and BOXFILLED
                 types but convert them to RECTANGLE.
--------------------------------------------------------------
Version: 5.0b                                         09/15/91
--------------------------------------------------------------
               - Fixes to text record.               
               - Check added to GetToken to check for a minus
                 sign all by itself.
               - Added capability to input point format
                 data with no header where preplot counts up the
                 number of values on the first line to determine
                 number of variables.
               - Added capability to read PLOT3D files that contain
                 IBlank variable.
--------------------------------------------------------------
Version: 5.0c                                         11/02/91
--------------------------------------------------------------
               - Fixed auto calculation of Number of variables for files
                 That start with a Zone Record.
--------------------------------------------------------------
Version: 5.0d                                         11/13/91
--------------------------------------------------------------
               - Fixed problem with reading numbers that start with
                 "-.".  This problem was introduced in version
                 5.0a.
               - Fixed problem with parsing numbers of the form
                 nenn.
--------------------------------------------------------------
Version: 5.0e                                         01/23/92
--------------------------------------------------------------
               - Added capability to write out FE datasets
                 on CRAY's.  (CRAYB type only).
               - Added capability to escape out special characters
                 in strings.  Use \ to do this.  \\ makes \
                 \" makes " ....
               - Added code so that plain CRAY form can write
                 out FE datasets.
--------------------------------------------------------------
Version: 5.0f                                         04/12/92
--------------------------------------------------------------
               - Added K dimension.
--------------------------------------------------------------
Version: 6.0a                                         09/04/91
--------------------------------------------------------------
               - Added capability to input point format
                 data with no header where preplot counts up the
                 number of values on the first line to determine
                 number of variables.
               - Added additional flags for FE data.
                 n = #  ..... Number of data points.  (Can still use 
                              old format i=#).
                                 
                 e = #  ..... Number of elements.  (Can still use
                              old format j=#).

                 et = (Triangle,Quadrilateral,Tetrahedron,Brick)
                              Element Type.  Default is Quadrilateral.
               - Fixed problem with parsing numbers of the form
                 nenn.
               - Fixed problem with FECONNECT.
--------------------------------------------------------------
Version: 6.1                                          06/03/92
--------------------------------------------------------------
--------------------------------------------------------------
Version: 6.2 .... Orphan version
--------------------------------------------------------------
               - Increased length of variable and zone names.
               - strings now are null terminated instead of
                 fixed lengths.
--------------------------------------------------------------
Version: 6.3                                          07/28/92
--------------------------------------------------------------
               - removed trailing blanks from strings.
               - added code so preplot exits properly if
                 unable to read input file.
--------------------------------------------------------------
Version: 6.3b                                         09/02/92
--------------------------------------------------------------
               - Renamed axislabels to be "CUSTOMLABELS"
               - Changed syntax for CUSTOMLABELS to not require
                 use of the =.  i.e.
                 old:    CUSTOMLABLES = l1,l2,l3 ....
                 new:    CUSTOMLABLES l1,l2,l3 ....
                 Preplot will let you use the = if you want.
               - Added capability to omit E= for FE data.
               - Increased filename size to 32 characters.
--------------------------------------------------------------
Version: 6.3c                                         01/19/93
--------------------------------------------------------------
               - Fixed problem with K Index in point format.
               - Added error message limit. (50)
--------------------------------------------------------------
Version: 6.3d                                         03/19/93
--------------------------------------------------------------
               - Added WarnMsg routine.  Changed so that there
                 is a warning limit and then warnings are no longer
                 issued.  There now is no error limit --- preplot
                 stops at the first error.
--------------------------------------------------------------
Version: 6.3e                                         05/11/93
--------------------------------------------------------------
               - Changed error conditions to always call
                 CleanUp to clean up temp files befor exiting.

               
                 



-----------------------------------------------------------------------

END OF HEADER COMMENTS ....
*/

#define VersionString "PREPLOT V6.3e, (05/11/93)  Copyright (C) Amtec Engineering 1987-1993,\n"

#include <stdio.h>
#include <math.h>

#if defined CRAYB
#define CRAY
#endif


#if defined CRAY
#define   FloatSize        8
#define   DOUBLE           float
#endif /* CRAY */

#ifndef CRAY
#if defined CONVEX
#define   FloatSize        8
#else
#define   FloatSize        4
#endif
#define   DOUBLE           double
#endif

#if defined HP || defined IBM6K || defined INTER
#define IRIS
#endif


#if defined (VMS)
#define DEC
#include <stdlib.h>
#include <unixlib.h>
#define unlink remove

/* * patch for broken "CC$mixed_float" in VMS * */
#if defined(CC$mixed_float) && defined(CC$gfloat) && !defined(vsprintf)
#define vsprintf vaxc$gvsprintf
#define vprintf vaxc$gvprintf
#define vfprintf vaxc$gvfprintf
#define sprintf vaxc$gsprintf
#define printf vaxc$gprintf
#define fprintf vaxc$gfprintf
#define sscanf vaxc$gsscanf
#define scanf vaxc$gscanf
#define fscanf vaxc$gfscanf
#endif

#endif /* VMS */


#if defined (IRIS3000)
#define IRIS
#endif

#if defined (STARDENT)
#define SUN
#endif

#if defined (DECALPHA)
#define DEC
#endif


#if defined ENCORE || defined IRIS || defined SUN || defined DEC || defined MASSCOMP || defined CRAY
#include <string.h>
#include <ctype.h>
#define  MaxCharsFileName   32
#endif
#if defined DOS
#include "ctype.h"
#define  MaxCharsFileName   12
#endif
#if defined APOLLO || defined CONVEX
#include <strings.h>
#include <ctype.h>
#define  MaxCharsFileName   32
#endif

#define   MaxCharsBaseName   (MaxCharsFileName-4)
#define   NumChrsVarName   32
#define   NumChrsZoneName  32
#define   MaxLineIndex     4023
#define   MaxNumVars       100 
#define   MaxNumZones      5000
#define   MaxGeometryPts   6000
#define   MaxGeomSegments  25
#define   MaxCustomLabels  30
#define   FALSE            0
#define   TRUE             1
#define   Boolean          int
#define   IJKSetSize       64
#define   LargestIndex     2000000000

#define   abs(x)           (x>=0 ? x : -(x))

#define ZONEMARKER         (float)299.0
#define GEOMMARKER         (float)399.0
#define TEXTMARKER         (float)499.0
#define CUSTOMLABELMARKER  (float)599.0
#define EOHMARKER          (float)357.0

typedef enum GridModeType {GRID,WINDOW}                 CoordModeType;
typedef enum ScopeType    {GLOBAL,LOCAL}                ScopeType;
typedef enum ElementType  {TRIANGLE,QUADRILATERAL,
                           TETRAHEDRON,BRICK,
                           BADELEMENT = 99}            ElementType;
typedef enum LineType     {SOLID,
                           DASHED,
                           DASHDOT,
                           DOTTED,
                           LONGDASH,
                           DASHDOTDOT}                  LineType;
typedef enum GeometryType {LINE,
                           RECTANGLE,
                           CIRCLE,
                           ELLIPSE,
                           LINE3D }                     GeometryType;
typedef enum FormatType   {BLOCK,POINT,FEBLOCK,FEPOINT} FormatType;
typedef enum Tokens       {NullToken,
                           TITLEToken,
                           VARIABLESToken,
                           ZONEToken,
                           GEOMETRYToken,
                           CUSTOMLABELToken,
                           TEXTToken,
                           IdentToken,
                           StringToken,
                           ValueToken,
                           EqualsToken,
                           LeftParenToken,
                           RightParenToken,
                           EndofFileToken,
                           DupConnectToken,
                           UnknownToken}              Tokens;
#if defined PLOT3D
typedef enum Plot3DModeEnum {MODE_Unknown,
                             MODE_1D,
                             MODE_2D,
                             MODE_3DW,
                             MODE_3DP}                Plot3DModeEnum;
#endif


typedef char               LStringType[150];
typedef char               SStringType[21];
typedef char              *StringPtr;
#if defined DECALPHA
  typedef unsigned int  uint32;
  typedef int           LgIndex;
#else
  typedef unsigned long int  uint32;
  typedef long int           LgIndex;
#endif

float              InputVersion = 6.3;
LgIndex            LineNumber;
int                NumWarns;
CoordModeType      Mode;
LineType           LineMode;
GeometryType       GeomType;
FormatType         Format;
FormatType         OldFormat;
ElementType        Element = BADELEMENT;
ElementType        OldElement;
int                NumDupVars;
Boolean            DupVars[MaxNumVars+1];
float              ZoneColor;
float              Color;
float              FillColor;
float              IsFilled;
float              BoxMargin;
float              BoxFillColor;
float              BoxOutlineColor;
float              BoxType;
float              Font;
float              TGZone;
int                TextLength;
StringPtr          CustomLabel[MaxCustomLabels];
int                NumCustomLabels;
float              Angle;
ScopeType          Scope;
float              Height;
LgIndex            IMax,JMax,KMax;
LgIndex            OldIMax,OldJMax,OldKMax;
LgIndex            RepeatLength = 0;
float              RepeatValue;
LStringType        CurData;
int                LinePos;
int                LineLen;
char               Line[MaxLineIndex+1];
Tokens             CurToken;
float              CurTValue;
LStringType        HeaderString;
Boolean            IsOk;
Boolean            EndOfHeader;
Boolean            Done;
float              YGeometryValues[MaxGeometryPts];
float              ZGeometryValues[MaxGeometryPts];
char               BlckFName[40];
char               PlotFileName[150];
FILE              *BlckFile;
FILE              *PlotFile;
FILE              *InFile;
int                Z;
char               VarName[MaxNumVars][NumChrsVarName+1];
char               ZoneName[MaxNumZones][NumChrsZoneName+1];
int                NumVars;
Boolean            InsertVar = FALSE;
float              ZPlane;
float              XX,YY,ZZ;
float              ZZZ;
Boolean            Echo;
Boolean            ReverseBytes;
Boolean            DupConnect;
Boolean            ConvertFromPolar;
Boolean            ConvertFromSpherical;
Boolean            OldFEMFormat;
Boolean            ConvertSpherical;
Boolean            ConvertPolar;
char               Title[81];
LgIndex            Index;
LgIndex            IStart[MaxNumZones+1];
LgIndex            IEnd[MaxNumZones+1];
LgIndex            ISkip[MaxNumZones+1];
LgIndex            JStart[MaxNumZones+1];
LgIndex            JEnd[MaxNumZones+1];
LgIndex            JSkip[MaxNumZones+1];
LgIndex            KStart[MaxNumZones+1];
LgIndex            KEnd[MaxNumZones+1];
LgIndex            KSkip[MaxNumZones+1];

#if defined PLOT3D
FILE              *InFile_q;
float             *Plot3DVarArray[8];
LgIndex            Plot3DVarArrayCurIndex[8];
LgIndex            Plot3DGridBase[MaxNumZones];
Boolean            InputIsPlot3D;
Boolean            Plot3DInputIsGridOnly;
Boolean            Plot3DInputIsBinary;
Boolean            Plot3DIsMultiGrid;
short              Plot3DHasIBlank;
Boolean            Plot3DInputHasRecordMarks = FALSE;
Plot3DModeEnum     Plot3DMode                = MODE_Unknown;
LgIndex            Plot3DNumGrids            = 1;
LgIndex            Plot3DCurGrid;
LgIndex            Plot3DKIndex;
LgIndex            Plot3DIDim[MaxNumZones];
LgIndex            Plot3DJDim[MaxNumZones];
LgIndex            Plot3DKDim[MaxNumZones];
uint32             Plot3DKSet[IJKSetSize];
uint32             Plot3DJSet[IJKSetSize];
uint32             Plot3DISet[IJKSetSize];
uint32             Plot3DBadBlockCount = 0;
Boolean            IJKSetSet;
#endif

static void CleanUp(IsOk)
            Boolean IsOk;
{

  if (!IsOk && *PlotFileName)
    { 
      fclose(PlotFile);
      unlink(PlotFileName);
    }
  if (*BlckFName)
    {
      fclose(BlckFile);
      unlink(BlckFName);
    }
  if (!IsOk)
    exit (-1);
}


static void BadWrite()
{
  fprintf(stderr,"Cannot write to disk!!  Check disk space\n");
  CleanUp(FALSE);
}




void GetRandomFileName(Prefix,F)
     char             *Prefix;
     char             *F;
{
#ifndef DOS
  strcpy(F,Prefix);
  strcat(F,"XXXXXX");
  mktemp(F);
#endif
#if defined (DOS)
  strcpy(F,"BLCKFILE");
#endif
}




/************************************************************/
#if defined PLOT3D
Boolean inset(i,set)
        uint32 i;
        uint32 *set;
{ 
  uint32 Word;
  uint32 Mask;

  Mask = (uint32)1 << (i % 32);
  Word = i / 32;
  return ((Boolean)((Mask & set[Word]) != 0));
}



void addtoset(i,set)
     uint32 i;
     uint32 *set;
{ 
  uint32 Word;

  Word      = i / 32;
  set[Word] = (set[Word] | ((uint32)1 << (i % 32)));
}


void settonull(set,l)
     uint32 *set;
     uint32 l;
{ 
  int i;

  for (i = 0; i < l; i++)
    set[i] = 0;
}


void copyset(toset,fromset,l)
     uint32 *toset;
     uint32 *fromset;
     uint32 l;
{
  int i;
  for (i = 0; i < l; i++)
    toset[i] = fromset[i];
}
#endif



void ErrMsg(S,ShowLine)
     LStringType S;
     Boolean     ShowLine;
{
  int   I;

  IsOk = FALSE;
  putchar('\n');
  if (ShowLine)
    {
      for (I = 0; I <= LinePos+4; I++)
        putchar(' ');
      printf("V");
      for (I = 0; I < 3; I++)
        putchar('-');
      printf(" Err: %s\n",S);
      printf("%5ld %s\n",LineNumber,Line);
    }
  else
    printf("Err: %s\n",S);
  CleanUp(FALSE);
}


void WarnMsg(S,ShowLine)
     LStringType S;
     Boolean     ShowLine;
{
  int   I;

  if (NumWarns < 50)
    {
      putchar('\n');
      if (ShowLine)
        {
          for (I = 0; I <= LinePos+4; I++)
            putchar(' ');
          printf("V");
          for (I = 0; I < 3; I++)
            putchar('-');
          printf("Warning: %s\n",S);
          printf("%5d %s\n",LineNumber,Line);
        }
      else
        printf("Warning: %s\n",S);
    }
  NumWarns++;
  if (NumWarns == 50)
    {
      printf("Warning Limit Exceeded... Further warnings will not be printed\n");
    }
}


void CheckIfValue()
{
  if (CurToken != ValueToken)
    ErrMsg("Expecting a value",TRUE);
}


int GetNextLimit(CPtrPtr,Default,IsOk)
    char       **CPtrPtr;
    LgIndex      Default;
    Boolean     *IsOk;
{
  LgIndex Sum = Default;

  if (**CPtrPtr != ',')
    {
      Sum = 0;
      while ((**CPtrPtr != ',') &&
             (**CPtrPtr != ' ') &&
             (**CPtrPtr != '\0'))
        {
          if (isdigit(**CPtrPtr))
            Sum = Sum*10 + **CPtrPtr - '0';
          else
            *IsOk = FALSE;
          (*CPtrPtr)++;
        }
    }
  (*CPtrPtr)++;
  return (Sum);
}



Boolean SetIJLimits(IJStart,IJEnd,IJSkip,S)
        LgIndex    *IJStart;
        LgIndex    *IJEnd;
        LgIndex    *IJSkip;
        char       *S;
{
  LgIndex StartZ,EndZ,Z;
  LgIndex NStart,NEnd,NSkip;
  Boolean IsOk = TRUE;
  char   *CPtr = S;

  if (Echo)
    printf("Set IJ Limits, >%s<\n",S);

  StartZ = GetNextLimit(&CPtr,0,&IsOk);
  if (StartZ == 0)
    {
      StartZ = 1;
      EndZ   = MaxNumZones;
    }
  else
    EndZ = StartZ;

  NStart = GetNextLimit(&CPtr,1,&IsOk);
  NEnd   = GetNextLimit(&CPtr,0,&IsOk);
  NSkip  = GetNextLimit(&CPtr,1,&IsOk);

  for (Z = StartZ; IsOk && (Z <= EndZ); Z++)
    {
      IJStart[Z] = NStart;
      IJEnd[Z]   = NEnd;
      IJSkip[Z]  = NSkip;
    }
  return (IsOk);
}



#define    round2(X)  ((X) >= 0 ? ((LgIndex)(X+0.49)) : ((LgIndex)(X-0.49)))
#ifndef CRAY
void WriteI(F,R)
     FILE  *F;
     float *R;
{
  LgIndex i;
  LgIndex IR;
  char   bufr[4];
  char  *buf;
  size_t NObjs;

  IR = round2(*R);

  buf = (char *)&IR;

  if (ReverseBytes)
    {
      for (i = 0; i < 4; i++)
        bufr[i] = buf[3-i];
      NObjs = fwrite(bufr,4,1,F);
        
    }
  else
    NObjs = fwrite(buf,4,1,F);
  if (NObjs < 1)
    BadWrite();
}
#endif


#if defined CRAY
void WriteI(F,R)
     FILE  *F;
     float *R;
{
  int    II = *R;
  char   Int4Buffer[8];
  char   bufr[4];
  int    i      = 1;
  int    type   = 1;
  int    bitoff = 0;
  size_t NObjs;
#if defined CRAYB
  CRAY2IEG(&type,&i,Int4Buffer,&bitoff,&II);
#else
  IX8X4(&i,&II,Int4Buffer);
#endif
  if (ReverseBytes)
    {
      for (i = 0; i < 4; i++)
        bufr[i] = Int4Buffer[3-i];
      NObjs = fwrite(bufr,4,1,F);
    }
  else
    NObjs = fwrite(Int4Buffer,4,1,F);
  if (NObjs < 1)
    BadWrite();
}
#endif




#ifndef CRAY
void WriteR(F,R)
     FILE  *F;
     float *R;
{
  int    i;
  char   bufr[4];
  size_t NObjs;

#ifndef CONVEX
  char  *buf = (char *)R;
#endif

#if defined CONVEX
  float  RR;
  char  *buf = (char *)&RR;

  RR = (float)dcvtid((double)*R);  /* Must use the Double precision
                                      version due to bug in single.
                                    */
#endif

  if (ReverseBytes)
    {
      for (i = 0; i < 4; i++)
        bufr[i] = buf[3-i];
      NObjs = fwrite(bufr,4,1,F);
    }
  else
    NObjs = fwrite(buf,4,1,F);
  if (NObjs < 1)
    BadWrite();
}
#endif

#if defined CRAY
void WriteR(F,R)
     FILE  *F;
     float *R;
{
  float  RR = *R;
  char   Real4Buffer[8];
  char   bufr[4];
  int    i      = 1;
  int    type   = 2;
  int    bitoff = 0;
  size_t NObjs;

  if ((RR > -1.0E-36) && (RR < 1.0E-36))
    RR = 0.0;
  else if (RR > 1.0E36)
    RR = 1.0E36;
  else if (RR < -1.0E36)
    RR = -1.0E36;

#if defined CRAYB
  CRAY2IEG(&type,&i,Real4Buffer,&bitoff,&RR);
#endif
#ifndef CRAYB
  FC8W4(&i,&RR,Real4Buffer);
#endif

  if (ReverseBytes)
    {
      for (i = 0; i < 4; i++)
        bufr[i] = Real4Buffer[3-i];
      NObjs = fwrite(bufr,4,1,F);
    }
  else
    NObjs = fwrite(Real4Buffer,4,1,F);
  if (NObjs < 1)
    BadWrite();
}
#endif


void WriteN(F,R)
     FILE  *F;
     float  R;
{
  float  RR;
  RR = R;
  WriteR(F,&RR);
}


void CopyCurData(S,MaxLen)
     char S[];
     int  MaxLen;
{
  int L;

  CurData[MaxLen] = '\0';
  strcpy(S,CurData);
  L = strlen(S)-1;
  while ((L > 0) && (S[L] == ' '))
    L--;
  S[L+1] = '\0';
}


Boolean CompareIdent(S,ID)
        char *S;
        char *ID;
{
  char *SPtr = S;
  char *IPtr = ID;
  while (*SPtr)
    {
      if ((*SPtr & 223) != *IPtr)
        return (FALSE);
      SPtr++;
      IPtr++;
    }
  return ((Boolean)(*IPtr == '\0'));
}


void GetNextLine(F)
     FILE       *F;
{
  Boolean Done = 0;
  if (feof(F))
    ErrMsg("Unexpected end of file:",FALSE);
  while (!Done)
    {
      if (fgets(Line,MaxLineIndex,F) == NULL)
        {
          if (feof(F))
            Done = TRUE;
          else
            {
              printf("Err: Unable to read input file\n");
              CleanUp(FALSE);
            }
        }
      else
        Done = ((*Line != '#') || (feof(F)));
      LineNumber++;
    }
  if (Echo > 1)
    printf("%5ld: %s",LineNumber,Line);
  LineLen       = strlen(Line) - 1;
  if (LineLen > MaxLineIndex-1)
    ErrMsg("Line too Long:",TRUE);
  else
    {
      Line[LineLen] = '\0';
      LinePos       = -1;
    }
}

Boolean CheckTokenStr(S)
        char S[];
{
  char S2[150];
  int  i;

  i = -1;
  while (CurData[++i] != '\0')
    if (islower(CurData[i]))
      S2[i] = toupper(CurData[i]);
    else
      S2[i] = CurData[i];
  S2[i] = '\0';

  return (!strcmp(S2,S));
}




void GetToken(TreatParenAsAlpha,OkToGetNextLine,F)
     Boolean  TreatParenAsAlpha;
     Boolean  OkToGetNextLine;
     FILE    *F;
{
  LgIndex     I;
  LgIndex     TempR;
  char        S[40];
  DOUBLE      DValue;
  DOUBLE      AbsDValue;
  Boolean     DecimalOrEFound;
  Boolean     EFound;
  short       C;

  if (RepeatLength > 0)
    {
      CurTValue = RepeatValue;
      CurToken  = ValueToken;
      RepeatLength--;
      return;
    }

  CurData[0] = '\0';
  CurToken = NullToken;

  while ((!feof(F)) && 
        ((Line[LinePos] == ' ')  || 
         (Line[LinePos] == ',')  || 
         (Line[LinePos] == '\r') ||
         (Line[LinePos] == '\t') || 
         (Line[LinePos] == '\\') || 
         (LinePos >= LineLen)))
   {
     if (LinePos >= LineLen)
       {
         if (OkToGetNextLine)
           GetNextLine(F);
         else
           {
             CurToken = EndofFileToken;
             return;
           }
       }
     LinePos++;
   }

  if (feof(F))
    CurToken = EndofFileToken;
  else if (Line[LinePos] == '=')
   {
      CurToken = EqualsToken;
      LinePos++;
   }
  else if ((Line[LinePos] == '(') && !TreatParenAsAlpha)
   {
      CurToken = LeftParenToken;
      LinePos++;
   }
  else if ((Line[LinePos] == ')') && !TreatParenAsAlpha)
   {
      CurToken = RightParenToken;
      LinePos++;
   }
  else if ((Line[LinePos] == '-') && 
           !(isdigit(Line[LinePos+1]) || (Line[LinePos+1] == '.')))
    CurToken = UnknownToken;
  else if ((isdigit(Line[LinePos])) || 
           (Line[LinePos] == '.')   ||
           (Line[LinePos] == '+')   ||
           (Line[LinePos] == '-'))
   {
      CurToken        = ValueToken;
      DecimalOrEFound = FALSE;
      EFound          = FALSE;
      I     = 0;
      while ((I < 40)                 && 
             (CurToken == ValueToken) &&
             (LinePos < LineLen)      && 
             (isdigit(C = Line[LinePos]) || (C == 'E')
                                         || (C == 'D')
                                         || (C == 'e')
                                         || (C == 'd')
                                         || (C == '.')
                                         || (C == '+')
                                         || (C == '-')))
        {
          if (isalpha(C))
            {
              EFound = TRUE;
              C = 'E';
            }
          S[I++] = C;
          if ((C == '.') || (C == 'E'))
            DecimalOrEFound = TRUE;
          else if (C == '-') 
            {
              if (EFound)
                {
                  if (!isalpha(Line[LinePos-1]))
                    CurToken = UnknownToken;
                }
              else if (I > 1)
                {
                  EFound = TRUE;
                  S[I-1] = 'E';
                  S[I++] = '-';
                }
            }
          else if (!EFound && (C == '+') && (I > 1))
            {
              EFound = TRUE;
              S[I-1] = 'E';
              S[I++] = '+';
            }
          LinePos++;
        }

      S[I] = '\0';
      if (DecimalOrEFound)
        {
#ifndef IRIS3000
          if (sscanf(S,"%le",&DValue) == EOF)
#endif
#if defined IRIS3000
          if (sscanf(S,"%e",&DValue) == EOF)
#endif
            CurToken = UnknownToken;
          else
            {
              AbsDValue = abs(DValue);
              if (AbsDValue < 1.0E-31)
                CurTValue = 0.0;
              else if (DValue >  1.0E31) 
                CurTValue =  1.0E31;
              else if (DValue < -1.0E31)
                CurTValue = -1.0E31;
              else
                CurTValue = DValue;
            }
        }
      else
        {
          if (sscanf(S,"%ld",&I) == EOF)
            CurToken = UnknownToken;
          else
            CurTValue = I;
        }
      if (Line[LinePos] == '*')            /* repeat */
        {
          TempR = (LgIndex)(CurTValue+0.01) - 1;
          LinePos++;
          GetToken(FALSE,TRUE,F);
          if (CurToken == ValueToken)
            {
              RepeatValue  = CurTValue;
              RepeatLength = TempR;
            }
          else
            ErrMsg("Bad Repeat",TRUE);
        }
   }
  else if (Line[LinePos] == '"')              /* stringToken */
   { 
      CurToken   = StringToken;
      I          = 0;
      LinePos++;
      while ((I < MaxLineIndex)   && 
             (LinePos < LineLen)  && 
             (Line[LinePos] != '"'))
        {
          if ((Line[LinePos] == '\\') && ((LinePos < LineLen-1)))
            LinePos++;
          CurData[I++] = Line[LinePos++];
        }
      if (LinePos < LineLen)
        {
          LinePos++;
          CurData[I] = '\0';
        }
      else
        {
          CurData[0] = '\0';
          CurToken = UnknownToken;
        }
   }
  else 
   {
      CurToken = IdentToken;
      I        = 0;
      while ((I < MaxLineIndex)      && 
             (LinePos < LineLen)     && 
             (Line[LinePos] != ' ')  && 
             (Line[LinePos] != ',')  && 
             (TreatParenAsAlpha || 
              (Line[LinePos] != ')')) && 
             (Line[LinePos] != '\t') && 
             (Line[LinePos] != '\r') && 
             (Line[LinePos] != '\\') && 
             (Line[LinePos] != '='))
        CurData[I++] = Line[LinePos++];
      CurData[I] = '\0';

      if (CheckTokenStr("ZONE"))
        CurToken = ZONEToken;
      else if (CheckTokenStr("FECONNECT"))
        CurToken = DupConnectToken;
      else if (CheckTokenStr("TITLE"))
        CurToken = TITLEToken;
      else if (CheckTokenStr("VARIABLES"))
        CurToken = VARIABLESToken;
      else if (CheckTokenStr("GEOMETRY"))
        CurToken = GEOMETRYToken;
      else if (CheckTokenStr("TEXT"))
        CurToken = TEXTToken;
      else if (CheckTokenStr("CUSTOMLABELS"))
        CurToken = CUSTOMLABELToken;
   }
}



#if defined PLOT3D
int Plot3D_GetBinaryInt(F)
     FILE *F;
{
#ifndef CONVEX
  long I;
  fread(&I,sizeof(long),1,F);
#endif
#if defined CONVEX
  long long I;
  fread(&I,sizeof(long long),1,F);
#endif
  return ((LgIndex)I);
}



#if defined CRAY
DOUBLE Plot3D_GetBinaryReal(F)
       FILE *F;
{

  float          R;
  LgIndex       *I = (LgIndex *)&R;
  unsigned char *C = (unsigned char *)&R;
  fread(&R,8,1,F);

  /* Weed out block markers */
  if (!((C[0] == 63)  ||
        (C[0] == 64)  ||
        (C[0] == 191) ||
        (C[0] == 192)) &&
        (*I != 0))
    {
      if (Plot3DBadBlockCount < 200)
        printf("# %d %d %d %d %d %d %d %d\n",
                  C[0],C[1],C[2],C[3],C[4],C[5],C[6],C[7]);
      Plot3DBadBlockCount++;
      fread(&R,8,1,F);
    }
  return ((DOUBLE)R);
}
#endif /* CRAY */


#if defined CONVEX
DOUBLE Plot3D_GetBinaryReal(F)
       FILE *F;
{
  double R;
  fread(&R,8,1,F);
  return ((DOUBLE)R);
}
#endif /* CONVEX */



#if defined APOLLO || defined SUN || defined DEC || defined MASSCOMP || defined DOS || defined ENCORE || defined IRIS
DOUBLE Plot3D_GetBinaryReal(F)
       FILE *F;
{
  float R; 
  fread(&R,4,1,F);
  return ((DOUBLE)R);
}
#endif



void  Plot3D_GetToken(F,IsInt)
      FILE           *F;
      Boolean         IsInt;
{
  short       C;
  LgIndex     I;
  LgIndex     TempR;
  char        S[40];
  DOUBLE      DValue;
  DOUBLE      AbsDValue;
  Boolean     DecimalOrEFound;

  if (Plot3DInputIsBinary)
    {
      if (IsInt)
        CurTValue = (DOUBLE)Plot3D_GetBinaryInt(F);
      else
        CurTValue = Plot3D_GetBinaryReal(F);
    }
  else
    {
      if (RepeatLength > 0)
        {
          CurTValue = RepeatValue;
          CurToken  = ValueToken;
          RepeatLength--;
          return;
        }

      CurToken = NullToken;

      C = fgetc(F);
      while ((C != EOF) && 
            ((C == ' ')  || 
             (C == ',')  || 
             (C == '\t') || 
             (C == '\r') || 
             (C == '\n')))
        {
          C = fgetc(F);
        }

      if (C == EOF)
        CurToken = EndofFileToken;
      else if ((isdigit(C) || 
               (C == '.')  ||
               (C == '+')  ||
               (C == '-')))
        {
          CurToken        = ValueToken;
          DecimalOrEFound = FALSE;
          I     = 0;
          while ((I < 40)  && 
                 (isdigit(C) || (C == 'E')
                             || (C == 'e')
                             || (C == '.')
                             || (C == '+')
                             || (C == '-')))
            {
              S[I++]  = C;
              if ((C == '.') || (C == 'E'))
                DecimalOrEFound = TRUE;
              C = fgetc(F);
            }

          S[I] = '\0';
          if (DecimalOrEFound)
            {
#ifndef IRIS3000
              if (sscanf(S,"%le",&DValue) == EOF)
#endif
#if defined IRIS3000
              if (sscanf(S,"%e",&DValue) == EOF)
#endif
                CurToken = UnknownToken;
              else
                {
                  AbsDValue = abs(DValue);
                  if (AbsDValue < 1.0E-31)
                    CurTValue = 0.0;
                  else if (DValue >  1.0E31) 
                    CurTValue =  1.0E31;
                  else if (DValue < -1.0E31)
                    CurTValue = -1.0E31;
                  else
                    CurTValue = DValue;
                }
            }
          else
            {
              if (sscanf(S,"%ld",&I) == EOF)
                CurToken = UnknownToken;
              else
                CurTValue = I;
            }
          if (C == '*')
            {
              TempR = (LgIndex)(CurTValue+0.01) - 1;
              Plot3D_GetToken(F,IsInt);
              if (CurToken == ValueToken)
                {
                  RepeatValue  = CurTValue;
                  RepeatLength = TempR;
                }
              else
                ErrMsg("Bad Repeat",FALSE);
            }
        }
    }
}



void Plot3D_GetRecordMarks(F)
     FILE                 *F;
{
#if defined CONVEX
  long I;
  if (Plot3DInputIsBinary)
    fread(&I,sizeof(long),1,F);
#endif
#ifndef CONVEX
  if (Plot3DInputIsBinary)
    Plot3D_GetToken(F,TRUE);
#endif
}

#endif /*Plot3D*/



Boolean RemoveEqualsSign(TreatParenAsAlpha)
        Boolean          TreatParenAsAlpha;
{
  GetToken(TreatParenAsAlpha,TRUE,InFile);
  if (CurToken == EqualsToken)
    {
      GetToken(TreatParenAsAlpha,TRUE,InFile);
      return (TRUE);
    }
  else
    return (FALSE);
}


void GetAnInteger(I)
     LgIndex *I;
{

  if (RemoveEqualsSign(FALSE))
    {
      CheckIfValue();
      if (abs(CurTValue) < 200000000.0)
        *I = abs(CurTValue);
      else
        ErrMsg("Value out of range",TRUE);
    }
  else
    ErrMsg("Missing an Equals sign",TRUE);
}



void GetAReal(R)
     float *R;
{
  if (RemoveEqualsSign(FALSE))
    {
      CheckIfValue();
      *R = CurTValue;
    }
  else
    ErrMsg("Missing an Equals sign",TRUE);
}



void GetBlock(F,IStart,IEnd,ISkip,IMax,
                JStart,JEnd,JSkip,JMax,
                KStart,KEnd,KSkip,KMax)
     FILE    *F;
     LgIndex  IStart,IEnd,ISkip,IMax;
     LgIndex  JStart,JEnd,JSkip,JMax;
     LgIndex  KStart,KEnd,KSkip,KMax;
{
     LgIndex         I,J,K;

  if (IsOk)
    {
      if ((IStart == 1) && (IEnd == IMax) && (ISkip == 1) &&
          (JStart == 1) && (JEnd == JMax) && (JSkip == 1) &&
          (KStart == 1) && (KEnd == KMax) && (KSkip == 1))
        {
          Index = IMax*JMax*KMax;
          for (I = 1; (I <= Index) && IsOk; I++)
            {
              if (CurToken != ValueToken)
                {
                  if (CurToken == EndofFileToken)
                    ErrMsg("End of file encountered while looking for value",FALSE);
                  else
                    ErrMsg("Bad Value",TRUE);
                }
              if (Echo == 9)
                printf("%G\n",CurTValue);
              WriteR(F,&CurTValue);
              GetToken(FALSE,TRUE,InFile);
            }
        }
      else
        {
          for (K = 1; (K <= KMax) && IsOk; K++)
          for (J = 1; (J <= JMax) && IsOk; J++)
          for (I = 1; (I <= IMax) && IsOk; I++)
            {
              if (CurToken != ValueToken)
                {
                  if (CurToken == EndofFileToken)
                    ErrMsg("End of file encountered while looking for value",FALSE);
                  else
                    ErrMsg("Bad Value",TRUE);
                }
              if ((I >= IStart) && (I <= IEnd) &&
                  (J >= JStart) && (J <= JEnd) &&
                  (K >= KStart) && (K <= KEnd) &&
                  ((I == IEnd) || (((I-IStart) % ISkip) == 0)) &&
                  ((J == JEnd) || (((J-JStart) % JSkip) == 0)) &&
                  ((K == KEnd) || (((K-KStart) % KSkip) == 0)))
                {
                  if (Echo == 9)
                    printf("%G\n",CurTValue);
                  WriteR(F,&CurTValue);
                }
              GetToken(FALSE,TRUE,InFile);
            }
        }
    }
}


#if defined PLOT3D
#define IJKOffset(I,J,K)    GridBase + (I + IMax*(J + JMax*K))
void Plot3D_GetBlock(IVar,Plane,Grid,IJKMode)
     LgIndex      IVar;
     LgIndex      Plane;
     LgIndex      Grid;
     short        IJKMode;
{
  LgIndex I,J,K;
  LgIndex IMax     = Plot3DIDim[Grid];
  LgIndex JMax     = Plot3DJDim[Grid];
  LgIndex KMax     = Plot3DKDim[Grid];
  LgIndex GridBase = Plot3DGridBase[Grid];

  if (Echo)
    printf("%ld    %ld\n",IVar+1,Plane+1);
  else
    printf("%ld,",IVar+1);
  fflush(stdout);

  switch (IJKMode)
    {
      case 'I' : /* I is Constant */
        {
          for (K = 0; K < KMax; K++)
          for (J = 0; J < JMax; J++)
            WriteR(BlckFile,
                   &Plot3DVarArray[IVar][IJKOffset(Plane,J,K)]);
        } break;
      case 'J' : /* J is Constant */
        {
          for (K = 0; K < KMax; K++)
          for (I = 0; I < IMax; I++)
            WriteR(BlckFile,
                   &Plot3DVarArray[IVar][IJKOffset(I,Plane,K)]);
        } break;
      case ' ' : /* Unknown */
      case 'K' : /* K is Constant */
        {
          for (J = 0; J < JMax; J++)
          for (I = 0; I < IMax; I++)
            WriteR(BlckFile,
                   &Plot3DVarArray[IVar][IJKOffset(I,J,Plane)]);
        } break;
    }
}

void Plot3D_LoadVar(InF,IsInt,IVar,N)
     FILE          *InF;
     Boolean        IsInt;
     LgIndex        IVar;
     LgIndex        N;
{
  LgIndex I;
  LgIndex J = 0;
  printf("Loading Var,CurIndex ->%ld %ld\n",IVar+1,Plot3DVarArrayCurIndex[IVar]);
  for (I = 1; (I <= N); I++)
    {
      J++;
      if (J == 5000)
        {
          putchar('.');
          fflush(stdout);
          J = 0;
        }
      Plot3D_GetToken(InF,IsInt);
      Plot3DVarArray[IVar][(Plot3DVarArrayCurIndex[IVar])++] = CurTValue;
      if (Echo == 3)
        {
          printf("%10G",CurTValue);
          if ((I % 7) == 0)
            putchar('\n');
        }
   }
   putchar('\n');
}


#endif




void RecogVarNames()
{
  NumVars = 0;
  if (RemoveEqualsSign(TRUE))
    {
      do
        {
          if ((CurToken == StringToken) || (CurToken == IdentToken))
            {
              NumVars = NumVars + 1;
              CopyCurData(VarName[NumVars],NumChrsVarName);
              if (Echo)
                printf("Var: %s\n",VarName[NumVars]);
            }
          else
            ErrMsg("Bad variable name for variable:",TRUE);
          GetToken(TRUE,TRUE,InFile);
        }
      while ((NumVars < MaxNumVars) && 
             ((CurToken == StringToken) || (CurToken == IdentToken)));
    }
  else
    ErrMsg("Missing Equals sign after 'VARIABLES' in header",TRUE);
}


void GetDupInfo()
{ 
  if (RemoveEqualsSign(FALSE))
    {
      if (CurToken != LeftParenToken)
        ErrMsg("Expecting a left parenthesis",TRUE);

      if (IsOk)
        GetToken(FALSE,TRUE,InFile);

      if (IsOk && ((CurToken != ValueToken) && (CurToken != DupConnectToken)))
        ErrMsg("Expecting a variable number",TRUE);

      while (IsOk && ((CurToken == ValueToken) || (CurToken == DupConnectToken)))
        {
          if (CurToken == ValueToken)
            {
              if ((CurTValue >= 1.0) && (CurTValue <= (float)NumVars))
                {
                  DupVars[(int)CurTValue] = TRUE;
                  NumDupVars++;
                  GetToken(FALSE,TRUE,InFile);
                }
              else
                ErrMsg("Invalid value for dup var Assignment",TRUE);
            }
          else
            {
              DupConnect = TRUE;
              GetToken(FALSE,TRUE,InFile);
            }
        }
      if (IsOk && (CurToken != RightParenToken))
        ErrMsg("Expecting a value, FECONNECT, or a right parenthesis",TRUE);
    }
  else
    ErrMsg("Expecting equals sign",TRUE);
}



void GetFormat()
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("POINT"))
        Format = POINT;
      else if (CheckTokenStr("BLOCK"))
        Format = BLOCK;
      else if (CheckTokenStr("FEBLOCK"))
        Format = FEBLOCK;
      else if (CheckTokenStr("FEPOINT"))
        Format = FEPOINT;
      else
        ErrMsg("Invalid Format, Need POINT, BLOCK, FEPOINT, or FEBLOCK",TRUE);
    }
  else
    ErrMsg("Missing Equals sign for Format Specifier",TRUE);
}


void GetElementType()
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("TRIANGLE"))
        Element = TRIANGLE;
      else if (CheckTokenStr("QUADRILATERAL"))
        Element = QUADRILATERAL;
      else if (CheckTokenStr("TETRAHEDRON"))
        Element = TETRAHEDRON;
      else if (CheckTokenStr("BRICK"))
        Element = BRICK;
      else if (CheckTokenStr("CUBE"))
        {
          WarnMsg("Element type of CUBE will be phased out.  Use BRICK\n");
          Element = BRICK;
        }
      else
        ErrMsg("Invalid Element type, Need TRIANGLE, QUADRILATERAL, TETRAHEDRON, or BRICK",TRUE);
    }
  else
    ErrMsg("Missing Equals sign for Format Specifier",TRUE);
}


#define Custom1_C 15
void GetColor(C)
     float   *C;
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("BLACK"))
        *C = 0.0;
      else if (CheckTokenStr("RED"))
        *C = 1.0;
      else if (CheckTokenStr("GREEN"))
        *C = 2.0;
      else if (CheckTokenStr("BLUE"))
        *C = 3.0;
      else if (CheckTokenStr("CYAN"))
        *C = 4.0;
      else if (CheckTokenStr("YELLOW"))
        *C = 5.0;
      else if (CheckTokenStr("PURPLE"))
        *C = 6.0;
      else if (CheckTokenStr("WHITE"))
        *C = 7.0;
      else if (CheckTokenStr("CUST1"))
        *C = Custom1_C;
      else if (CheckTokenStr("CUST2"))
        *C = Custom1_C + 1;
      else if (CheckTokenStr("CUST3"))
        *C = Custom1_C + 2;
      else if (CheckTokenStr("CUST4"))
        *C = Custom1_C + 3;
      else if (CheckTokenStr("CUST5"))
        *C = Custom1_C + 4;
      else if (CheckTokenStr("CUST6"))
        *C = Custom1_C + 5;
      else if (CheckTokenStr("CUST7"))
        *C = Custom1_C + 6;
      else if (CheckTokenStr("CUST8"))
        *C = Custom1_C + 7;
      else
        ErrMsg("Invalid Color",TRUE);
    }
  else
    ErrMsg("Missing Equals Sign in Color Assignment",TRUE);
}

void RecogZoneHeader()
{
  int N;
  Boolean FEFlagsUsed = FALSE;
  Boolean ISet        = FALSE;
  Boolean JSet        = FALSE;
  Boolean KSet        = FALSE;

  Z++;
  if (!Echo)
    printf("Zone : %3d\n",Z);
  /*Set Defaults*/
  strcpy(ZoneName[Z],"ZONE      ");
  ZoneName[Z][6] = '0' + Z / 10;
  ZoneName[Z][7] = '0' + Z % 10;
  ZoneColor      = -1.0;
  ZPlane         = 0.0;
  OldElement     = Element;
  OldIMax        = IMax;
  OldJMax        = JMax;
  OldKMax        = KMax;
  KMax           = 1;
  OldFormat      = Format;
  Format         = POINT;
  Element        = QUADRILATERAL;
  NumDupVars     = 0;
  DupConnect     = FALSE;
  for (N=1;N<=MaxNumVars;N++)
    DupVars[N] = FALSE;

  if (CurToken == ZONEToken)
    GetToken(FALSE,TRUE,InFile);
  while ((CurToken == IdentToken) && (IsOk))
    {
      if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                  CopyCurData(ZoneName[Z],NumChrsZoneName);
              else
                ErrMsg("Expecting a character string",TRUE);
            }
          else
            ErrMsg("Missing Equals sign in Zone Title Assignment",TRUE);
        }
      else if (CompareIdent(CurData,"D"))
        GetDupInfo();
      else if (CompareIdent(CurData,"C"))
        GetColor(&ZoneColor);
      else if (CompareIdent(CurData,"Z"))
        {
          GetAReal(&ZPlane);
          WarnMsg("ZPlane value in ZONE header obsolete - ignored",Z);
        }
      else if (CompareIdent(CurData,"I"))
        {
          GetAnInteger(&IMax);
          ISet = TRUE;
        }
      else if (CompareIdent(CurData,"N"))
        {
          GetAnInteger(&IMax);
          FEFlagsUsed = TRUE;
          ISet = TRUE;
        }
      else if (CompareIdent(CurData,"J"))
        {
          GetAnInteger(&JMax);
          JSet = TRUE;
        }
      else if (CompareIdent(CurData,"E"))
        {
          GetAnInteger(&JMax);
          FEFlagsUsed = TRUE;
          JSet = TRUE;
        }
      else if (CompareIdent(CurData,"ET"))
        {
          GetElementType();
          FEFlagsUsed = TRUE;
        }
      else if (CompareIdent(CurData,"K"))
        {
          GetAnInteger(&KMax);
          KSet = TRUE;
        }
      else if (CompareIdent(CurData,"F"))
        GetFormat();
      else
        ErrMsg("Bad Identifier in zone header",TRUE);
      if (IsOk)
        GetToken(FALSE,TRUE,InFile);
    }

  if (((Format == BLOCK) || (Format == POINT)) &&
      !JSet                                    &&
      (NumDupVars > 0))
    {
      JMax = OldJMax;
      JSet = TRUE;
    }

  if (!JSet)
    {
      if ((Format == FEPOINT) || (Format == FEBLOCK))
        JMax = LargestIndex;
      else
        JMax = 1;
    }

  if (((Format == BLOCK) || (Format == POINT)) &&
      !ISet                                    &&
      (NumDupVars > 0))
    {
      IMax = OldIMax;
      ISet = TRUE;
      WarnMsg("Variables are being duplicated and I is not set.\n         I will be set to value of previous zone.");
    }
  else if (!ISet)
    {
      IMax = LargestIndex;
    }


  if (NumDupVars > 0)
    {
      LgIndex OldNumPts;
      LgIndex NumPts;
      if (Z == 1)
        ErrMsg("Not allowed to dup variables or connect list for first zone",TRUE);
    
      if ((OldFormat == FEPOINT) || (OldFormat == FEBLOCK))
        OldNumPts = OldIMax;
      else
        OldNumPts = OldIMax*OldJMax*OldKMax;
      if ((Format == FEPOINT) || (Format == FEBLOCK))
        NumPts = IMax;
      else
        NumPts = IMax*JMax*KMax;
        
      if (OldNumPts != NumPts)
        ErrMsg("Cannot dup variables or if current zone and previous zone have different number of points",TRUE);
    }



  if (FEFlagsUsed && !((Format == FEPOINT) || (Format == FEBLOCK)))
    ErrMsg("N,E or ET flag used for non-FE type data",TRUE);

  if (DupConnect && (Element != OldElement))
    ErrMsg("Previous zones must have same element type when using FECONNECT",TRUE);
    
  if (Echo)
    {
      printf("\nZONE HEADER: T= %10s\n",ZoneName[Z]);
      printf("             I= %ld\n",IMax);
      printf("             J= %ld\n",JMax);
      printf("             K= %ld\n",KMax);
      printf("             F= ");
      if (Format == BLOCK)
        printf("BLOCK\n");
      else if (Format == POINT)
        printf("POINT\n");
      else if (Format == FEPOINT)
        printf("FEPOINT\n");
      else
        printf("FEBLOCK\n");

      if ((Format == FEPOINT) || (Format == FEBLOCK))
        {
          IStart[Z] = 1;
          IEnd[Z]   = IMax;
          ISkip[Z]  = 1;
          JStart[Z] = 1;
          JEnd[Z]   = 1;
          JSkip[Z]  = 1;
        }
    }
  if (!ISet && (Format == BLOCK))
    ErrMsg("Zone must at least contain I identifier for BLOCK format",TRUE);
  if (!ISet && ((Format == FEPOINT) || (Format == FEBLOCK)))
    ErrMsg("Must Specify N (and N must be greater than 0)) for FE formats",TRUE);
  if ((JMax <= 0) || (IMax <= 0) || (KMax <= 0))
    ErrMsg("I,J,K,N,E Must be greater than 0 if specified",TRUE);
  
  if (ISet && (IMax == 1))
    ErrMsg("Cannot set IMax to 1",TRUE);
  if (JSet && (JMax == 1) && KSet && (KMax > 1))
    ErrMsg("Cannot set JMax to 1 when KMax > 1",TRUE);
}

void ShowColor(C)
     float     C;
{
       if (C == 0.0)  printf("BLACK\n");
  else if (C == 1.0)  printf("RED\n");
  else if (C == 2.0)  printf("GREEN\n");
  else if (C == 3.0)  printf("BLUE\n");
  else if (C == 4.0)  printf("CYAN\n");
  else if (C == 5.0)  printf("YELLOW\n");
  else if (C == 6.0)  printf("PURPLE\n");
  else if (C == 7.0)  printf("WHITE\n");
}




void GetMode()
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("WINDOW"))
        Mode = WINDOW;
/* keep this to remain backwords compatible */
      else if (CheckTokenStr("GRID"))
        Mode = GRID;
      else
        ErrMsg("Invalid Mode, Need GRID or WINDOW",TRUE);
    }
  else
    ErrMsg("Missing equals sign in mode assignment",TRUE);
}


void GetScope()
{
  if (RemoveEqualsSign(FALSE))
    {
      if (CheckTokenStr("GLOBAL"))
        Scope = GLOBAL;
      else if (CheckTokenStr("LOCAL"))
        Scope = LOCAL;
      else
        ErrMsg("Invalid Scope, Need GLOBAL or LOCAL",TRUE);
    }
  else
    ErrMsg("Missing equals sign in scope assignment",TRUE);
}





void RecogGeometryHeader()
{
  LgIndex I;

  /* Set Defaults */
  XX        = 0.0;
  YY        = 0.0;
  ZZ        = 0.0;
  Color     = 7.0;
  FillColor = 0.0;
  IsFilled  = 0.0;
  TGZone    = 0.0;
  Scope     = GLOBAL;
  Mode      = WINDOW;
  LineMode  = SOLID;
  GeomType  = LINE;
  Format    = POINT;

  GetToken(FALSE,TRUE,InFile);
  while ((IsOk) && (CurToken == IdentToken))
    {
      if (CompareIdent(CurData,"X"))
        GetAReal(&XX);
      else if (CompareIdent(CurData,"Y"))
        GetAReal(&YY);
      else if (CompareIdent(CurData,"ZN"))
        GetAReal(&TGZone);
      else if (CompareIdent(CurData,"Z"))
        GetAReal(&ZZ);
      else if (CompareIdent(CurData,"M"))
        GetMode();
      else if (CompareIdent(CurData,"S"))
        GetScope();
      else if (CompareIdent(CurData,"C"))
        GetColor(&Color);
      else if (CompareIdent(CurData,"Z"))
        GetAReal(&TGZone);
      else if (CompareIdent(CurData,"FC"))
        {
          GetColor(&FillColor);
          IsFilled = 1.0;
        }
      else if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("LINE"))
                GeomType = LINE;
              else if ((CheckTokenStr("BOX") ||
                       (CheckTokenStr("FILLEDBOX"))))
                {
                  ErrMsg("Box and FilledBox No longer supported, Use RECTANGLE or old preplot",TRUE);
                }
              else if (CheckTokenStr("RECTANGLE"))
                GeomType = RECTANGLE;
              else if (CheckTokenStr("ELLIPSE"))
                GeomType = ELLIPSE;
              else if (CheckTokenStr("CIRCLE"))
                GeomType = CIRCLE;
              else if (CheckTokenStr("LINE3D"))
                GeomType = LINE3D; 
              else
                ErrMsg("Invalid geometry Type, Need LINE,RECTANGLE,ELLIPSE, CIRCLE, or LINE3D",TRUE);
            }
          else
            ErrMsg("Missing Equals Sign in geometry type assignment",TRUE);
        }
      else if (CompareIdent(CurData,"L"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("SOLID"))
                LineMode = SOLID;
              else if (CheckTokenStr("DASHED"))
                LineMode = DASHED;
              else if (CheckTokenStr("DASHDOT"))
                LineMode = DASHDOT;
              else if (CheckTokenStr("DASHDOTDOT"))
                LineMode = DASHDOTDOT;
              else if (CheckTokenStr("DOTTED"))
                LineMode = DOTTED;
              else if (CheckTokenStr("LONGDASH"))
                LineMode = LONGDASH;
              else
                ErrMsg("Invalid Line Type, Need SOLID,DASHED,DASHDOT,DASHDOTDOT,LONGDASH or DOTTED",TRUE);
            }
          else
            ErrMsg("Missing Equals Sign in line type assignment",TRUE);
        }
      else if (CompareIdent(CurData,"F"))
        GetFormat();
      else
        ErrMsg("Bad Identifier in Geometry header",TRUE);
      if (IsOk)
        GetToken(FALSE,TRUE,InFile);
    }

  if (IsOk)
    {
      if (GeomType == LINE3D)
        {
          Mode = GRID;
        }
    }
  if (Echo)
    {
      printf("\nGEOM HEADER: X= %G\n",XX);
      printf("             Y= %G\n",YY);
      printf("             Z= %G\n",ZZ);
      printf("            TZ= %G\n",TGZone);
      printf("             C= ");
      ShowColor(Color);
      printf("             S= ");
      if (Scope == GLOBAL)
        printf("GLOBAL\n");
      else
        printf("LOCAL\n");
      printf("             M= ");
      if (Mode == GRID)
        printf("GRID\n");
      else
        printf("WINDOW\n");
      printf("             L= ");
      if (LineMode == SOLID)
        printf("SOLID\n");
      else if (LineMode == DASHED)
        printf("DASHED\n");
      else if (LineMode == DASHDOT)
        printf("DASHDOT\n");
      else if (LineMode == DOTTED)
        printf("DOTTED\n");
      printf("             T= ");
      if (GeomType == LINE)
        printf("LINE\n");
      else if (GeomType == CIRCLE)
        printf("CIRCLE\n");
      else if (GeomType == LINE3D)
        printf("3D-LINE\n");
    }
}

void RecogTextHeader()
{
  LgIndex I;

  /*Set Defaults*/
  XX              = 0.0;
  YY              = 0.0;
  TGZone          = 0.0;
  Color           = 7.0;
  Scope           = GLOBAL;
  Mode            = WINDOW;
  Angle           = 0.0;
  Font            = 1.0;
  Height          = 0.03;
  BoxFillColor    = 0.0;
  BoxOutlineColor = 7.0;
  BoxMargin       = 0.1;
  BoxType         = 0.0;
          
  GetToken(FALSE,TRUE,InFile);
  while ((CurToken == IdentToken) && IsOk)
    {
      if (CompareIdent(CurData,"T"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if ((CurToken == StringToken) || (CurToken == IdentToken))
                strcpy(Title,CurData);
              else
                ErrMsg("Expecting a character string",TRUE);
            }
          else
            ErrMsg("Missing Equals sign in Text Assignment",TRUE);
        }
      else if (CompareIdent(CurData,"X"))
        GetAReal(&XX);
      else if (CompareIdent(CurData,"Y"))
        GetAReal(&YY);
      else if (CompareIdent(CurData,"M"))
        GetMode();
      else if (CompareIdent(CurData,"S"))
        GetScope();
      else if (CompareIdent(CurData,"A"))
        GetAReal(&Angle);
      else if (CompareIdent(CurData,"ZN"))
        GetAReal(&TGZone);
      else if (CompareIdent(CurData,"BX"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("NOBOX"))
                BoxType = 0.0;
              else if (CheckTokenStr("HOLLOW"))
                BoxType = 1.0;
              else if (CheckTokenStr("FILLED"))
                BoxType = 2.0;
              else
                ErrMsg("Invalid Box Type");
            }
        }
      else if (CompareIdent(CurData,"BXF"))
        GetColor(&BoxFillColor);
      else if (CompareIdent(CurData,"BXO"))
        GetColor(&BoxOutlineColor);
      else if (CompareIdent(CurData,"BXM"))
        GetAReal(&BoxMargin);
      else if (CompareIdent(CurData,"F"))
        {
          if (RemoveEqualsSign(FALSE))
            {
              if (CheckTokenStr("HELV"))
                Font = 0.0;
              else if (CheckTokenStr("HELV-BOLD"))
                Font = 1.0;
              else if (CheckTokenStr("GREEK"))
                Font = 2.0;
              else if (CheckTokenStr("MATH"))
                Font = 3.0;
              else if (CheckTokenStr("USER-DEF"))
                Font = 4.0;
              else if (CheckTokenStr("TIMES"))
                Font = 5.0;
              else if (CheckTokenStr("TIMES-ITALIC"))
                Font = 6.0;
              else if (CheckTokenStr("TIMES-BOLD"))
                Font = 7.0;
              else if (CheckTokenStr("TIMES-ITALIC-BOLD"))
                Font = 8.0;
              else if (CheckTokenStr("COURIER"))
                Font = 9.0;
              else if (CheckTokenStr("COURIER-BOLD"))
                Font = 10.0;
              else
                ErrMsg("Invalid Font Type");
           }
        }
      else if (CompareIdent(CurData,"H"))
        GetAReal(&Height);
      else if (CompareIdent(CurData,"C"))
        GetColor(&Color);
      else
        ErrMsg("Bad Identifier in Text header",TRUE);
      if (IsOk)
        GetToken(FALSE,TRUE,InFile);
    }
  if (Echo)
    {
      printf("\nTEXT HEADER: X= %G\n",XX);
      printf("             Y= %G\n",YY);
      printf("             F= %G\n",Font);
      printf("             H= %G\n",Height);
      printf("             A= %G\n",Angle);
      printf("            TZ= %G\n",TGZone);
      printf("             C= ");
      ShowColor(Color);
      printf("             S= ");
      if (Scope == GLOBAL)
        printf("GLOBAL\n");
      else
        printf("LOCAL\n");
      printf("             M= ");
      if (Mode == GRID)
        printf("GRID\n");
      else
        printf("WINDOW\n");
      printf("             T= %s",Title);
    }
}



void RecogCustomLabelHeader()
{
  LgIndex I;

  /*Set Defaults*/
  NumCustomLabels = 0;
          
  /* Remove the equals sign if one is there and fetch the next token*/
  RemoveEqualsSign(FALSE);
  while (((CurToken == StringToken) || (CurToken == IdentToken)) && IsOk)
    {
      if (CustomLabel[NumCustomLabels] != NULL)
        free (CustomLabel[NumCustomLabels]);
      CustomLabel[NumCustomLabels] = (char *)malloc(strlen(CurData)+1);
      strcpy(CustomLabel[NumCustomLabels],CurData);
      NumCustomLabels++;
      GetToken(FALSE,TRUE,InFile);
    }
  if (Echo)
    {
      printf("\nCUSTOMLABEL HEADER: N= %d\n",NumCustomLabels);
      for (I = 0; I < NumCustomLabels; I++)
        printf("Label %2d: %s\n",I,CustomLabel[I]);
    }
}

void DumpString(S)
     char *S;
{
  float  X;
  int    L;

  L = 0;
  while (S[L] != '\0')
    {
      X = S[L++];
      WriteR(PlotFile,&X);
    }
  X = 0.0;
  WriteR(PlotFile,&X);
}



#if defined PLOT3D


static Boolean Plot3D_GetList(ListString,PlaneSet,C)
               char          *ListString;
               uint32        *PlaneSet;
               char           C;
{
  LgIndex      PrevK   = 0;
  Boolean  DoRange = FALSE;
  char    *SetPtr  = ListString;
  LgIndex      I;
  LgIndex  Start,End,Skip;

  settonull(PlaneSet,IJKSetSize);

  while (*SetPtr)
    {
      if (isdigit(*SetPtr))
        {
          Skip = 1;
          Start = *SetPtr++ - '0';
          while (isdigit(*SetPtr))
            Start = Start*10 + *SetPtr++ - '0';
          Start = ((Start > 2048) ? 2048 : Start);
          if (*SetPtr == ':')
            {
              SetPtr++;
              if (!isdigit(*SetPtr))
                return (FALSE);
              End = *SetPtr++ - '0';
              while (isdigit(*SetPtr))
                End = End*10 + *SetPtr++ - '0';
              End = ((End > 2048) ? 2048 : End);
              if (*SetPtr == ':')
                {
                  SetPtr++;
                  if (!isdigit(*SetPtr))
                    return (FALSE);
                  Skip = *SetPtr++ - '0';
                  while (isdigit(*SetPtr))
                    Skip = Skip*10 + *SetPtr++ - '0';
                  Skip = ((Skip > 2048) ? 2048 : Skip);
                }
            }
          else
            End = Start;

          for (I = Start; I <= End; I += Skip)
            addtoset(I-1,PlaneSet);
          addtoset(End-1,PlaneSet);
        }
      else
        SetPtr++;
    }

  printf("%cSet: ",C);
  for (I = 0; I < IJKSetSize*32; I++)
    if (inset(I,PlaneSet))
      printf("%ld,",I+1);
  putchar('\n');
  return (TRUE);
}

#endif /* PLOT3D */



main (argc,argv)
     int   argc;
     char *argv[];


{ 
  LgIndex  I,J,K,N,LastI;
  LgIndex  L;
  LgIndex  JJMax;
  char     buf[FloatSize];
  char     InFileName[150];
  char     TInFileName[150];
  Boolean  InFileFound;
  Boolean  CreatePlotName;
  Boolean  Fetch;
  Boolean  IndexIsGood;
  Boolean  VariablesIdentified = FALSE;
  Boolean  ZoneHeaderParsed    = FALSE;

  for (I = 0; I < MaxCustomLabels; I++)
    CustomLabel[I] = NULL;

  PlotFileName[0] = '\0';
  BlckFName[0]    = '\0';

  IsOk = TRUE;
  NumWarns = 0;

  printf(VersionString);

  GetRandomFileName("pp",BlckFName);

#ifndef DOS
  BlckFile       = fopen(BlckFName,"w");
#endif
#if defined DOS
  BlckFile       = fopen(BlckFName,"wb");
#endif

  if (BlckFile == NULL)
    {
      printf("Err: Unable to create temp scratch file %s.  Check Directory permissions\n",BlckFName);
      CleanUp(FALSE);
    }


  CreatePlotName       = TRUE;
  InFileFound          = FALSE;
  Echo                 = 0;
  ReverseBytes         = FALSE;
  ConvertFromPolar     = FALSE;
  ConvertFromSpherical = FALSE;
  ReverseBytes         = FALSE;
  OldFEMFormat         = FALSE;

#if defined PLOT3D
  IJKSetSet             = FALSE;
  InputIsPlot3D         = FALSE;
  Plot3DInputIsGridOnly = FALSE;
  Plot3DIsMultiGrid     = FALSE;
  Plot3DHasIBlank       = 0;
  Plot3DInputIsBinary   = FALSE;

  for (I = 0; I < MaxNumZones; I++)
    {
      Plot3DIDim[I] = 1;
      Plot3DJDim[I] = 1;
      Plot3DKDim[I] = 1;
    }
  settonull(Plot3DKSet,IJKSetSize);
  settonull(Plot3DJSet,IJKSetSize);
  settonull(Plot3DISet,IJKSetSize);
#endif

  for (I = 0; I < MaxNumZones; I++)
    {
      IStart[I] = 1;
      IEnd[I]   = 0;
      ISkip[I]  = 1;
      JStart[I] = 1;
      JEnd[I]   = 0;
      JSkip[I]  = 1;
      KStart[I] = 1;
      KEnd[I]   = 0;
      KSkip[I]  = 1;
    }

  I = 1;

  while (IsOk && (I < argc))
    {
      if (!strcmp(argv[I],"-d") || !strcmp(argv[I],"-D"))
        Echo = 1;
      else if ((argv[I][0] == '-') &&
               ((argv[I][1] == 'd') || (argv[I][1] == 'D')) &&
               (isdigit(argv[I][2])))
        Echo = argv[I][2] - '0';
      else if (!strcmp(argv[I],"-r") || !strcmp(argv[I],"-R"))
        ReverseBytes = TRUE;
/*
      else if (!strcmp(argv[I],"-cp") || !strcmp(argv[I],"-CP"))
        ConvertFromPolar = TRUE;
      else if (!strcmp(argv[I],"-cs") || !strcmp(argv[I],"-CS"))
        ConvertFromSpherical = TRUE;
*/
      else if (!strcmp(argv[I],"-fe") || !strcmp(argv[I],"-FE"))
        OldFEMFormat = TRUE;
      else if (!strcmp(argv[I],"-iset") || !strcmp(argv[I],"-ISET"))
        {
          I++;
          IsOk = SetIJLimits(IStart,IEnd,ISkip,argv[I]);
        }
      else if (!strcmp(argv[I],"-jset") || !strcmp(argv[I],"-JSET"))
        {
          I++;
          IsOk = SetIJLimits(JStart,JEnd,JSkip,argv[I]);
        }
      else if (!strcmp(argv[I],"-kset") || !strcmp(argv[I],"-KSET"))
        {
          I++;
          IsOk = SetIJLimits(KStart,KEnd,KSkip,argv[I]);
        }
#if !defined (PLOT3D)
      else if (!strcmp(argv[I],"-plot3d") || !strcmp(argv[I],"-PLOT3D"))
        {
          printf("Err: Plot-3D files not supported: preplot not compiled with -DPLOT3D flag\n");
          CleanUp(FALSE);
        }
#endif
#if defined PLOT3D
      else if (!strcmp(argv[I],"-plot3d") || !strcmp(argv[I],"-PLOT3D"))
        InputIsPlot3D = TRUE;
      else if (!strcmp(argv[I],"-m") || !strcmp(argv[I],"-M"))
        Plot3DIsMultiGrid = TRUE;
      else if (!strcmp(argv[I],"-i") || !strcmp(argv[I],"-I"))
        Plot3DHasIBlank = 1;
      else if (!strcmp(argv[I],"-b") || !strcmp(argv[I],"-B"))
        Plot3DInputIsBinary = TRUE;
      else if (!strcmp(argv[I],"-f") || !strcmp(argv[I],"-F"))
        Plot3DInputHasRecordMarks = TRUE;
      else if (!strcmp(argv[I],"-1d"))
        Plot3DMode = MODE_1D;
      else if (!strcmp(argv[I],"-2d"))
        Plot3DMode = MODE_2D;
      else if (!strcmp(argv[I],"-3dw"))
        Plot3DMode = MODE_3DW;
      else if (!strcmp(argv[I],"-3dp"))
        Plot3DMode = MODE_3DP;
      else if (!strcmp(argv[I],"-gridonly"))
        Plot3DInputIsGridOnly = TRUE;
      else if (!strcmp(argv[I],"-kp") || !strcmp(argv[I],"-KP"))
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!Plot3D_GetList(argv[I],Plot3DKSet,'K'))
                ErrMsg("Bad -kp list");
            }
        }
      else if (!strcmp(argv[I],"-jp") || !strcmp(argv[I],"-JP"))
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!Plot3D_GetList(argv[I],Plot3DJSet,'J'))
                ErrMsg("Bad -jp list");
            }
        }
      else if (!strcmp(argv[I],"-ip") || !strcmp(argv[I],"-IP"))
        {
          IJKSetSet = TRUE;
          I++;
          if (argv[I])
            {
              if (!Plot3D_GetList(argv[I],Plot3DISet,'I'))
                ErrMsg("Bad -ip list");
            }
        }
#endif /*PLOT3D*/

      else
        { 
          if ((*argv[I] == '-') && (strlen(argv[I]) > 1))
            ErrMsg("invalid flag");
          else
            {
              if (!InFileFound)
                {
                  strcpy(InFileName,argv[I]);
                  InFileFound = TRUE;
                }
              else if (CreatePlotName)
                {
                  strcpy(PlotFileName,argv[I]);
                  CreatePlotName = FALSE;
                }
            }
        }
      I++;
    }


#if defined PLOT3D

  if (Plot3DInputHasRecordMarks)
    Plot3DInputIsBinary = TRUE;

  if (InputIsPlot3D && (Plot3DMode == MODE_Unknown))
    ErrMsg("PLOT3D Mode not set",FALSE);
#endif

  if (!InFileFound)
    IsOk = FALSE;

  if (IsOk)
    {
      strcpy(TInFileName,InFileName);
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          strcat(InFileName,".g");
          IsOk = ((InFile = fopen(InFileName,"r")) != 0);
          if (IsOk && !Plot3DInputIsGridOnly)
            {
              strcpy(InFileName,TInFileName);
              strcat(InFileName,".q");
              IsOk = ((InFile_q = fopen(InFileName,"r")) != 0);
            }
          if (!IsOk)
            printf("Err: cannot find input files %s.q or %s.g\n",
                    TInFileName,TInFileName);
        }
      else
#endif
        {
          if (strcmp(InFileName,"-"))
            {
              IsOk = ((InFile = fopen(InFileName,"r")) != 0);
              if (!IsOk)
                {
                  strcat(InFileName,".dat");
                  IsOk = ((InFile = fopen(InFileName,"r")) != 0);
                }
            }
          else
            InFile = stdin;
          if (!IsOk)
            printf("Err: cannot find input file:: %s\n",TInFileName);
        }
    }

  if (Echo)
    printf("Temporary scratch file = %s\n",BlckFName);

/******************** to be added later **************
-cp -cs ........................... cp converts R,theta to X,Y.  cs converts\n\
                                    R,theta,phi to X,Y,Z\n\
*/

  if (!IsOk)
    {
      printf("\n\
Usage: preplot infile [outfile] [flags]\n\
Where [flags] are:\n\
-d -d2 -d3 ........................ Debug echo add 2 or 3 for more output\n\
-r ................................ Reverse bytes of the output binary file\n\
-iset [zone],[start],[end],[skip].. restrict the i-index.\n\
                                    If zone is omitted then do all zones.\n\
                                    start and skip default to 1.  end \n\
                                    defaults to imax.\n\
-jset [zone],[start],[end],[skip].. same as iset except for j index\n\
-kset [zone],[start],[end],[skip].. same as iset except for k index\n");

#if defined PLOT3D
printf("\
PLOT3D input ONLY:\n\
-plot3d .... Input is plot3d format. -1d ........ Input is 1d            \n\
-m ......... Input is multi-grid     -2d ........ Input is 2d            \n\
-b ......... Input is binary         -3dp ....... Input is 3d-planar     \n\
-f ......... Input is binary-FORTRAN -3dw ....... Input is 3d-whole      \n\
-ip ilist .. zones come from ilist.  -i ......... Input contains IBlanking.\n\
-jp jlist .. zones come from jlist.  NOTES:  ilist, jlist, and klist are \n\
-kp klist .. zones come from klist.          of the form:\n\
-gridonly .. Read in the grid only.          start[:end[:skip]],...\n");
#endif
    }

  if (CreatePlotName && IsOk)
    {
      if (strcmp(InFileName,"-"))
        {
          J = strlen(InFileName);
          for (I = 0; InFileName[I] ; I++)
            if (InFileName[I] == '.')
              J = I;
          if (J <= MaxCharsBaseName)
            {
              InFileName[J] = '\0';
              strcpy(PlotFileName,InFileName);
              strcat(PlotFileName,".plt");
              if (strlen(PlotFileName) > MaxCharsFileName)
                PlotFileName[MaxCharsBaseName] = '\0';
              if (!strcmp(PlotFileName,InFileName))
                {
                  IsOk = FALSE;
                  printf("\nErr: Cannot create .plt filename extension\n");
                }
            }
          else
            {
              IsOk = FALSE;
              printf("\nErr: input filename too long to generate .plt extension\n");
            }
        }
      else
        strcpy(PlotFileName,"-"); 
    }

  if (IsOk)
    {
      if (strcmp(PlotFileName,"-"))
        {
#ifndef DOS
          IsOk = ((PlotFile = fopen(PlotFileName,"w")) != 0);
#endif
#if defined(DOS)
          IsOk = ((PlotFile = fopen(PlotFileName,"wb")) != 0);
#endif
          if (!IsOk)
            printf("\nErr: Cannot open file: %s\n",PlotFileName);
        }
      else
        PlotFile = stdout;
    }

  if (IsOk)
    {
      Title[0]        = '\0';
      HeaderString[0] = '\0';
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          VariablesIdentified = TRUE;
          if ((short)Plot3DMode > 2)
            {
              if (Plot3DInputIsGridOnly)
                {
                  NumVars = 3+Plot3DHasIBlank;
                  strcpy(VarName[1],"X");
                  strcpy(VarName[2],"Y");
                  strcpy(VarName[3],"Z");
                  strcpy(VarName[4],"IBlnk");
                }
              else
                {
                  NumVars = 8+Plot3DHasIBlank;
                  strcpy(VarName[1],"X");
                  strcpy(VarName[2],"Y");
                  strcpy(VarName[3],"Z");
                  strcpy(VarName[4],"IBlnk");
                  strcpy(VarName[4+Plot3DHasIBlank],"RHO");
                  strcpy(VarName[5+Plot3DHasIBlank],"RHO-U");
                  strcpy(VarName[6+Plot3DHasIBlank],"RHO-V");
                  strcpy(VarName[7+Plot3DHasIBlank],"RHO-W");
                  strcpy(VarName[8+Plot3DHasIBlank],"E");
                }
            }
          else if ((short)Plot3DMode == 2)
            {
              if (Plot3DInputIsGridOnly)
                {
                  NumVars = 2+Plot3DHasIBlank;
                  strcpy(VarName[1],"X");
                  strcpy(VarName[2],"Y");
                  strcpy(VarName[3],"IBlnk");
                }
              else
                {
                  NumVars = 6+Plot3DHasIBlank;
                  strcpy(VarName[1],"X");
                  strcpy(VarName[2],"Y");
                  strcpy(VarName[3],"IBlnk");
                  strcpy(VarName[3+Plot3DHasIBlank],"RHO");
                  strcpy(VarName[4+Plot3DHasIBlank],"RHO-U");
                  strcpy(VarName[5+Plot3DHasIBlank],"RHO-V");
                  strcpy(VarName[6+Plot3DHasIBlank],"E");
                }
            }
          else if ((short)Plot3DMode == 1)
            {
              NumVars = 4;
              strcpy(VarName[1],"X");
              strcpy(VarName[3],"V1");
              strcpy(VarName[4],"V2");
              strcpy(VarName[5],"V3");
            }
        }
      else
#endif
        {
          for (I = 0; I < MaxNumVars-1; I++)
            sprintf(VarName[I+1],"V%-4ld",I+1);
        }

    /*Start Parsing the input*/
      
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          if (!InFile)
            ErrMsg("Cannot find .g file",FALSE);
          if (!Plot3DInputIsGridOnly && !InFile_q)
            ErrMsg("Cannot find .q file",FALSE);
        }
      else  
#endif
        {
          if (InFile)
            {
              GetNextLine(InFile);
              LinePos = 0;
              GetToken(FALSE,TRUE,InFile);
            }
          else
            ErrMsg("Cannot find input file",FALSE);
        }
    }
  if (IsOk)
    { 
#if defined PLOT3D
      if (InputIsPlot3D)
        {
          if (Plot3DIsMultiGrid)
            {
              if (Plot3DInputHasRecordMarks)     /* Header Rec */
                {
                  if (!Plot3DInputIsGridOnly)
                    Plot3D_GetRecordMarks(InFile_q);
                  Plot3D_GetRecordMarks(InFile);
                }
              Plot3D_GetToken(InFile,TRUE);
              if (IsOk)
                {
                  Plot3DNumGrids = (LgIndex)CurTValue;
                  if (Echo)
                    printf("MultiGrid, NumG=%ld\n",Plot3DNumGrids);
                  if (!Plot3DInputIsGridOnly)
                    {
                      Plot3D_GetToken(InFile_q,TRUE);
                      if (Plot3DNumGrids != (LgIndex)CurTValue)
                        ErrMsg("inconsistant .g and .q files",FALSE);
                    }
                  if (Plot3DNumGrids > MaxNumZones)
                    {
                      printf("Err: Too many Grids in Plot3d file, G= %ld, Max=%ld\n",
                             Plot3DNumGrids,MaxNumZones);
                      IsOk = FALSE;
                    }
                }
#ifndef CRAY
              if (Plot3DInputHasRecordMarks)   /* Trailer Rec */
                {
                  if (!Plot3DInputIsGridOnly)
                    Plot3D_GetRecordMarks(InFile_q);
                  Plot3D_GetRecordMarks(InFile);
                }
#endif
            }

          if (Plot3DInputHasRecordMarks)      /* Header Rec */
            {
              if (!Plot3DInputIsGridOnly)
                Plot3D_GetRecordMarks(InFile_q);
              Plot3D_GetRecordMarks(InFile);
            }

          if (IsOk)
          for (I = 0; I < Plot3DNumGrids; I++)
            {
              if (!Plot3DInputIsGridOnly)
                Plot3D_GetToken(InFile_q,TRUE);
              Plot3D_GetToken(InFile,TRUE);
              Plot3DIDim[I] = (LgIndex)CurTValue;
              if ((short)Plot3DMode > 1)
                {
                  if (!Plot3DInputIsGridOnly)
                    Plot3D_GetToken(InFile_q,TRUE);
                  Plot3D_GetToken(InFile,TRUE);
                  Plot3DJDim[I] = (LgIndex)CurTValue;
                }
              if ((short)Plot3DMode > 2)
                {
                  if (!Plot3DInputIsGridOnly)
                    Plot3D_GetToken(InFile_q,TRUE);
                  Plot3D_GetToken(InFile,TRUE);
                  Plot3DKDim[I] = (LgIndex)CurTValue;
                }
              if ((Plot3DIDim[I] <= 0) ||
                  (Plot3DJDim[I] <= 0) ||
                  (Plot3DKDim[I] <= 0))
                IsOk = FALSE;
              if (Echo || !IsOk)
                printf("G=%ld,  ID=%ld,  JD=%ld,  KD=%ld\n",
                       I+1,Plot3DIDim[I],Plot3DJDim[I],Plot3DKDim[I]);
              if (!IsOk)
                {
                  printf("Error in dimensions\n");
                  CleanUp(FALSE);
                }
            }

#ifndef CRAY
          if (Plot3DInputHasRecordMarks)       /* Trailer Rec */
            {
              if (!Plot3DInputIsGridOnly)
                Plot3D_GetRecordMarks(InFile_q);
              Plot3D_GetRecordMarks(InFile);
            }
#endif

          EndOfHeader = TRUE;
        }
      else
#endif
        {
          EndOfHeader = FALSE;
          do
            {
              if (CurToken == TITLEToken)
                {
                  if (RemoveEqualsSign(FALSE))
                    {
                      if ((CurToken == StringToken) || 
                          (CurToken == IdentToken))
                        {
                          CopyCurData(HeaderString,80);
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else
                        ErrMsg("Expecting a string",TRUE);
                    }
                  else
                    ErrMsg("Missing Equals Sign after 'TITLE' in header",TRUE);
                }
              else if (CurToken == VARIABLESToken)
                {
                  RecogVarNames();
                  VariablesIdentified = TRUE;
                }
              else if ((CurToken == TEXTToken)      ||
                       (CurToken == GEOMETRYToken)  ||
                       (CurToken == CUSTOMLABELToken) ||
                       (CurToken == ZONEToken)      ||
                       (CurToken == ValueToken))
                EndOfHeader = TRUE;
              else if (CurToken == EndofFileToken)
                {
                  ErrMsg("Unexpected End of File",FALSE); 
                }
              else
                {
                  WarnMsg("Expecting Record Marker or Data.  Skipping Current token"); 
/*                LinePos = 0; */
                  GetToken(FALSE,TRUE,InFile);
                }
            }
          while (!EndOfHeader && IsOk);
        } /* else if Is Plot3D */

      if (IsOk)
        {
/*Write out header information*/
          WriteN(PlotFile,InputVersion);
          DumpString(HeaderString);
      
          if (!VariablesIdentified)
            {
              if (CurToken == ZONEToken)
                {
                  RecogZoneHeader();
                  if ((Format != POINT) && (Format != FEPOINT))
                    {
                      ErrMsg("VARIABLES= statement must be used if first zone format is not POINT",FALSE);
                      CleanUp(FALSE);
                    }
                  ZoneHeaderParsed = TRUE;
                }
              if (CurToken == ValueToken)
                {
                  NumVars = 0;
                  while (CurToken == ValueToken)
                    {
                      GetToken(FALSE,FALSE,InFile);
                      NumVars++;
                    }
                  if (CurToken != EndofFileToken)
                    {
                      ErrMsg("Bad value",TRUE);
                      CleanUp(FALSE);
                    }
                  LinePos = 0;
                  GetToken(FALSE,TRUE,InFile);
                }
              else
                {
                  NumVars = 2;
                }
            }

          XX = NumVars;
          WriteR(PlotFile,&XX);

          I = 0;
          while (I < NumVars)
            {
              I = I + 1;
              DumpString(VarName[I]);
            }
#if defined PLOT3D
          if (InputIsPlot3D)
            {
              /* first need to split up the .g and .q files into
                 many single variable arrays */
              for (L = 0; L < NumVars; L++)
                {
                  Index = 0;
                  for (I = 0; I < Plot3DNumGrids; I++)
                    {
                      Plot3DGridBase[I] = Index;
                      Index            += Plot3DIDim[I]*
                                          Plot3DJDim[I]*
                                          Plot3DKDim[I];
                    }

                  if (Echo)
                    printf("Allocing space for %ld values\n",Index);
                  Plot3DVarArray[L]         = (float *)malloc(FloatSize*Index);
                  Plot3DVarArrayCurIndex[L] = 0;
                  if (Plot3DVarArray[L] == NULL)
                    {
                      printf("Err: ran out of swap space on Var %d\n",L);
                      CleanUp(FALSE);
                    }
                }

              /* put case in here to divvy up the variables */
              if (Echo)
                printf("Transferring Data for Plot3DVarArrays ....\n");
              for (I = 0; I < Plot3DNumGrids; I++)
                {
                  if (!Plot3DInputIsGridOnly)
                    {
                      if (Plot3DInputHasRecordMarks)      /* Header Rec */
                        Plot3D_GetRecordMarks(InFile_q);
                      printf("Removing constants ...\n");
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("FSMACH = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("ALPHA  = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("RE     = %G\n",CurTValue);
                      Plot3D_GetToken(InFile_q,FALSE);
                      printf("TIME   = %G\n",CurTValue);
#ifndef CRAY
                      if (Plot3DInputHasRecordMarks) /* Trailer Rec */
                        {
                          Plot3D_GetRecordMarks(InFile_q);
                        }
#endif
                    }

                  if (Plot3DInputHasRecordMarks && 
                      (Plot3DMode != MODE_3DP))  /* Header Rec */
                    {
                      if (!Plot3DInputIsGridOnly)
                        Plot3D_GetRecordMarks(InFile_q);
                      Plot3D_GetRecordMarks(InFile);
                    }
                  switch (Plot3DMode)
                    {
                      case MODE_1D :
                        {
                          Plot3D_LoadVar(InFile,FALSE,0,Plot3DIDim[I]);
                          for (J = 1; J <= 3; J++)
                            Plot3D_LoadVar(InFile_q,FALSE,J,Plot3DIDim[I]);
                        } break;
                      case MODE_2D :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I];
                          for (J = 0; J < 2; J++)
                            Plot3D_LoadVar(InFile,FALSE,J,Index);
                          if (Plot3DHasIBlank)
                            Plot3D_LoadVar(InFile,TRUE,2,Index);
                          if (!Plot3DInputIsGridOnly)
                            for (J = 2; J < 6; J++)
                              Plot3D_LoadVar(InFile_q,FALSE,J+Plot3DHasIBlank,Index);
                        } break;
                      case MODE_3DP :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I];
                          for (K = 0; K < Plot3DKDim[I]; K++)
                            {
                              if (Plot3DInputHasRecordMarks)
                                { /*  Header Recs */
                                  if (!Plot3DInputIsGridOnly)
                                    Plot3D_GetRecordMarks(InFile_q);
                                  Plot3D_GetRecordMarks(InFile);
                                }
                              for (J = 0; J < 3; J++)
                                Plot3D_LoadVar(InFile,FALSE,J,Index);
                              if (Plot3DHasIBlank)
                                Plot3D_LoadVar(InFile,TRUE,3,Index);
                              if (!Plot3DInputIsGridOnly)
                                for (J = 3; J < 8; J++)
                                  Plot3D_LoadVar(InFile_q,FALSE,J+Plot3DHasIBlank,Index);
#ifndef CRAY
                              if (Plot3DInputHasRecordMarks)
                                { /* Trailer recs */
                                  if (!Plot3DInputIsGridOnly)
                                    Plot3D_GetRecordMarks(InFile_q);
                                  Plot3D_GetRecordMarks(InFile);
                                }
#endif
                            }
                        } break;
                      case MODE_3DW :
                        {
                          Index = Plot3DIDim[I]*Plot3DJDim[I]*Plot3DKDim[I];
                          for (J = 0; J < 3; J++)
                            Plot3D_LoadVar(InFile,FALSE,J,Index);
                          if (Plot3DHasIBlank)
                            Plot3D_LoadVar(InFile,TRUE,3,Index);
                          if (!Plot3DInputIsGridOnly)
                            for (J = 3; J < 8; J++)
                              Plot3D_LoadVar(InFile_q,FALSE,J+Plot3DHasIBlank,Index);
                        } break;
                    }
#ifndef CRAY
                  if (Plot3DInputHasRecordMarks && 
                      (Plot3DMode != MODE_3DP))
                    {       /* Trailer Recs */
                      if (!Plot3DInputIsGridOnly)
                        Plot3D_GetRecordMarks(InFile_q);
                      Plot3D_GetRecordMarks(InFile);
                    }
#endif
                }

        /*  Next pull data from var files and stuff into BlckFile */

              Z             = 0;
              Plot3DCurGrid = 0;
              while (IsOk && (Plot3DCurGrid < Plot3DNumGrids))
                {
                  switch (Plot3DMode)
                    {
                      case MODE_1D :
                        {
                          WriteN(PlotFile,ZONEMARKER);
                          WriteN(BlckFile,ZONEMARKER);
                          WriteN(BlckFile,0.0); /* No repeat vars */
                          Z             = Z + 1;
                          printf("\nZone : %3d\n",Z);
                          /*Set Defaults*/
                          strcpy(ZoneName[Z],"ZONE      ");
                          ZoneName[Z][6] = '0' + Z / 10;
                          ZoneName[Z][7] = '0' + Z % 10;
                          DumpString(ZoneName[Z]);
                          /* Format = BLOCK */
                          XX     = 0.0;
                          WriteR(PlotFile,&XX);
                          XX     = -1.0;           /* Zone Color */
                          WriteR(PlotFile,&XX);
                          IMax   = Plot3DIDim[Plot3DCurGrid];
                          JMax   = 1;
                          XX     = IMax;
                          YY     = JMax;
                          WriteR(PlotFile,&XX);
                          WriteR(PlotFile,&YY);
                          YY     = 1.0;
                          WriteR(PlotFile,&YY);

                          Index = IMax*JMax;
                          printf("Var  : ");
                          for (J = 0; J < 4; J++)
                            Plot3D_GetBlock(J,2,Plot3DCurGrid,' ');
                        } break; /* MODE_1D */
                      case MODE_2D :
                        {
                          WriteN(PlotFile,ZONEMARKER);
                          WriteN(BlckFile,ZONEMARKER);
                          WriteN(BlckFile,0.0); /* No repeat vars */
                          Z             = Z + 1;
                          printf("\nZone : %3d\n",Z);
                          /*Set Defaults*/
                          strcpy(ZoneName[Z],"ZONE      ");
                          ZoneName[Z][6] = '0' + Z / 10;
                          ZoneName[Z][7] = '0' + Z % 10;
                          DumpString(ZoneName[Z]);
                          /* Format = BLOCK */
                          XX     = 0.0;
                          WriteR(PlotFile,&XX);
                          XX     = -1.0;           /* Zone Color */
                          WriteR(PlotFile,&XX);
                          IMax   = Plot3DIDim[Plot3DCurGrid];
                          JMax   = Plot3DJDim[Plot3DCurGrid];
                          XX     = IMax;
                          YY     = JMax;
                          WriteR(PlotFile,&XX);
                          WriteR(PlotFile,&YY);
                          YY     = 1.0;
                          WriteR(PlotFile,&YY);

                          Index = IMax*JMax;
                          printf("Var  : ");
                          for (J = 0; J < NumVars; J++)
                            Plot3D_GetBlock(J,0,Plot3DCurGrid,' ');
                        } break; /* MODE_2D  */
                      case MODE_3DP :
                      case MODE_3DW :
                        {
                          if (IJKSetSet)
                            {
                              /* I planes */
                              for (I = 0; I < Plot3DIDim[Plot3DCurGrid]; I++)
                                {
                                  if (inset(I,Plot3DISet))
                                    {
                                      WriteN(PlotFile,ZONEMARKER);
                                      WriteN(BlckFile,ZONEMARKER);
                                      WriteN(BlckFile,0.0); /* No repeat vars */
                                      Z             = Z + 1;
                                      printf("\nZone=%-3d,  I=%ld\n",Z,I+1);
                                      /*Set Defaults*/
                                      sprintf(ZoneName[Z],"G%-3d,P%-3d ",Plot3DCurGrid+1,I+1);
                                      if (Echo) 
                                        printf("Zone Name ->%s<-\n",ZoneName[Z]);
                                      DumpString(ZoneName[Z]);
                                      /* Format = BLOCK */
                                      XX     = 0.0;
                                      WriteR(PlotFile,&XX);
                                      XX     = -1.0;           /* Zone Color */
                                      WriteR(PlotFile,&XX);
                                      IMax   = Plot3DJDim[Plot3DCurGrid];
                                      JMax   = Plot3DKDim[Plot3DCurGrid];
                                      KMax   = 1;
                                      XX     = IMax;
                                      YY     = JMax;
                                      WriteR(PlotFile,&XX);
                                      WriteR(PlotFile,&YY);
                                      YY     = KMax;
                                      WriteR(PlotFile,&YY);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        Plot3D_GetBlock(N,I,Plot3DCurGrid,'I');
                                    }
                                } /* for I */

                              /* J Planes */
                              for (J = 0; J < Plot3DJDim[Plot3DCurGrid]; J++)
                                {
                                  if (inset(J,Plot3DJSet))
                                    {
                                      WriteN(PlotFile,ZONEMARKER);
                                      WriteN(BlckFile,ZONEMARKER);
                                      WriteN(BlckFile,0.0); /* No repeat vars */
                                      Z             = Z + 1;
                                      printf("\nZone=%-3d,  J=%ld\n",Z,J+1);
                                      /*Set Defaults*/
                                      sprintf(ZoneName[Z],"G%-3d,P%-3d ",Plot3DCurGrid+1,J+1);
                                      if (Echo) 
                                        printf("Zone Name ->%s<-\n",ZoneName[Z]);
                                      DumpString(ZoneName[Z]);
                                      /* Format = BLOCK */
                                      XX     = 0.0;
                                      WriteR(PlotFile,&XX);
                                      XX     = -1.0;           /* Zone Color */
                                      WriteR(PlotFile,&XX);
                                      IMax   = Plot3DIDim[Plot3DCurGrid];
                                      JMax   = Plot3DKDim[Plot3DCurGrid];
                                      KMax   = 1;
                                      XX     = IMax;
                                      YY     = JMax;
                                      WriteR(PlotFile,&XX);
                                      WriteR(PlotFile,&YY);
                                      YY     = KMax;
                                      WriteR(PlotFile,&YY);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        Plot3D_GetBlock(N,J,Plot3DCurGrid,'J');
                                    }
                                } /* for J */

                              /* K Planes */
                              for (K = 0; K < Plot3DKDim[Plot3DCurGrid]; K++)
                                {
                                  Fetch = inset(K,Plot3DKSet);
                                  if (Fetch)
                                    {
                                      WriteN(PlotFile,ZONEMARKER);
                                      WriteN(BlckFile,ZONEMARKER);
                                      WriteN(BlckFile,0.0); /* No repeat vars */
                                      Z             = Z + 1;
                                      printf("\nZone=%-3d,  K=%ld\n",Z,K+1);
                                      /*Set Defaults*/
                                      sprintf(ZoneName[Z],"G%-3d,P%-3d ",Plot3DCurGrid+1,K+1);
                                      if (Echo) 
                                        printf("Zone Name ->%s<-\n",ZoneName[Z]);
                                      DumpString(ZoneName[Z]);
                                      /* Format = BLOCK */
                                      XX     = 0.0;
                                      WriteR(PlotFile,&XX);
                                      XX     = -1.0;           /* Zone Color */
                                      WriteR(PlotFile,&XX);
                                      IMax   = Plot3DIDim[Plot3DCurGrid];
                                      JMax   = Plot3DJDim[Plot3DCurGrid];
                                      KMax   = 1;
                                      XX     = IMax;
                                      YY     = JMax;
                                      WriteR(PlotFile,&XX);
                                      WriteR(PlotFile,&YY);
                                      YY     = KMax;
                                      WriteR(PlotFile,&YY);
                                      if (Echo)
                                        printf("Var Plane\n");
                                      else
                                        printf("Var:");
                                      for (N = 0; N < NumVars; N++)
                                        Plot3D_GetBlock(N,K,Plot3DCurGrid,'K');
                                    }
                                }
                            }
                          else
                            { /* IJK zone */
                              WriteN(PlotFile,ZONEMARKER);
                              WriteN(BlckFile,ZONEMARKER);
                              WriteN(BlckFile,0.0); /* No repeat vars */
                              Z             = Z + 1;
                              printf("\nZone=%-3d ",Z);
                              /*Set Defaults*/
                              sprintf(ZoneName[Z],"G%-3d      ",Plot3DCurGrid+1);
                              if (Echo) 
                                printf("Zone Name ->%s<-\n",ZoneName[Z]);
                              DumpString(ZoneName[Z]);
                              /* Format = BLOCK */
                              XX     = 0.0;
                              WriteR(PlotFile,&XX);
                              XX     = -1.0;           /* Zone Color */
                              WriteR(PlotFile,&XX);
                              IMax   = Plot3DIDim[Plot3DCurGrid];
                              JMax   = Plot3DJDim[Plot3DCurGrid];
                              KMax   = Plot3DKDim[Plot3DCurGrid];
                              XX     = IMax;
                              YY     = JMax;
                              WriteR(PlotFile,&XX);
                              WriteR(PlotFile,&YY);
                              YY     = KMax;
                              WriteR(PlotFile,&YY);
                              if (Echo)
                                printf("Var Plane\n");
                              else
                                printf("Var:");
                              for (N = 0; N < NumVars; N++)
                                {
                                  for (K = 0; K < Plot3DKDim[Plot3DCurGrid]; K++)
                                    Plot3D_GetBlock(N,K,Plot3DCurGrid,'K');
                                }
                            }
                        } break; /* MODE_3Dx */
                    } /* switch Plot3DMode */
                  Plot3DCurGrid++;
                } /*While CurGrid */
            }
          else
#endif /*PLOT3D*/
            {
              Z = 0;
              while (IsOk && !(feof(InFile)))
                {
                  if ((CurToken == ZONEToken) || 
                      ((Z == 0) && (CurToken == ValueToken)))
                    {
                      WriteN(PlotFile,ZONEMARKER);
                      WriteN(BlckFile,ZONEMARKER);
                      if (ZoneHeaderParsed)
                        Z++;
                      else
                        RecogZoneHeader();
                      ZoneHeaderParsed = FALSE;
                      XX = NumDupVars;
                      WriteR(BlckFile,&XX);
                      for (N=1; N <= MaxNumVars; N++)
                        if (DupVars[N])
                          {
                            XX = N;
                            WriteR(BlckFile,&XX);
                          }

                      if ((Format == FEBLOCK) || (Format == FEPOINT))
                        JJMax = 1;
                      else 
                        JJMax = JMax;
                      if (IsOk)
                        {
                          if (IEnd[Z] == 0)
                            IEnd[Z] = IMax;
                          if (JEnd[Z] == 0)
                            JEnd[Z] = JMax;
                          if (KEnd[Z] == 0)
                            KEnd[Z] = KMax;
                          if (Echo)
                            {
                              printf("IStart=%5ld, IEnd=%5ld, ISkip=%5ld, IMax=%ld\n",
                                      IStart[Z],IEnd[Z],ISkip[Z],IMax);
                              printf("JStart=%5ld, JEnd=%5ld, JSkip=%5ld, JMax=%ld\n",
                                      JStart[Z],JEnd[Z],JSkip[Z],JJMax);
                              printf("KStart=%5ld, KEnd=%5ld, KSkip=%5ld, KMax=%ld\n",
                                      KStart[Z],KEnd[Z],KSkip[Z],KMax);
                            }
                          if ((Format == BLOCK) || (Format == FEBLOCK))
                            {
                              if (!Echo)
                                printf("Var  : ");
                              fflush(stdout);
                              for (N = 1; (N <= NumVars) && IsOk; N++)
                                {
                                  if (Echo)
                                    printf("\nReading Var: %d\n",N);
                                  else
                                    printf("%3d",N);
                                  fflush(stdout);
                                  if (!DupVars[N])
                                    {
                                      if (InsertVar && (N == 1))
                                        {
                                          for (K = 1; (K <= KMax); K++)
                                          for (J = 1; (J <= JJMax); J++)
                                          for (I = 1; (I <= IMax); I++)
                                            {
                                              if ((I >= IStart[Z]) && (I <= IEnd[Z]) &&
                                                  (J >= JStart[Z]) && (J <= JEnd[Z]) &&
                                                  (K >= KStart[Z]) && (K <= KEnd[Z]) &&
                                                  ((I == IEnd[Z]) || (((I-IStart[Z]) % ISkip[Z]) == 0)) &&
                                                  ((J == JEnd[Z]) || (((J-JStart[Z]) % JSkip[Z]) == 0)) &&
                                                  ((K == KEnd[Z]) || (((K-KStart[Z]) % KSkip[Z]) == 0)))
                                                {
                                                  XX = (float)I;
                                                  WriteR(BlckFile,&XX);
                                                }
                                            }
                                        }
                                      else
                                        GetBlock(BlckFile,IStart[Z],
                                                          IEnd[Z],
                                                          ISkip[Z],
                                                          IMax,
                                                          JStart[Z],
                                                          JEnd[Z],
                                                          JSkip[Z],
                                                          JJMax,
                                                          KStart[Z],
                                                          KEnd[Z],
                                                          KSkip[Z],
                                                          KMax);
                                    }
                                }
                            }
                          else if ((IEnd[Z] != 0) && 
                                   (JEnd[Z] != 0) &&
                                   (KEnd[Z] != 0))
                            {
                              Index = 0;
                              Done  = FALSE;
                              K     = 0;
                              do
                                {
                                  K++;
                                  J = 0;
                                  do
                                    {
                                      J++;
                                      I = 0;
                                      do
                                        {
                                          I++;
                                          IndexIsGood = ((I >= IStart[Z]) && (I <= IEnd[Z]) &&
                                                         (J >= JStart[Z]) && (J <= JEnd[Z]) &&
                                                         (K >= KStart[Z]) && (K <= KEnd[Z]) &&
                                                         ((I == IEnd[Z]) || (((I-IStart[Z]) % ISkip[Z]) == 0)) &&
                                                         ((J == JEnd[Z]) || (((J-JStart[Z]) % JSkip[Z]) == 0)) &&
                                                         ((K == KEnd[Z]) || (((K-KStart[Z]) % KSkip[Z]) == 0)));

                                          if (IndexIsGood)
                                            LastI = I;
        
                                          for (N = 1; (N <= NumVars) && IsOk && !Done; N++)
                                            {
                                              if (!DupVars[N])
                                                {
                                                  IsOk = (CurToken == ValueToken);
                                                  if (InsertVar && (N == 1))
                                                    {
                                                      if (IndexIsGood)
                                                        {
                                                          XX = (float)(I-1);
                                                          WriteR(BlckFile,&XX);
                                                        }
                                                    }
                                                  else
                                                    {
                                                      if (IndexIsGood)
                                                        {
                                                          WriteR(BlckFile,&CurTValue);
                                                        }
                                                      GetToken(FALSE,TRUE,InFile);
                                                      if (Format == POINT)
                                                        Done = (CurToken != ValueToken);
                                                    }
                                                }
                                            }
                                          if (Format == FEPOINT)
                                            Done = (I == IMax);
                                          if ((++Index % 250) == 0)
                                            {
                                              putchar('.');
                                              if ((Index % 10000) == 0)
                                                {
                                                  printf("%ld\n",I);
                                                }
                                              fflush(stdout);
                                            }
                                        }
                                      while (!Done && ((IMax == LargestIndex) || (I < IMax)) && IsOk);
                                    }
                                  while (!Done && (J < JJMax) && IsOk);
                                }
                              while (!Done && (K < KMax) && IsOk);
   
                              if (N != NumVars+1)
                                IsOk = FALSE;
                              if (IsOk)
                                {
   /*Check to make sure that the correct number of values were read in*/
                                  if (Format == POINT)
                                    {
                                      if (IMax != LargestIndex)
                                        IsOk = (I == IMax) && 
                                               (J == JJMax) &&
                                               (K == KMax);
                                      else 
                                        {
                                          IsOk = ((J == JMax) && (K == KMax));
                                          if (IsOk)
                                            {
                                              if (I < IEnd[Z])
                                                IEnd[Z] = LastI;
                                            }
                                        }
                                    }
                                  if (!IsOk)
                                    printf("\nErr:  An incorrect number of variable sets (%ld) were read in for zone %ld\n",I,Z);
                                }
                              else
                                {
                                  if (CurToken == EndofFileToken)
                                    ErrMsg("Unexpected End of file",FALSE);
                                  else
                                    ErrMsg("Bad Value",TRUE);
                                }
   
                              if (IsOk && (IMax == 1) && 
                                 ((Format == POINT) || (Format == BLOCK)))
                                 WarnMsg("Non-Standard input: IMax = 1");
                            }
                          if ((Format == FEBLOCK) || 
                              (Format == FEPOINT))
                            {
                              if (DupConnect)
                                {
                                  XX = 1.0;
                                  WriteR(BlckFile,&XX);
                                }
                              else
                                {
                                  /* Do not duplicate previous zone */
                                  XX = 0.0;
                                  WriteR(BlckFile,&XX);

                                  switch (Element)
                                    {
                                      case TRIANGLE      : L = 3; break;
                                      case QUADRILATERAL : L = 4; break;
                                      case TETRAHEDRON   : L = 4; break;
                                      case BRICK         : L = 8; break;
                                    }
                                  J = 0;
                                  while ((CurToken == ValueToken) && (J < JMax))
                                    {
                                      J++;
                                      for (I = 0; I < L; I++)
                                        {
                                          if (CurToken != ValueToken)
                                            {
                                              if ((JMax == LargestIndex) &&
                                                  (I == L-1))
                                                break;
                                              else
                                                {
                                                  printf("Err: Bad or Missing FE Cell Indicies for Cell %ld\n",J+1);
                                                  CleanUp(FALSE);
                                                }
                                            }
                                          if ((CurTValue > 0) && 
                                              (CurTValue <= IMax))
                                            WriteI(BlckFile,&CurTValue);
                                          else
                                            {
                                              printf("Err: FE Cell %ld has bad index of %ld\n",J,(int)(CurTValue));
                                              CleanUp(FALSE);
                                            }
                                          GetToken(FALSE,TRUE,InFile);
                                        }
                                    }
                                  if (JMax == LargestIndex)
                                    JMax = J;
                                }
                            }
                        }
                      printf("\n");
    
                      /*Write out zone header information*/
                      DumpString(ZoneName[Z]);
                      if (OldFEMFormat)
                        XX = (float)Format + 2; 
                      else
                        XX = (float)Format;
                      WriteR(PlotFile,&XX);
                      WriteR(PlotFile,&ZoneColor);
                      IMax = 1+(IEnd[Z]-IStart[Z])/ISkip[Z];
                      if (((IEnd[Z]-IStart[Z]) % ISkip[Z]) != 0)
                        IMax++;
                      if ((Format == FEBLOCK) || (Format == FEPOINT))
                        {
                          KMax = (int)Element;
                        }
                      else
                        {
                          JMax = 1+(JEnd[Z]-JStart[Z])/JSkip[Z];
                          if (((JEnd[Z]-JStart[Z]) % JSkip[Z]) != 0)
                            JMax++;
                          KMax = 1+(KEnd[Z]-KStart[Z])/KSkip[Z];
                          if (((KEnd[Z]-KStart[Z]) % KSkip[Z]) != 0)
                            KMax++;
                        }
                      if (Echo)
                        printf("Actual Dimension Used %ld %ld %ld\n",IMax,JMax,KMax);
                      if (OldFEMFormat)
                        JMax = IMax/4;
                      XX = IMax;
                      YY = JMax;
                      ZZ = KMax;
                      WriteR(PlotFile,&XX);
                      WriteR(PlotFile,&YY);
                      WriteR(PlotFile,&ZZ);
                      if (OldFEMFormat)
                        {
                          N = 0;
                          for (L = 0; L < J; L++)
                          for (I = 0; I < 4; I++)
                            {
                              XX = ++N;
                              WriteI(BlckFile,&XX);
                            }
                        }
                    }
                  else if (CurToken == GEOMETRYToken)
                    {
                      printf("Geometry\n");
                      RecogGeometryHeader();
                      WriteN(PlotFile,GEOMMARKER);
          
                      ZZZ = (float)Mode;
                      WriteN(PlotFile,ZZZ);
                      ZZZ = (float)Scope;
                      WriteR(PlotFile,&ZZZ);
                      WriteR(PlotFile,&XX);
                      WriteR(PlotFile,&YY);
                      WriteR(PlotFile,&ZZ);
                      if ((Mode == WINDOW) &&
                          ((XX < 0.0) || (XX > 1.0) ||
                           (YY < 0.0) || (YY > 1.0)))
                        {
                          WarnMsg("WINDOW Mode geometry has starting position outside of window");
                        }
                      WriteR(PlotFile,&TGZone);
                      WriteR(PlotFile,&Color);
                      WriteR(PlotFile,&FillColor);
                      WriteR(PlotFile,&IsFilled);
                      ZZZ = (float)GeomType;
                      WriteN(PlotFile,ZZZ);
                      ZZZ = (float)LineMode;
                      WriteN(PlotFile,ZZZ);
                      if (GeomType == RECTANGLE)
                        {
                          CheckIfValue();
                          WriteR(PlotFile,&CurTValue);
                          GetToken(FALSE,TRUE,InFile);
                          CheckIfValue();
                          WriteR(PlotFile,&CurTValue);
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else if (GeomType == CIRCLE)
                        {
                          CheckIfValue();
                          WriteR(PlotFile,&CurTValue);
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else if (GeomType == ELLIPSE)
                        {
                          CheckIfValue();
                          WriteR(PlotFile,&CurTValue);
                          GetToken(FALSE,TRUE,InFile);
                          CheckIfValue();
                          WriteR(PlotFile,&CurTValue);
                          GetToken(FALSE,TRUE,InFile);
                        }
                      else if ((GeomType == LINE) ||
                               (GeomType == LINE3D))
                        {
                          if ((CurToken == ValueToken) && 
                              (CurTValue < 32000.0))
                            {
                              J = CurTValue;
                              if (J > MaxGeomSegments)
                                ErrMsg("Geometry has too many segments",TRUE);
                            }
                          else
                            ErrMsg("Bad value for Number of Polylines in Geometry",TRUE);  
                          if (Echo)
                            printf("NumSegments = %ld\n",J);
                          if (IsOk)
                            WriteR(PlotFile,&CurTValue);
    
                          GetToken(FALSE,TRUE,InFile);
                        
                          for (I = 1; (I <= J) && IsOk; I++)
                            {
                              if ((CurToken == ValueToken) && (CurTValue < 32000.0))
                                Index = CurTValue;
                              else
                                ErrMsg("Bad value for Number of points in Geometry",TRUE);  
                              if (Echo)
                                printf("NumPts = %ld\n",Index);

                              WriteR(PlotFile,&CurTValue);
                              GetToken(FALSE,TRUE,InFile);
                              if (Format == BLOCK)
                                {
                                  if (Echo)
                                    printf("Reading X\n");
                                  GetBlock(PlotFile,(LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1);
                                  if (Echo)
                                    printf("Reading Y\n");
                                  GetBlock(PlotFile,(LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    Index,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1,
                                                    (LgIndex)1);
                                  if (GeomType == LINE3D)
                                    {
                                      if (Echo)
                                        printf("Reading Z\n");
                                      GetBlock(PlotFile,(LgIndex)1,
                                                        Index,
                                                        (LgIndex)1,
                                                        Index,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1,
                                                        (LgIndex)1);
                                    }
                                }
                              else
                                {
                                  L = 0;
                                  while ((L < Index) && IsOk)
                                    {
                                      L++;
                                      if (CurToken == ValueToken)
                                        {
                                          WriteN(PlotFile,CurTValue);
                                          GetToken(FALSE,TRUE,InFile);
                                          if (CurToken == ValueToken)
                                            {
                                              YGeometryValues[L] = CurTValue;
                                              GetToken(FALSE,TRUE,InFile);
                                            }
                                          else
                                            ErrMsg("Bad value for Y Geometry",TRUE);  
                                          if (GeomType == LINE3D)
                                            {
                                              if (CurToken == ValueToken)
                                                {
                                                  ZGeometryValues[L] = CurTValue;
                                                  GetToken(FALSE,TRUE,InFile);
                                                }
                                              else
                                                ErrMsg("Bad value for Z Geometry",TRUE);  
                                            }
                                        }
                                      else
                                        ErrMsg("Bad value for X in Geometry",TRUE);  
                                    }
                                  if (IsOk)
                                    {
                                      for (L = 1; L <= Index; L++)
                                        WriteN(PlotFile,YGeometryValues[L]);
                                      if (GeomType == LINE3D)
                                        for (L = 1; L <= Index; L++)
                                          WriteN(PlotFile,ZGeometryValues[L]);
                                    }
                                }
                            }
                        }
                    }
                  else if (CurToken == TEXTToken)
                    {
                      RecogTextHeader();
                      if (IsOk)
                        {
                          printf("Text\n");
                          WriteN(PlotFile,TEXTMARKER);
                          ZZZ = (float)Mode;
                          WriteN(PlotFile,ZZZ);
                          ZZZ = (float)Scope;
                          WriteR(PlotFile,&ZZZ);
                          WriteR(PlotFile,&XX);
                          WriteR(PlotFile,&YY);
                          if ((Mode == WINDOW) &&
                              ((XX < 0.0) || (XX > 1.0) ||
                               (YY < 0.0) || (YY > 1.0)))
                            {
                              WarnMsg("WINDOW Mode Text has starting position outside of window");
                            }
                          WriteR(PlotFile,&Font);
                          WriteR(PlotFile,&Height);
                          WriteR(PlotFile,&BoxType);
                          WriteR(PlotFile,&BoxMargin);
                          WriteR(PlotFile,&BoxOutlineColor);
                          WriteR(PlotFile,&BoxFillColor);
                          WriteR(PlotFile,&Angle);
                          WriteR(PlotFile,&TGZone);
                          WriteR(PlotFile,&Color);
                          TextLength = strlen(Title);
                          WriteN(PlotFile,(float)TextLength);
                          for (I = 0; I < TextLength; I++)
                            WriteN(PlotFile,(float)Title[I]);
                        }
                    }
                  else if (CurToken == CUSTOMLABELToken)
                    {
                      RecogCustomLabelHeader();
                      if (IsOk)
                        {
                          printf("Customlabel set\n");
                          WriteN(PlotFile,CUSTOMLABELMARKER);
                          ZZZ = (float)NumCustomLabels;
                          WriteN(PlotFile,ZZZ);
                          for (I = 0; I < NumCustomLabels; I++)
                            DumpString(CustomLabel[I]);
                        }
                      else
                        ErrMsg("Invalid Axis Label Record\n",TRUE);
                    }
                  else
                    {
                      WarnMsg("Expecting Record Marker, Skipping current line...");
                      GetNextLine(InFile);
                      LinePos = 0;
                      GetToken(FALSE,TRUE,InFile);
                    }
                } /* non plot3d while */
            } /* Else */
        }
    } 

  if (IsOk)
    {
      printf("\n\n");
      WriteN(PlotFile,EOHMARKER);

      fclose(BlckFile);

#ifndef DOS
      BlckFile = fopen(BlckFName,"r");
#endif
#if defined(DOS)
      BlckFile = fopen(BlckFName,"rb");
#endif


      while (fread(buf,4,1,BlckFile))
        {
          if (fwrite(buf,4,1,PlotFile) < 1)
            BadWrite();
        }

    }

  CleanUp(IsOk);

  if (NumWarns > 0)
    printf("\nWarnings issued: %d\n",NumWarns);

#if defined PLOT3D
  if (Plot3DBadBlockCount)
    printf("\nMarker Blocks encountered = %ld\n\n",Plot3DBadBlockCount);
#endif
}


/*
BINARY FILE FORMAT:
-----------------------------------------------------------------------
The binary Datafile format (as produced by the preplot) is 
described below.


The binary datafile has two main sections.  A header section and a data
section.


         +----------------+
         | HEADER SECTION |
         +----------------+
         +---------+
         |357.0    |               1-WORD of value 357 (See below)
         +---------+
         +----------------+
         | DATA SECTION   |
         +----------------+





Each WORD represents a single 32-bit real value.
Each IWORD represents a single 32-bit integer value.


I.  The header section.

    The header section contains The version number of the file, a title
    of the file, the names of the varialles to be plotted, the 
    descriptions of all zones to be read in and all text and geometry 
    definitions.  

     i.  Version number, title and variable names.
         +--------+
         | 1-WORD |       Value representing the version
         +--------+       of the input file.  The format for these
                          instructions is version 6.3

         +--------+
         |N-WORDS |       The TITLE. (See note 1.)
         +--------+   

         +--------+
         | 1-WORD |       Number of variables (NumVar) in the datafile.
         +--------+       

         +--------+
         | N-WORDS|       Variable names.  N = sum of lengths. (See note 1.)
         +--------+       
                   
     ii.  Zones  
         +--------+
         | 299.0  |       Zone marker.
         +--------+       
         +--------+
         |N-WORDS |       Zone name. (See note 1.)
         +--------+       
         +--------+
         | 1-WORD |       Format, 0=BLOCK 1=POINT 2=FEBLOCK 3=FEPOINT
         +--------+       (See note 2.)
         +--------+
         | 1-WORD |       Zone Color (set to -1 if you want tecplot to
         +--------+       determine).
         +--------+
         | 3-WORDS|       IMax,JMax,KMax (See notes 2 and 3.)
         +--------+       
    iii.  Geometries
         +--------+
         | 399.0  |       Geometry marker.
         +--------+       
         +--------+
         | 1-WORD |       Mode, 1=WINDOW 0=Grid (See note 2.)
         +--------+       
         +--------+
         | 1-WORD |       Group (Use 1.0 )
         +--------+       
         +--------+
         | 3-WORDS|       X,Y,Z Starting Location 
         +--------+       
         +--------+
         | 1-WORD |       Zone (0=all)
         +--------+       
         +--------+
         | 1-WORD |       Color
         +--------+       
         +--------+
         | 1-WORD |       FillColor
         +--------+       
         +--------+
         | 1-WORD |       IsFilled (0=no 1=yes)
         +--------+       
         +--------+
         | 1-WORD |       GeometryType  0=Line, 1=Rectangle 2=Circle,
         +--------+                     3=ellipse, 4=3DLine,
         +--------+
         | 1-WORD |       LineType  0=Solid 1=Dashed 2=DashDot 3=Dotted
         +--------+       


If the geometry type is line or 3dline then:
         +--------+
         | 1-WORD |       Number of polylines
         +--------+       
         +--------+
         | 1-WORD |       Number of points, line 1.
         +--------+       
         +--------+
         | N-WORDS|       X-block geometry points N=NumPts
         +--------+       
         +--------+
         | N-WORDS|       Y-block geometry points N=NumPts
         +--------+       
         +--------+
         | N-WORDS|       Z-block geometry points N=NumPts (3dLine Only)
         +--------+       
             .
             .
             .

If the geometry type is Rectangle then
         +--------+
         | 2-WORDS|       X and Y offset for far corner of rectangle
         +--------+       

If the geometry type is Circle then
         +--------+
         | 1-WORD |       Radius
         +--------+       

If the geometry type is Ellipse then
         +--------+
         | 2-WORDS|       X and Y Radii
         +--------+       


    iv.   Text
         +--------+
         | 499.0  |       Text marker.
         +--------+       
         +--------+
         | 1-WORD |       Mode, 1=WINDOW 0=Grid
         +--------+       
         +--------+
         | 1-WORD |       Group
         +--------+       
         +--------+
         | 2-WORDS|       X,Y Starting Location
         +--------+       
         +--------+
         | 2-WORDS|       Width,Height of characters
         +--------+       
         +--------+
         | 1-WORD |       Text Box type 0=NoBox 1=Hollow 2=Filled
         +--------+       
         +--------+
         | 1-WORD |       Text Box Margin
         +--------+       
         +--------+
         | 1-WORD |       Text Box Outline Color
         +--------+       
         +--------+
         | 1-WORD |       Text Box Fill Color
         +--------+       
         +--------+
         | 1-WORD |       Angle
         +--------+       
         +--------+
         | 1-WORD |       Zone (0=all)
         +--------+       
         +--------+
         | 1-WORD |       Color
         +--------+
         +--------+
         | 1-WORD |       Text Length
         +--------+       
         +--------+
         | N-WORDS|       Text.  N=Text Length
         +--------+       

     v.  CustomLabel
         +--------+
         | 599.0  |       CustomLabel Marker;
         +--------+       
         +--------+
         | 1-WORD |       Number of labels labels
         +--------+       
         +--------+
         | N-WORDS|       Text for label 1.  See note 1.
         +--------+       
         +--------+
         | N-WORDS|       Text for label 2.  See note 1.
         +--------+       
             .
             .
             .
         +--------+
         | N-WORDS|       Text for label NumLabels.  See note 1.
         +--------+       

II.  Data section
     The data section contains all of the data associated with the
     zone definitions in the header.  

     i.  zones
         +--------+
         | 299.0  |       Zone marker
         +--------+       
         +--------+
         | 1-WORD |       Number of repeat vars.
         +--------+       
         +--------+
         | N-WORDS|       variable numbers to repeat.  N=Number of
         +--------+       variables to repeat.
         +--------+
         | N-WORDS|       Zone Data N=Numvars*IMax*JMax.  This is 
         +--------+       as per the format specified in zone header 
                          above.

     ii. fem zones
         +--------+
         | 299.0  |       Zone marker
         +--------+       
         +--------+
         | 1-WORD |       Number of repeat vars.
         +--------+       
         +--------+
         | N-WORDS|       variable numbers to repeat.  N=Number of
         +--------+       variables to repeat.
         +--------+
         | N-WORDS|       Zone Data N=Numvars*IMax.  This is in 
         +--------+       format specified in zone header above.
         +--------+
         | 1-WORD |       Repeat adjacency list from previous zone.
         +--------+       1=yes, 0=no
         +--------+
         |N-IWORDS|       Zone Data N=L*JMax.  This represents
         +--------+       JMax sets of adjacency indicies where each
                          set contains L values where L is 
                          3 for TRIANGLES
                          4 for QUADRILATERALS
                          4 for TETRAHEDRONS
                          8 for BRICKS




NOTES:

1.  All character data is represented by real values.

     Example:  The letter "A" has an ASCII value of 65.  The WORD
               written to the data file for the letter "A" is then
               65.0.
               In fortran this could be done by doing the following:

               REAL R
               .
               .
               R = ICHAR('A');

               WRITE(10) R


    All character strings except for the text titles in text records
    are null terminated (i.e. terminated by a zero value)

2.  All Integer values are represented by real values.
    (e.g. 1 becomes 1.0).


3.  In FE Data I = Number of points, J = Number of elements, and
    K = Element type where:

    0 = Triangles;
    1 = Quadrilaterals;
    2 = Tetrahedrons.
    3 = Bricks.




Example: Convert the  folloing line plot data into binary format.

    X     Y
-------------
   0.0    0.0
   1.0    0.5
   2.0    1.0
   3.0    1.0
   4.0    1.5


         +--------+
         | 6.3    |        Version = 6.3
         +--------+
         +--------+     
         | 0.0    |        Null title string
         +--------+    
         +--------+
         | 2.0    |       Number of variables in the datafile.
         +--------+       
         +--------+
         | 88.0   |       The letter "X"
         +--------+       
         +--------+     
         | 0.0    |       terminate X
         +--------+      
         +--------+
         | 88.0   |       The letter "Y"
         +--------+       
         +--------+     
         | 0.0    |       terminate Y
         +--------+      
         +--------+
         | 299.0  |       Zone marker.
         +--------+       
         +--------+     
         |  0.0   |       Zone name is null
         +--------+ 
         +--------+
         | 1.0    |       Format, 1=POINT 0=BLOCK (See note 2.)
         +--------+
         +--------+
         | -1.0   |       No zone color is assigned
         +--------+
         +--------+
         | 5.0    |       There are 5 data points. (IMax)
         +--------+       
         +--------+
         | 1.0    |       This is a line plot so JMax=1
         +--------+       
         +--------+
         | 1.0    |       KMax = 1
         +--------+       
         +---------+
         |357.0    |      End of header marker.
         +---------+
         +---------+
         |299.0    |      Start of zone
         +---------+
         +---------+
         |0.0      |      No repeat variables
         +---------+
         +---------+
         |0.0      |      X1
         +---------+
         +---------+
         |0.0      |      Y1
         +---------+
         +---------+
         |1.0      |      X2
         +---------+
         +---------+
         |0.5      |      Y2
         +---------+
         +---------+
         |2.0      |      X3
         +---------+
         +---------+
         |1.0      |      Y3
         +---------+
         +---------+
         |3.0      |      X4
         +---------+
         +---------+
         |1.0      |      Y4
         +---------+
         +---------+
         |4.0      |      X5
         +---------+
         +---------+
         |1.5      |      Y5
         +---------+

*/
