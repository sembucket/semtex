///////////////////////////////////////////////////////////////////////////////
// element.C: 2D spectral element class routines.
//
// Copyright (C) 1994, 1999 Hugh Blackburn
//
// $Id$
///////////////////////////////////////////////////////////////////////////////

#include <Sem.h>


Element::Element (const integer i,
		  const Mesh*   M,
		  const real*   z,
		  const integer n) :
// ---------------------------------------------------------------------------
// Create a new quad element, n x n.  Node spacing along any side
// generated by mapping z (defined on domain [-1, 1], np points) onto
// side.
//
// Compute information for internal storage, and economise.
// ---------------------------------------------------------------------------
  id   (i),
  np   (n),
  npnp (np * np),
  next (4 * (np - 1)),
  nint (npnp - next)
{
  const char routine[] = "Element::Element";

  if (np < 2) message (routine, "need > 2 knots for element edges", ERROR);

  Femlib::buildMaps (np, 2, &emap, &pmap);
  
  xmesh = new real [(size_t) npnp];
  ymesh = new real [(size_t) npnp];
  
  M -> meshElmt (id, np, z, xmesh, ymesh);
  
  Femlib::adopt (npnp, &xmesh);
  Femlib::adopt (npnp, &ymesh);
 
  map();
}


Element::~Element ()
// ---------------------------------------------------------------------------
// Clean up internal storage using Femlib family routines.
// ---------------------------------------------------------------------------
{
  Femlib::abandon (&xmesh);
  Femlib::abandon (&ymesh);

  Femlib::abandon (&drdx );
  Femlib::abandon (&dsdx );
  Femlib::abandon (&drdy );
  Femlib::abandon (&dsdy );

  Femlib::abandon (&G1   );
  Femlib::abandon (&G2   );
  Femlib::abandon (&G3   );
  Femlib::abandon (&G4   );
  Femlib::abandon (&delta);
}


void Element::map ()
// ---------------------------------------------------------------------------
// Generate geometric factors associated with mapping from 2D Cartesian to
// isoparametrically-mapped space:
//
//   dxdr, dydr, = dx/dr,  dy/dr,  "Forward Partials"
//   dxds, dyds, = dx/ds,  dy/ds.
//   drdx, drdy, = dr/dx,  dr/dy,  "Inverse Partials"
//   dsdx, dsdy, = ds/dx,  ds/dy.
//   jac         = dx/dr * dy/ds - dx/ds * dy/dr.
//
// The following relationships are used, where
//
//   IN[j][k] = h_k (x_j) is a Lagrangian interpolant matrix operator, and
//   DV[j][k] = h'_k(x_j) is a Lagrangian derivative  matrix operator,
//
// [ IT = transpose(IN), DT = transpose(DV) ]:
//
//   [dxdr] = [IN][X][DT];    [dydr] = [IN][Y][DT],
//   [dxds] = [DV][X][IT];    [dyds] = [DV][Y][IT].
//
// For a Gauss--Legendre quadrature rule, the inverse partials and
// mass matrix are returned for spatial locations at the mesh nodes,
// while the forward partials and other geometric factors are for
// spatial locations at the quadrature points.  In general, the amount
// of storage allocated for forward and inverse partials differ.
//
// For Lobatto--Legendre rule, everything is at the nodes, hence the
// interpolant matrices are identities.
// 
// The inverse partials are retained in Element storage, to be used in
// element gradient operations (e.g. dP/dx = dP/dr * dr/dx + dP/ds *
// ds/dx) while the forward partials are retained in scrambled form
// (in combination with quadrature weights) as "geometric factors"
// G1--G4, to be used in element quadrature operations.  For
// cylindrical geometries, G1--G4 are multiplied by y (i.e. r) as a
// consequence of the fact that Helmholtz equations are symmetrized by
// premultiplication by this factor for cylindrical coords.
//
// The local length-scale, delta, is a measure of the size of the local
// mesh length: delta = sqrt{(dx^2 + dy^2 + dz^2)/3}
//                    ~ sqrt{([dr^2 + ds^2]*jac + dz^2)/3)}
// or modified as appropriate for cylindrical cases and 2D.
//
// Null-mapping optimizations mentioned below occur when the element
// geometry ensures that the entries of a vector are zero to within
// roundoff, due either to the edges of elements being aligned with
// coordinate axes (as can happen for the inverse partials) or if the
// element is an undistorted (but possibly rotated) rectangle (this
// applies to G3).  In these cases the associated memory is deleted
// and the pointers are set to zero, so they can serve as flags in
// subsequent computations.
// ---------------------------------------------------------------------------
{
  const char   routine[] = "Element::map";
  const real   EPS  = 4 * ((sizeof(real) == sizeof(double)) ? EPSDP : EPSSP);
  const real   dz   = Femlib::value ("TWOPI / (BETA * N_Z)");
  const real   dxy  = 2.0 * sqr (2.0 / (np - 1));
  const real   invD = 1.0 / Geometry::nDim();
  const real   *x   = xmesh, *y = ymesh;
  const real   **DV, **DT, *w;
  char         err[StrMax];
  real         *jac, *dxdr, *dxds, *dydr, *dyds, *tV, *WW;

  vector<real> work;

  // -- Permanent/family allocations.
  
  drdx  = new real [(size_t) npnp];
  dsdx  = new real [(size_t) npnp];
  drdy  = new real [(size_t) npnp];
  dsdy  = new real [(size_t) npnp];
  G1    = new real [(size_t) npnp];
  G2    = new real [(size_t) npnp];
  G3    = new real [(size_t) npnp];
  G4    = new real [(size_t) npnp];
  delta = new real [(size_t) npnp];
    
  // -- Temporaries.

  work.setSize (7 * npnp);

  dxdr = work();
  dxds = dxdr + npnp;
  dydr = dxds + npnp;
  dyds = dydr + npnp;

  jac  = dyds + npnp;
  WW   = jac  + npnp;
  tV   = WW   + npnp;
    
  Femlib::quad (LL, np, np, 0, 0, &w, 0, 0, &DV, &DT);
  Veclib::zero (npnp, WW, 1);
  Blas::ger    (np, np, 1.0, w, 1, w, 1, WW, np);
    
  Blas::mxm (  x, np, *DT, np, dxdr, np);
  Blas::mxm (*DV, np,   x, np, dxds, np);
  Blas::mxm (  y, np, *DT, np, dydr, np);
  Blas::mxm (*DV, np,   y, np, dyds, np);
    
  Veclib::vmul  (npnp,        dxdr, 1, dyds, 1, tV,  1);
  Veclib::vvvtm (npnp, tV, 1, dxds, 1, dydr, 1, jac, 1);
    
  if (jac[Veclib::imin (npnp, jac, 1)] < EPS) {
    sprintf (err, "jacobian of element %1d nonpositive", id + 1);
    message (routine, err, ERROR);
  }
    
  Veclib::vmul  (npnp, dyds, 1, dyds, 1, tV, 1);
  Veclib::vvtvp (npnp, dxds, 1, dxds, 1, tV, 1, G1, 1);
  Veclib::vdiv  (npnp, G1,   1, jac,  1, tV, 1);
  Veclib::vmul  (npnp, tV,   1, WW,   1, G1, 1);
    
  Veclib::vmul  (npnp, dydr, 1, dydr, 1, tV, 1);
  Veclib::vvtvp (npnp, dxdr, 1, dxdr, 1, tV, 1, G2, 1);
  Veclib::vdiv  (npnp, G2,   1, jac,  1, tV, 1);
  Veclib::vmul  (npnp, tV,   1, WW,   1, G2, 1);
    
  Veclib::vmul  (npnp, dydr, 1, dyds, 1, tV,   1);
  Veclib::neg   (npnp, tV,   1);
  Veclib::vvvtm (npnp, tV,   1, dxdr, 1, dxds, 1, G3, 1);
  Veclib::vdiv  (npnp, G3,   1, jac,  1, tV,   1);
  Veclib::vmul  (npnp, tV,   1, WW,   1, G3,   1);
  
  Veclib::vmul  (npnp, jac,  1, WW,   1, G4, 1);
  Veclib::smul  (npnp, dxy,  jac, 1,  delta, 1);

  Veclib::copy (npnp, dyds, 1, drdx, 1);
  Veclib::vneg (npnp, dxds, 1, drdy, 1);
  Veclib::vneg (npnp, dydr, 1, dsdx, 1);
  Veclib::copy (npnp, dxdr, 1, dsdy, 1);
    
  Veclib::vdiv (npnp, drdx, 1, jac, 1, drdx, 1);
  Veclib::vdiv (npnp, drdy, 1, jac, 1, drdy, 1);
  Veclib::vdiv (npnp, dsdx, 1, jac, 1, dsdx, 1);
  Veclib::vdiv (npnp, dsdy, 1, jac, 1, dsdy, 1);

  if (Geometry::nDim() == 3) {
    if (Geometry::system() == Geometry::Cylindrical)
      Veclib::smul (npnp, dz, ymesh, 1, tV, 1);
    else
      Veclib::fill (npnp, dz, tV, 1);
    Veclib::vmul (npnp, tV, 1, tV, 1, tV, 1);
    Veclib::vadd (npnp, tV, 1, delta, 1, delta, 1);
  }
  Blas::scal    (npnp, invD,     delta, 1);
  Veclib::vsqrt (npnp, delta, 1, delta, 1);

  if (Geometry::system() == Geometry::Cylindrical) {
    Veclib::vmul (npnp, G1, 1, y, 1, G1, 1);
    Veclib::vmul (npnp, G2, 1, y, 1, G2, 1);
    Veclib::vmul (npnp, G3, 1, y, 1, G3, 1);
    Veclib::vmul (npnp, G4, 1, y, 1, G4, 1);
  } 

  // -- Calculations are done.  Do null-mapping optimizations.
  
  if (Blas::nrm2 (npnp, drdx, 1) < EPS) { delete [] drdx; drdx = 0; }
  if (Blas::nrm2 (npnp, drdy, 1) < EPS) { delete [] drdy; drdy = 0; }
  if (Blas::nrm2 (npnp, dsdx, 1) < EPS) { delete [] dsdx; dsdx = 0; }
  if (Blas::nrm2 (npnp, dsdy, 1) < EPS) { delete [] dsdy; dsdy = 0; }
  if (Blas::nrm2 (npnp, G3,   1) < EPS) { delete [] G3;   G3   = 0; }

  // -- Check for family redundancies.

  Femlib::adopt (npnp, &drdx );
  Femlib::adopt (npnp, &drdy );
  Femlib::adopt (npnp, &dsdx );
  Femlib::adopt (npnp, &dsdy );
  Femlib::adopt (npnp, &G1   );
  Femlib::adopt (npnp, &G2   );
  Femlib::adopt (npnp, &G3   );
  Femlib::adopt (npnp, &G4   );
  Femlib::adopt (npnp, &delta);
}


void Element::bndryDsSum (const integer* btog,
			  const real*    src ,
			  real*          tgt ) const
// ---------------------------------------------------------------------------
// Direct-stiffness-sum from element boundary to globally-numbered
// storage, i.e. tgt[btog[i]] += mass[emap[i]] * src[emap[i]].  This
// is using in smoothing Fields along element boundaries.
// ---------------------------------------------------------------------------
{
  register integer  i, e;
  register real     w;
  static const real EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  static const int  CYL = Geometry::system() == Geometry::Cylindrical;

  if (CYL)
    for (i = 0; i < next; i++) {
      e = emap[i];
      w = G4  [e];
      tgt[btog[i]] += (w > EPS) ? w * src[e] : src[e];
    }
  else
    for (i = 0; i < next; i++) {
      e = emap[i];
      tgt[btog[i]] += G4[e] * src[e];
    }
}


void Element::bndryMask (const integer* bmsk,
			 real*          tgt ,
			 const real*    src ,
			 const integer* btog) const
// ---------------------------------------------------------------------------
// Mask the values in (row-major) tgt according to the mask vector
// bmsk and optionally globally-numbered vector src.
//
// If src is non-zero, it is used with boundary-to-global mapping
// vector btog to impose values within tgt on locations where bmsk is
// non-zero; other locations are unaffected.
//
// If src is zero, then the values within tgt where bmsk is zero are
// set to zero (i.e. tgt itself is taken as the source).  Btog is then
// not used and may be zero also.
// ---------------------------------------------------------------------------
{
  register integer i, e;

  if (src) {
    for (i = 0; i < next; i++) {
      e = emap[i];
      tgt[e] = (bmsk[i]) ? src[btog[i]] : tgt[e];
    }

  } else {
    vector<real>   work (npnp);
    register real* tmp = work();

    Veclib::gathr (npnp, tgt, emap, tmp);
    for (i = 0; i < next; i++)
      tmp[i] = (bmsk[i]) ? tmp[i] : 0.0;
    Veclib::zero  (nint, tmp + next, 1);
    Veclib::gathr (npnp, tmp, pmap, tgt);
  }
}


void Element::bndryInsert (const integer* b2g,
			   const real*    src,
			   real*          tgt) const
// ---------------------------------------------------------------------------
// Load values from globally-numbered src around periphery of element
// tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (next, src, b2g, emap, tgt);
}

       
void Element::e2g (const real*    src     ,
		   const integer* btog    ,
		   real*          external,
		   real*          internal) const
// ---------------------------------------------------------------------------
// Load values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (next, src, emap, btog, external);
  if (internal) Veclib::gathr (nint, src, emap + next, internal);
}


void Element::e2gSum (const real*    src     ,
		      const integer* btog    ,
		      real*          external,
		      real*          internal) const
// ---------------------------------------------------------------------------
// Sum values from element storage src into (globally-numbered)
// external & internal partitions of vector.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr_sum (next, src, emap,  btog, external);
  if (internal) Veclib::gathr_sum (nint, src, emap + next, internal);
}


void Element::g2e (real*          tgt,
		   const integer* btog,
		   const real*    external,
		   const real*    internal) const
// ---------------------------------------------------------------------------
// From (globally-numbered) external & internal partitons of vector,
// load into elemnt storage tgt.
// ---------------------------------------------------------------------------
{
  Veclib::gathr_scatr (next, external, btog,  emap, tgt);
  if (internal) Veclib::scatr (nint, internal, emap + next, tgt);
}


void Element::e2gSumSC (real*          F   ,
			const integer* btog,
			real*          tgt ,
			const real*    hbi ) const
// ---------------------------------------------------------------------------
// Create statically-condensed boundary Helmholtz forcing for this
// element from row-major F and insert it into globally-numbered tgt
// by direct stiffness summation.
//
// NB: forcing, F, is modified.
//
// On entry, F contains the elemental weak boundary-constrained forcing
//   - M f - H g.
//
// Elemental storage is then sorted in F so that it is ordered with boundary
// nodes foremost, i.e. it contains the partition { F | F }.
//                                                   b   i
//
// Statically-condensed boundary forcing is created in the first partition:
//                       -1                         -1
//   F   <--   F  -  h  h   F           (matrix h  h   supplied as hbi)
//    b         b     bi ii  i                   bi ii
//
// and summed into the tgt vector.  In the summation, there is no need
// to check if the global node is to be solved for or is fixed, since
// the fixed (essential-BC) partition of tgt is overwritten later.
//
// NB: scatr_sum is broken for self-periodic elements on vector machines!
// ---------------------------------------------------------------------------
{
  vector<real> work (npnp);

  Veclib::gathr (npnp, F, emap, work());
  Veclib::copy  (npnp, work(), 1, F, 1);

  if (nint) Blas::gemv ("T", nint,next, -1.0, hbi,nint, F + next,1, 1.0, F,1);

  Veclib::scatr_sum (next, F, btog, tgt);
}


void Element::g2eSC (const real*    RHS ,
		     const integer* btog,
		     real*          F   , 
		     real*          tgt ,
		     const real*    hbi ,
		     const real*    hii ,
		     real*          work) const
// ---------------------------------------------------------------------------
// Complete static condensation solution for internal values of Element.
//
// On entry, global-node solution values are in RHS and F contains the
// weak form of internal forcing in its top end (as installed by
// e2gSumSC).
//
// If u is current Element, compute internal solution according to:
//            -1      -1
//   u  <--  h  F  - h  h   u
//    i       ii i    ii ib  b
//
// Input vector work has length nTot().  F is overwritten during
// processing.
// ----------------------------------------------------------------------------
{
  // -- Load globally-numbered RHS into element-boundary storage.

  Veclib::gathr (next, RHS,  btog, work);
  Veclib::scatr (next, work, emap, tgt );

  // -- Complete static-condensation solution for element-internal storage.

  if (nint) {
    real* Fi   = F    + next;
    real* wint = work + next;

    Veclib::copy  (nint, Fi, 1, wint, 1);
    Blas::gemv    ("T", nint, nint,  1.0, hii, nint, wint, 1, 0.0, Fi, 1);
    Blas::gemv    ("N", nint, next, -1.0, hbi, nint, work, 1, 1.0, Fi, 1);
    Veclib::scatr (nint, Fi, emap + next, tgt);
  }
}


void Element::HelmholtzSC (const real lambda2,
			   const real betak2 ,
			   real*      hbb    ,
			   real*      hbi    ,
			   real*      hii    ,
			   real*      rmat   ,
			   real*      rwrk   ,
			   integer*   iwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix and return the
// statically condensed form in hbb, the interior-exterior coupling
// matrix in hbi, and the interior resolution matrix factor in hii.
//
// lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Uncondensed System   -->   Statically condensed form returned in hbb.
//
//                                                           -1
//  +---------+------+       +---------+    +------+  +------+  +---------+
//  |         |      |       |         |    |      |  |      |  |         |
//  |         |      |       |         |    |      |  | hii  |  |   hib   |
//  |   hbb   | hbi  |  -->  |   hbb   | -  | hbi  |  |      |  |         |
//  |         |      |       |         |    |      |  +------+  +---------+
//  |         |      |       |         |    |      |
//  +---------+------+       +---------+    +------+
//  |         |      |
//  |   hib   | hii  |
//  |         |      |
//  +---------+------+
//
// Element matrices are built row-by-row, sorted to place entries for
// internal nodes first, posted into local partitions.  Then the
// internal resolution matrix hii is factorized and the static
// condensation completed.  In addition, the interior-exterior
// partition hbi is postmultiplied by hii(inverse) for convenience in
// the resolution stage.
//
// hbb:    nExt  by nExt    matrix;  (row-major 1D storage).
// hbi:    nExt  by nInt    matrix;  (row-major 1D storage).
// hii:    nInt  by nInt    matrix;  (row-major 1D storage).
// rmat:   nKnot by nKnot   matrix;  (row-major 1D storage).
// rwrk:   nExt*(nExt+nInt) vector.
// iwrk:   nInt             vector.
// ---------------------------------------------------------------------------
{
  const char       routine[] = "Element::HelmholtzSC";
  register integer i, j, eq, info, ij = 0;
  const real       **DV, **DT;

  // -- Construct hbb, hbi, hii partitions of elemental Helmholtz matrix.

  Femlib::quad (LL, np, np, 0, 0, 0, 0, 0, &DV, &DT);

  for (i = 0; i < np; i++)
    for (j = 0; j < np; j++, ij++) {

      helmRow (DV, DT, lambda2, betak2, i, j, rmat, rwrk);

      Veclib::gathr (npnp, rmat, emap, rwrk);

      if ( (eq = pmap[ij]) < next ) {
	Veclib::copy (next, rwrk,        1, hbb + eq * next, 1);
	Veclib::copy (nint, rwrk + next, 1, hbi + eq * nint, 1);
      } else
	Veclib::copy (nint, rwrk + next, 1, hii + (eq - next) * nint, 1);
    }

  // -- Static condensation.

  if (nint) {

    Lapack::getrf (nint, nint, hii, nint, iwrk, info);
    if (info) message (routine, "matrix hii has singular factor", ERROR);

#if defined(DEBUG)
  if ((integer) Femlib::value ("VERBOSE") > 3) printMatSC (hbb, hbi, hii);
#endif

    Lapack::getri (nint, hii, nint, iwrk, rwrk, nint*next, info);
    if (info) message (routine, "matrix hii is singular",         ERROR);

    Blas::gemm   ("N","N",nint,next,nint, 1.0,hii,nint,hbi,nint,0.0,rwrk,nint);
    Blas::gemm   ("T","N",next,next,nint,-1.0,hbi,nint,rwrk,nint,1.0,hbb,next);
    Veclib::copy (nint*next, rwrk, 1, hbi, 1);
  }
}


void Element::printMatSC (const real* hbb,
			  const real* hbi,
			  const real* hii) const
// ---------------------------------------------------------------------------
// (Debugging) utility to print up element matrices.
// ---------------------------------------------------------------------------
{
  integer i, j;

  cout << "-- Helmholtz matrices, element " << id << endl;

  cout << "-- hbb:" << endl;

  cout.precision(3);

  for (i = 0; i < next; i++) {
    for (j = 0; j < next; j++)
      cout << setw (10) << hbb[Veclib::row_major (i, j, next)];
    cout << endl;
  }

  cout << "-- hii:" << endl;

  for (i = 0; i < nint; i++) {
    for (j = 0; j < nint; j++)
      cout << setw (10) << hii[Veclib::row_major (i, j, nint)];
    cout << endl;
  }

  cout << "-- hbi:" << endl;

  for (i = 0; i < next; i++) {
    for (j = 0; j < nint; j++)
      cout << setw (10) << hbi[Veclib::row_major (i, j, nint)];
    cout << endl;
  }

  cout.precision(6);
}


void Element::Helmholtz (const real lambda2,
			 const real betak2 ,
			 real*      h      ,
			 real*      rmat   ,
			 real*      rwrk   ) const
// ---------------------------------------------------------------------------
// Compute the discrete elemental Helmholtz matrix, return in h.
//
// This routine can be used when static condensation is not employed,
// and is included mainly to ease checking of entire element matrices.
// Node ordering produced is row-major.
//
// h:    vector, length np*np*np*np;
// rmat: vector, length np*np;
// ---------------------------------------------------------------------------
{
  const real       **DV, **DT;
  register integer ij = 0;

  Femlib::quad (LL, np, np, 0, 0, 0, 0, 0, &DV, &DT);

  for (register integer i = 0; i < np; i++)
    for (register integer j = 0; j < np; j++, ij++) {
      helmRow      (DV, DT, lambda2, betak2, i, j, rmat, rwrk);
      Veclib::copy (npnp, rmat, 1, h + ij * np, 1);
    }
}


void Element::HelmholtzDg (const real lambda2,
			   const real betak2 ,
			   real*      diag   ,
			   real*      work   ) const
// ---------------------------------------------------------------------------
// Create the diagonal of the elemental Helmholtz matrix in diag.  The
// diagonal is sorted in emap order: i.e., boundary nodes are first.
//
// Input vector diag must be nTot() long, work must be Ntot() +
// nKnot() long.  Construction is very similar to that in helmRow
// except that m, n = i, j.
// ---------------------------------------------------------------------------
{
  static const real EPS  = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  static const int  CYL = Geometry::system() == Geometry::Cylindrical;
  const real**      DT;
  register integer  i, j, ij;
  register real     *dg = work, *tmp = work + npnp;
  real              r2, HCon;

  Femlib::quad (LL, np, np, 0, 0, 0, 0, 0, 0, &DT);

  if (CYL) {
    for (ij = 0, i = 0; i < np; i++)
      for (j = 0; j < np; j++, ij++) {
	r2   = sqr (ymesh[Veclib::row_major (i, j, np)]);
	HCon = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	Veclib::vmul (np, DT[j], 1, DT[j], 1, tmp, 1);
	dg[ij] = Blas::dot   (np, G1 + i*np, 1, tmp, 1);
	Veclib::vmul (np, DT[i], 1, DT[i], 1, tmp, 1);
	dg[ij] += Blas::dot   (np, G2 + j,   np, tmp, 1);
	if (G3)
	  dg[ij] += 2.0 * G3[Veclib::row_major (i, j, np)] * DT[j][j]*DT[i][i];
	dg[ij] += HCon  * G4[Veclib::row_major (i, j, np)];
      }
  } else {
    HCon = lambda2 + betak2;
    for (ij = 0, i = 0; i < np; i++)
      for (j = 0; j < np; j++, ij++) {
	Veclib::vmul (np, DT[j], 1, DT[j], 1, tmp, 1);
	dg[ij]  = Blas::dot   (np, G1 + i*np, 1, tmp, 1);
	Veclib::vmul (np, DT[i], 1, DT[i], 1, tmp, 1);
	dg[ij] += Blas::dot   (np, G2 + j,   np, tmp, 1);
	if (G3)
	  dg[ij] += 2.0 * G3[Veclib::row_major (i, j, np)] * DT[j][j]*DT[i][i];
	dg[ij] += HCon  * G4[Veclib::row_major (i, j, np)];
      }
  }

  Veclib::gathr (npnp, work, emap, diag);
}


void Element::helmRow (const real**  DV     ,
		       const real**  DT     ,
		       const real    lambda2,
		       const real    betak2 ,
		       const integer i      ,
		       const integer j      ,
		       real*         hij    ,
		       real*         work   ) const
// ---------------------------------------------------------------------------
// Build row [i,j] of the elemental Helmholtz matrix in array hij (np x np).
//
// Lambda2 is the Helmholtz constant, betak2 is the Fourier constant.
//
// Input array work should be at least np long.
//
// For a 2D tensor product form, the elemental Helmholtz matrix is produced
// as (sums on p & q indices assumed):
//
// h      = G1  IN  DT  IN  DT     \
//  ij mn     pq  pi  jq  pm  nq   |
//        + G2  DV  IT  DV  IT     |
//            pq  pi  jq  pm  nq   |
//        + G3  DV  IT  IN  DT      >                              "STIFFNESS"
//            pq  pi  jq  pm  nq   |
//        + G3  IN  DT  DV  IT     |
//            pq  pi  jq  pm  nq   /
//                
//        + G4  IN  IT  IN  IT        (k2 / sqr (r  ) + lambda2)        "MASS"
//            pq  pi  jq  pm  nq                  pq
//
// where the terms G1, G2, G3, G4 contain geometric mapping factors
// and quadrature weights, and the matrices IN, IT are the Lagrangian
// interpolation matrix (from the nodes to the quadrature points) and
// its transpose, while DV, DT are the Lagrangian derivative matrix &
// transpose.
//
// (The 1/r^2 factor in the mass matrix is only for cylindrical coordinates.)
//
// For Gauss--Lobatto--Legendre integration, the interpolant matrices
// are identities, and are not required.
// ---------------------------------------------------------------------------
{
  const real       r2   = sqr (ymesh[Veclib::row_major (i, j, np)]);
  const real       EPS  = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  const real       hCon = (Geometry::system() == Geometry::Cylindrical &&
			r2 > EPS) ? (betak2 / r2 + lambda2) : betak2 + lambda2;
  register integer m, n;

  Veclib::zero (npnp, hij, 1);

  for (n = 0; n < np; n++) {
    Veclib::vmul (np, DT[j], 1, DT[n], 1, work, 1);
    hij[Veclib::row_major (i, n, np)]  = Blas::dot (np, G1 + i*np, 1, work, 1);
  }

  for (m = 0; m < np; m++) {
    Veclib::vmul (np, DT[i], 1, DT[m], 1, work, 1);
    hij[Veclib::row_major (m, j, np)] += Blas::dot (np, G2 + j,   np, work, 1);
  }

  if (G3)
    for (m = 0; m < np; m++)
      for (n = 0; n < np; n++) {
	hij [Veclib::row_major (m, n, np)] +=
	  G3[Veclib::row_major (i, n, np)] * DV[n][j] * DV[i][m];
	hij [Veclib::row_major (m, n, np)] +=
	  G3[Veclib::row_major (m, j, np)] * DV[j][n] * DV[m][i];
      }

  hij[Veclib::row_major (i, j, np)] += G4[Veclib::row_major (i, j, np)] * hCon;
}


void Element::HelmholtzKern (const real lambda2,
			     const real betak2 ,
			     real*      R      ,
			     real*      S      ,
			     real*      src    ,
			     real*      tgt    ) const 
// ---------------------------------------------------------------------------
// Apply kernel of elemental discrete Helmholtz operator on src to make tgt
// (if required, these can be the same storage locations).
//
// Lambda2 is the Helmholtz constant, betak2 is the mode Fourier constant.
// ---------------------------------------------------------------------------
{
  register integer  ij;
  register real     tmp, r2, hCon;
  register real     *g1 = G1, *g2 = G2, *g3 = G3, *g4 = G4, *r = ymesh;
  static const real EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;
  static const int  CYL = Geometry::system() == Geometry::Cylindrical;

  if (CYL) {
    if (g3) {
      for (ij = 0; ij < npnp; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < npnp; ij++) {
	r2       = r[ij] * r[ij];
	hCon     = (r2 > EPS) ? (betak2 / r2 + lambda2) : 0.0;
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }

  } else {			// -- Cartesian.
    hCon = betak2 + lambda2;
    if (g3) {
      for (ij = 0; ij < npnp; ij++) {
	tmp      = R [ij];
	R  [ij]  = g1[ij] * R  [ij] + g3[ij] * S  [ij];
	S  [ij]  = g2[ij] * S  [ij] + g3[ij] * tmp;
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    } else {
      for (ij = 0; ij < npnp; ij++) {
	R  [ij] *= g1[ij];
	S  [ij] *= g2[ij];
	tgt[ij]  = g4[ij] * src[ij] * hCon;
      }
    }
  }
}


void Element::grad (real*        tgtA,
		    real*        tgtB,
		    const real** DV  ,
		    const real** DT  ,
		    real*        work) const
// ---------------------------------------------------------------------------
// Operate partial derivative d(tgt)/dxi = d_dr*drdxi + d_ds*dsdxi,
// where the appropriate component of gradient is selected by input
// pointers.  Values are computed at node points.
//
// Work area must be 2*nTot() long.
// ---------------------------------------------------------------------------
{
  real* tmpA = work;
  real* tmpB = tmpA + npnp;
  real* tgt;

  if ((tgt = tgtA)) {
    if (drdx && dsdx) {
      Blas::mxm     (tgt, np, *DT, np, tmpA, np);
      Blas::mxm     (*DV, np, tgt, np, tmpB, np);
      Veclib::vmul  (npnp, tmpA, 1, drdx, 1, tmpA, 1);
      Veclib::vvtvp (npnp, tmpB, 1, dsdx, 1, tmpA, 1, tgt, 1);
    } else if (drdx) {
      Blas::mxm     (tgt, np, *DT, np, tmpA, np);
      Veclib::vmul  (npnp, tmpA, 1, drdx, 1, tgt, 1);
    } else {
      Blas::mxm     (*DV, np, tgt, np, tmpB, np);
      Veclib::vmul  (npnp, tmpB, 1, dsdx, 1, tgt, 1);
    }
  }

  if ((tgt = tgtB)) {
    if (drdy && dsdy) {
      Blas::mxm     (tgt, np, *DT, np, tmpA, np);
      Blas::mxm     (*DV, np, tgt, np, tmpB, np);
      Veclib::vmul  (npnp, tmpA, 1, drdy, 1, tmpA, 1);
      Veclib::vvtvp (npnp, tmpB, 1, dsdy, 1, tmpA, 1, tgt, 1);
    } else if (drdy) {
      Blas::mxm     (tgt, np, *DT, np, tmpA, np);
      Veclib::vmul  (npnp, tmpA, 1, drdy, 1, tgt, 1);
    } else {
      Blas::mxm     (*DV, np, tgt, np, tmpB, np);
      Veclib::vmul  (npnp, tmpB, 1, dsdy, 1, tgt, 1);
    }
  }
}


void Element::gradX (const real* xr,
		     const real* xs,
		     real*       dx) const
// ---------------------------------------------------------------------------
// Partial implementation of x-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (drdx && dsdx) Veclib::vvtvvtp (npnp, xr,1,drdx,1,xs,1,dsdx,1,dx,1);
  else if (drdx)    Veclib::vmul    (npnp, xr,1,drdx,1,dx,1);
  else              Veclib::vmul    (npnp, xs,1,dsdx,1,dx,1);
}


void Element::gradY (const real* yr,
		     const real* ys,
		     real*       dy) const
// ---------------------------------------------------------------------------
// Partial implementation of y-gradient, for use with Femlib::grad2.
// ---------------------------------------------------------------------------
{
  if (drdy && dsdy) Veclib::vvtvvtp (npnp, yr,1,drdy,1,ys,1,dsdy,1,dy,1);
  else if (drdy)    Veclib::vmul    (npnp, yr,1,drdy,1,dy,1);
  else              Veclib::vmul    (npnp, ys,1,dsdy,1,dy,1);
}


void Element::sideGeom (const integer side,
			real*         x   ,
			real*         y   ,
			real*         nx  ,
			real*         ny  ,
			real*         area) const
// ---------------------------------------------------------------------------
// Generate unit outward normal components and change-of-variable
// Jacobian, area, for use in computation of edge integrals.
//
// We will always use Lobatto-Legendre quadrature for these integrals; 
// however, we need to do some recomputation of local forward partial
// derivatives along edges.
//
// Computed vectors have CCW edge-traverse ordering, i.e. are made to operate
// on vectors obtained from base storage using BLAS-conformant copy.
//
// For cylindrical coordinates the area variable is weighted by y (i.e. r).
// ---------------------------------------------------------------------------
{
  if (side < 0 || side >= 4)
    message ("Element::sideGeom", "illegal side", ERROR);

  register integer low, skip;
  const real       **D, *w;
  real             *xr, *xs, *yr, *ys, *len;
  vector<real>     work (np + np);

  Femlib::quad (LL, np, np, 0, 0, &w, 0, 0, &D, 0);

  switch (side) {
  case 0: 
    low  = 0;
    skip = 1;
    xr   = work();
    yr   = xr + np;
        
    Veclib::copy  (np, xmesh + low, skip, x, 1);
    Veclib::copy  (np, ymesh + low, skip, y, 1);

    Blas::gemv    ("T", np, np, 1.0, *D, np, xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", np, np, 1.0, *D, np, ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (np, yr, 1, yr, 1, area, 1, area, 1);

    if   (dsdx) Veclib::smul (np, -1.0, dsdx, skip, nx, 1);
    else        Veclib::zero (np,                   nx, 1);
    if   (dsdy) Veclib::smul (np, -1.0, dsdy, skip, ny, 1);
    else        Veclib::zero (np,                   ny, 1);
    
    break;

  case 1: 
    low  = np - 1;
    skip = np;
    xs   = work();
    ys   = xs + np;

    Veclib::copy  (np, xmesh + low, skip, x, 1);
    Veclib::copy  (np, ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", np, np, 1.0, *D, np, xmesh+low, np, 0.0, xs, 1);
    Blas::gemv    ("T", np, np, 1.0, *D, np, ymesh+low, np, 0.0, ys, 1);
    Veclib::vmul  (np, xs, 1, xs, 1, area, 1);

    Veclib::vvtvp (np, ys, 1, ys, 1, area, 1, area, 1);

    if   (drdx) Veclib::copy (np, drdx+low, skip, nx, 1);
    else        Veclib::zero (np,                 nx, 1);
    if   (drdy) Veclib::copy (np, drdy+low, skip, ny, 1);
    else        Veclib::zero (np,                 ny, 1);
    
    break;

  case 2:
    low  = np * (np - 1);
    skip = -1;
    xr   = work();
    yr   = xr + np;
    
    Veclib::copy  (np, xmesh + low, skip, x, 1);
    Veclib::copy  (np, ymesh + low, skip, y, 1);
	
    Blas::gemv    ("T", np, np, 1.0, *D, np, xmesh+low, 1, 0.0, xr, 1);
    Blas::gemv    ("T", np, np, 1.0, *D, np, ymesh+low, 1, 0.0, yr, 1);
    Veclib::vmul  (np, xr, 1, xr, 1, area, 1);
    Veclib::vvtvp (np, yr, 1, yr, 1, area, 1, area, 1);

    if   (dsdx) Veclib::copy (np, dsdx+low, skip, nx, 1);
    else        Veclib::zero (np,                 nx, 1);
    if   (dsdy) Veclib::copy (np, dsdy+low, skip, ny, 1);
    else        Veclib::zero (np,                 ny, 1);

    break;

  case 3:
    low  = 0;
    skip = -np;
    xs   = work();
    ys   = xs + np;
    
    Veclib::copy  (np, xmesh + low, skip, x, 1);
    Veclib::copy  (np, ymesh + low, skip, y, 1);
      
    Blas::gemv    ("T", np, np, 1.0, *D, np, xmesh+low, np, 0.0, xs, 1);
    Blas::gemv    ("T", np, np, 1.0, *D, np, ymesh+low, np, 0.0, ys, 1);
    Veclib::vmul  (np, xs, 1, xs, 1, area, 1);
    Veclib::vvtvp (np, ys, 1, ys, 1, area, 1, area, 1);

    if   (drdx) Veclib::smul (np, -1.0, drdx, skip, nx, 1);
    else        Veclib::zero (np,                   nx, 1);
    if   (drdy) Veclib::smul (np, -1.0, drdy, skip, ny, 1);
    else        Veclib::zero (np,                   ny, 1);

    break;
  }
  
  Veclib::vsqrt  (np, area, 1, area, 1);
  Veclib::vmul   (np, area, 1, w,    1, area, 1);
  if (Geometry::system() == Geometry::Cylindrical)
    Veclib::vmul (np, area, 1, ymesh+low, skip, area, 1);

  len = work();

  Veclib::vhypot (np, nx, 1, ny,  1, len, 1);
  Veclib::vdiv   (np, nx, 1, len, 1, nx,  1);
  Veclib::vdiv   (np, ny, 1, len, 1, ny,  1);
}


void Element::sideEval (const integer side,
			real*         tgt ,
			const char*   func) const
// ---------------------------------------------------------------------------
// Evaluate function func along side of element, returning in tgt.
//
// The function can use variables "x", "y" & "t" (and any
// floating-point parameters previously set).
// ---------------------------------------------------------------------------
{
  vector<real> work(np + np);
  real         *x, *y;

  register  integer estart, skip;
  terminal (side, estart, skip);

  x = work();
  y = x + np;

  Veclib::copy (np, xmesh + estart, skip, x, 1);
  Veclib::copy (np, ymesh + estart, skip, y, 1);

  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (np, x, y, tgt);
}


void Element::sideGrad (const integer side,
			const real*   src ,
			real*         c1  ,
			real*         c2  ) const
// ---------------------------------------------------------------------------
// Using geometric factors for this Element, return the first and
// second component, c1 and/or c2, of grad src (length nTot()) along
// side.
//
// We have to take some special care on sides 2 & 3, where the usual
// skips are negative: we instead use positive skips for formation of
// dc/dr, dc/ds, then a -1 skip when multiplying by dr/dx, ds/dx, etc.
// ---------------------------------------------------------------------------
{
  register integer d, estart, skip;
  terminal (side, estart, skip);
  
  vector<real> work (np + np);
  const real   **DV, **DT;
  real         *ddr, *dds;

  ddr = work();
  dds = ddr + np;

  Femlib::quad (LL, np, np, 0, 0, 0, 0, 0, &DV, &DT);

  // -- Make dc/dr, dc/ds along element edge.

  switch (side) {
  case 0:
    d = 1;
    Blas::gemv ("T", np, np, 1.0, *DV, np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N", np, np, 1.0, src, np, *DV + estart, d*skip, 0.0, dds, 1);
    break;
  case 1:
    d = 1;
    Blas::gemv ("T", np, np, 1.0, src, np, *DT + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T", np, np, 1.0, *DV, np, src + estart, d*skip, 0.0, dds, 1);
    break;
  case 2:
    d = -1;
    Blas::gemv ("T", np, np, 1.0, *DV, np, src + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("N", np, np, 1.0, src, np, *DV + estart, d*skip, 0.0, dds, 1);
    break;
  case 3:
    d = -1;
    Blas::gemv ("T", np, np, 1.0, src, np, *DT + estart, d*skip, 0.0, ddr, 1);
    Blas::gemv ("T", np, np, 1.0, *DV, np, src + estart, d*skip, 0.0, dds, 1);
    break;
  }

  // -- dc/dx = dc/dr * dr/dx + dc/ds * ds/dx.

  if (c1) {
    if   (drdx) Veclib::vmul  (np, ddr, d, drdx + estart, skip, c1, 1);
    else        Veclib::zero  (np, c1, 1);
    if   (dsdx) Veclib::vvtvp (np, dds, d, dsdx + estart, skip, c1, 1, c1, 1);
  }
  
  // -- dc/dy = dc/dr * dr/dy + dc/ds * ds/dy.

  if (c2) {
    if   (drdy) Veclib::vmul  (np, ddr, d, drdy + estart, skip, c2, 1);
    else        Veclib::zero  (np, c2, 1);
    if   (dsdy) Veclib::vvtvp (np, dds, d, dsdy + estart, skip, c2, 1, c2, 1);
  }
}


void Element::sideGet (const integer  side,
		       const real*    src ,
		       real*          tgt ) const
// ---------------------------------------------------------------------------
// Load edge vector tgt with values from internal storage src.
// ---------------------------------------------------------------------------
{
  register integer start, skip;

  terminal (side, start, skip);

  Veclib::copy (np, src + start, skip, tgt, 1);
}


void Element::evaluate (const char* func,
			real*       tgt ) const
// ---------------------------------------------------------------------------
// Evaluate function over mesh points, store in tgt.  Function can
// explicitly use "x" and "y", for which mesh values are used.
// ---------------------------------------------------------------------------
{
  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (npnp, xmesh, ymesh, tgt);
}


real Element::integral (const char* func) const
// ---------------------------------------------------------------------------
// Return integral of func over element, using element quadrature
// rule.
// ---------------------------------------------------------------------------
{
  real         intgrl;
  vector<real> tmp (npnp);

  Femlib::prepVec  ("x y", func);
  Femlib__parseVec (npnp, xmesh, ymesh, tmp());

  Veclib::vmul (npnp, tmp(), 1, G4, 1, tmp(), 1);

  intgrl = Veclib::sum (npnp, tmp(), 1);
  
  return intgrl;
}


real Element::integral (const real* src,
			real*       tmp) const
// ---------------------------------------------------------------------------
// Discrete approximation to the integral of element src vector.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (npnp, src, 1, G4,  1, tmp, 1);
  return Veclib::sum (npnp, tmp, 1);
}


real Element::area () const
// ---------------------------------------------------------------------------
// Discrete approximation to area of element, using GLL quadrature.
// ---------------------------------------------------------------------------
{ 
  return Veclib::sum (npnp, G4, 1);
}


void Element::weight (real* tgt) const
// ---------------------------------------------------------------------------
// Multiply tgt by elemental mass matrix.
// ---------------------------------------------------------------------------
{
  Veclib::vmul (npnp, tgt, 1, G4, 1, tgt, 1);
}


void Element::lengthScale (real* tgt) const
// ---------------------------------------------------------------------------
// Load tgt with information about local elemental length scale.
// ---------------------------------------------------------------------------
{
  Veclib::copy (npnp, delta, 1, tgt, 1);
}


real Element::norm_inf (const real* src) const
// ---------------------------------------------------------------------------
// Return infinity-norm of element value.
// ---------------------------------------------------------------------------
{
  return fabs (src[Blas::iamax (npnp, src, 1)]);
}


real Element::norm_L2 (const real* src) const
// ---------------------------------------------------------------------------
// Return L2-norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register integer i;
  register real    L2 = 0.0;
  register real*   dA = G4;

  for (i = 0; i < npnp; i++) L2 += src[i] * src[i] * dA[i];

  return sqrt (L2);
}


real Element::norm_H1 (const real* src) const
// ---------------------------------------------------------------------------
// Return Sobolev-1 norm of Element value, using Element quadrature rule.
// ---------------------------------------------------------------------------
{
  register real    H1 = 0;
  register integer i;
  vector<real>     work (3 * npnp);
  register real    *dA = G4, *u = work(), *gw = u + npnp;
  const real       **DV, **DT;

  Femlib::quad (LL, np, np, 0, 0, 0, 0, 0, &DV, &DT);

  // -- Add in L2 norm of u.

  for (i = 0; i < npnp; i++) H1 += src[i] * src[i] * dA[i];

  // -- Add in L2 norm of grad u.

  Veclib::copy (npnp, src, 1, u, 1);
  grad (u, 0, DV, DT, gw);
  for (i = 0; i < npnp; i++) H1 += u[i] * u[i] * dA[i];

  Veclib::copy (npnp, src, 1, u, 1);
  grad (0, u, DV, DT, gw);
  for (i = 0; i < npnp; i++) H1 += u[i] * u[i] * dA[i];

  return sqrt (H1);
}


void Element::divR (real* src) const
// ---------------------------------------------------------------------------
// Divide src by y (i.e. r in cylindrical coordinates), take special
// action where r = 0.  This is used in taking theta component of
// gradient.
// ---------------------------------------------------------------------------
{
  register integer  i;
  register real     rad, rinv;
  register real*    y   = ymesh;
  static const real EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  for (i = 0; i < npnp; i++) {
    rad     = y[i];
    rinv    = (rad > EPS) ? 1.0 / rad : 0.0;
    src[i] *= rinv;
  }
}


void Element::mulR (real* src) const
// ---------------------------------------------------------------------------
// Multiply src by y (i.e. r in cylindrical coordinates).
// ---------------------------------------------------------------------------
{
  Veclib::vmul (npnp, src, 1, ymesh, 1, src, 1);
}


void Element::sideGetR (const integer side,
			real*         tgt ) const
// ---------------------------------------------------------------------------
// Load r (i.e. y) values for side into tgt.
// ---------------------------------------------------------------------------
{
  register integer estart, skip;

  terminal (side, estart, skip);

  Veclib::copy (np, ymesh + estart, skip, tgt, 1);
}


void Element::sideDivR (const integer side,
			const real*   src ,
			real*         tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y (i.e. r), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  integer           i, base,  skip;
  real              r, rinv,  *y;
  const real        *s;
  static const real EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = ymesh;
    s    = src;
    break;
  case 1:
    base = np - 1;
    skip = np;
    y    = ymesh + base;
    s    = src   + base;
    break;
  case 2:
    base = np * np - 1;
    skip = -1;
    y    = ymesh + base;
    s    = src   + base;
    break;
  case 3:
    base = np * (np - 1);
    skip = -np;
    y    = ymesh + base;
    s    = src   + base;
    break;
  }

  for (i = 0; i < np; i++) {
    r      = y[i*skip];
    rinv   = (r > EPS) ? 1.0 / r : 0.0;
    tgt[i] = rinv * s[i*skip];
  }
}


void Element::sideDivR2 (const integer side,
			 const real*   src ,
			 real*         tgt ) const
// ---------------------------------------------------------------------------
// Deliver in tgt the side traverse of src (elemental storage) divided
// by y^2 (i.e. r^2), take special action where r = 0.
// ---------------------------------------------------------------------------
{
  register integer    i, base, skip;
  register real       r, rinv2, *y;
  register const real *s;
  static const real   EPS = (sizeof (real) == sizeof (double)) ? EPSDP : EPSSP;

  switch (side) {
  case 0: 
    base = 0;
    skip = 1;
    y    = ymesh;
    s    = src;
    break;
  case 1:
    base = np - 1;
    skip = np;
    y    = ymesh + base;
    s    = src   + base;
    break;
  case 2:
    base = np * np - 1;
    skip = -1;
    y    = ymesh + base;
    s    = src   + base;
    break;
  case 3:
    base = np * (np - 1);
    skip = -np;
    y    = ymesh + base;
    s    = src   + base;
    break;
  }

  for (i = 0; i < np; i++) {
    r      = y[i*skip];
    rinv2  = (r > EPS) ? 1.0 / sqr(r) : 0.0;
    tgt[i] = rinv2 * s[i*skip];
  }
}


integer Element::locate (const real    x    ,
			 const real    y    ,
			 real&         r    ,
			 real&         s     ,
			 const integer guess) const
// ---------------------------------------------------------------------------
// If x & y fall in this element, compute the corresponding r & s
// values, and return 1.  Otherwise return 0.
//
// If guess = 0 (the default argument), the input value of (r, s) is used
// as an initial guess for N--R iteration.  Otherwise the  (r, s) value that
// corresponds to the closest point in the Element mesh to (x, y) is used.
// Fairly loose tolerances are employed.
// ---------------------------------------------------------------------------
{
  static real   EPS    = 0.0;
  const integer MaxItn = 8;
  const real    DIVERG = 20.0;
  real          *J, *F, *ir, *is, *dr, *ds, *tp;
  vector<real>  work (5 * np + 6);
  integer       ipiv[2], info, i, j;
  
  tp = work();
  ir = tp + np;
  is = ir + np;
  dr = is + np;
  ds = dr + np;
  J  = ds + np;
  F  = J  + 4;

  if (EPS == 0.0) EPS = Femlib::value ("TOL_POS");

  if (guess) {
    vector<real> tmp (2 * npnp);
    const real*  knot;
    real         *tx = tmp(), *ty = tmp() + npnp;

    const real diag =
      max (hypot(xmesh[np*np-1]  -xmesh[0],    ymesh[np*np-1]  -ymesh[0])   ,
	   hypot(xmesh[np*(np-1)]-xmesh[np-1], ymesh[np*(np-1)]-ymesh[np-1]));

    Femlib::quad     (LL, np, np, &knot, 0, 0, 0, 0, 0, 0);
    Veclib::ssub     (npnp, x, xmesh, 1, tx, 1);
    Veclib::ssub     (npnp, y, ymesh, 1, ty, 1);
    Veclib::vvtvvtp  (npnp, tx, 1, tx, 1, ty, 1, ty, 1, tx, 1);
    
    i = Veclib::imin (npnp, tx, 1);

    if (tx[i] - diag * diag > 0.0) return 0;

    j = i % np;
    i = (i - j) / np;

    r = knot[i];
    s = knot[j];
    
    if      (r >  0.99) r =  0.99;
    else if (r < -0.99) r = -0.99;
    if      (s >  0.99) s =  0.99;
    else if (s < -0.99) s = -0.99;
  }

  i = 0;
  do {
    Femlib::interp (LL, np, r, s, ir, is, dr, ds);

               Blas::gemv ("T", np, np, 1.0, xmesh, np, ir, 1, 0.0, tp, 1);
    F[0] = x - Blas::dot  (np, is, 1, tp, 1);
    J[2] =     Blas::dot  (np, ds, 1, tp, 1);
               Blas::gemv ("T", np, np, 1.0, ymesh, np, ir, 1, 0.0, tp, 1);
    F[1] = y - Blas::dot  (np, is, 1, tp, 1);
    J[3] =     Blas::dot  (np, ds, 1, tp, 1);
               Blas::gemv ("T", np, np, 1.0, xmesh, np, dr, 1, 0.0, tp, 1);
    J[0] =     Blas::dot  (np, is, 1, tp, 1);
               Blas::gemv ("T", np, np, 1.0, ymesh, np, dr, 1, 0.0, tp, 1);
    J[1] =     Blas::dot  (np, is, 1, tp, 1);
    
    Lapack::gesv (2, 1, J, 2, ipiv, F, 2, info);
    
    r += F[0];
    s += F[1];

    if (fabs (r) > DIVERG || fabs (s) > DIVERG) {
#if defined(DEBUG)
      cerr << "D" << endl;
#endif
      return 0;
    }

  } while (++i < MaxItn && (fabs (F[0]) > EPS || fabs (F[1]) > EPS));

#if defined(DEBUG)
  if (i == MaxItn) cerr << "M" << endl;
  else if (fabs (r) > 1.0 + EPS && fabs(s) > 1.0 + EPS) cerr << "O" << endl;
#endif

  return (i < MaxItn && fabs (r) < 1.0 + EPS && fabs(s) < 1.0 + EPS) ? 1 : 0;
}


real Element::probe (const real  r  ,
		     const real  s  ,
		     const real* src) const
// ---------------------------------------------------------------------------
// Return the value of field storage located at r, s, in this element.
// ---------------------------------------------------------------------------
{
  real         *ir, *is, *tp;
  vector<real> work (3 * np);

  ir = work();
  is = ir + np;
  tp = is + np;

  Femlib::interp   (LL, np, r, s, ir, is, 0, 0);
  Blas::gemv       ("T", np, np, 1.0, src, np, ir, 1, 0.0, tp, 1);

  return Blas::dot (np, is, 1, tp, 1);
}


real Element::CFL (const real  d,
		   const real* u,
		   const real* v) const
// ---------------------------------------------------------------------------
// Return estimate of local inverse timescale for CFL stability
// condition, for either the x or y velocity component, selected by
// input pointer.
//
//   CFL_x = max (|u| / dx),
//   CFL_y = max (|v| / dy),
//
// where dx or dy are estimated from local element geometric
// information:
//
//   dx = (dx/dr + dx/ds) * d,
//   dy = (dy/dr + dy/ds) * d,
//
// and d is a mesh spacing in canonical coordinates, estimated as the
// minimum to be conservative (and supplied as input).
//
// The local CFL number is then D_T * CFL
// ---------------------------------------------------------------------------
{
  register integer i;
  vector<real>     work (npnp);
  register real*   tmp = work();

  Veclib::zero (npnp, tmp, 1);

  if        (u) {
    if (drdx) for (i = 0; i < npnp; i++) tmp[i] += d * fabs (drdx[i]);
    if (dsdx) for (i = 0; i < npnp; i++) tmp[i] += d * fabs (dsdx[i]);
    Veclib::vdiv (npnp, u, 1, tmp, 1, tmp, 1);
  } else if (v) {
    if (drdy) for (i = 0; i < npnp; i++) tmp[i] += d * fabs (drdy[i]);
    if (dsdy) for (i = 0; i < npnp; i++) tmp[i] += d * fabs (dsdy[i]);
    Veclib::vdiv (npnp, v, 1, tmp, 1, tmp, 1);
  }

  i = Blas::iamax (npnp, tmp, 1);
  return fabs (tmp[i]);
}
